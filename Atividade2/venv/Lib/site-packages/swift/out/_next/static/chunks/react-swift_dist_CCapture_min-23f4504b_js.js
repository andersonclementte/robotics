/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["react-swift_dist_CCapture_min-23f4504b_js"],{

/***/ "../../react-swift/dist/CCapture.min-23f4504b.js":
/*!*******************************************************!*\
  !*** ../../react-swift/dist/CCapture.min-23f4504b.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"C\": function() { return /* binding */ CCapture_min$1; }\n/* harmony export */ });\n/* harmony import */ var _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_commonjsHelpers-1c8beb5f.js */ \"../../react-swift/dist/_commonjsHelpers-1c8beb5f.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../react-swift/node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nvar CCapture_min$2 = {exports: {}};\n\nvar tar = {exports: {}};\n\n(function (module) {\n\n  (function () {\n\n    var lookup = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'];\n\n    function clean(length) {\n      var i,\n          buffer = new Uint8Array(length);\n\n      for (i = 0; i < length; i += 1) {\n        buffer[i] = 0;\n      }\n\n      return buffer;\n    }\n\n    function extend(orig, length, addLength, multipleOf) {\n      var newSize = length + addLength,\n          buffer = clean((parseInt(newSize / multipleOf) + 1) * multipleOf);\n      buffer.set(orig);\n      return buffer;\n    }\n\n    function pad(num, bytes, base) {\n      num = num.toString(base || 8);\n      return '000000000000'.substr(num.length + 12 - bytes) + num;\n    }\n\n    function stringToUint8(input, out, offset) {\n      var i, length;\n      out = out || clean(input.length);\n      offset = offset || 0;\n\n      for (i = 0, length = input.length; i < length; i += 1) {\n        out[offset] = input.charCodeAt(i);\n        offset += 1;\n      }\n\n      return out;\n    }\n\n    function uint8ToBase64(uint8) {\n      var i,\n          extraBytes = uint8.length % 3,\n          // if we have 1 byte left, pad 2 bytes\n      output = '',\n          temp,\n          length;\n\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3f] + lookup[num >> 12 & 0x3f] + lookup[num >> 6 & 0x3f] + lookup[num & 0x3f];\n      } // go through the array every three bytes, we'll deal with trailing stuff later\n\n\n      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n        output += tripletToBase64(temp);\n      } // this prevents an ERR_INVALID_URL in Chrome (Firefox okay)\n\n\n      switch (output.length % 4) {\n        case 1:\n          output += '=';\n          break;\n\n        case 2:\n          output += '==';\n          break;\n      }\n\n      return output;\n    }\n\n    window.utils = {};\n    window.utils.clean = clean;\n    window.utils.pad = pad;\n    window.utils.extend = extend;\n    window.utils.stringToUint8 = stringToUint8;\n    window.utils.uint8ToBase64 = uint8ToBase64;\n  })();\n\n  (function () {\n    /*\n    struct posix_header {             // byte offset\n    char name[100];               //   0\n    char mode[8];                 // 100\n    char uid[8];                  // 108\n    char gid[8];                  // 116\n    char size[12];                // 124\n    char mtime[12];               // 136\n    char chksum[8];               // 148\n    char typeflag;                // 156\n    char linkname[100];           // 157\n    char magic[6];                // 257\n    char version[2];              // 263\n    char uname[32];               // 265\n    char gname[32];               // 297\n    char devmajor[8];             // 329\n    char devminor[8];             // 337\n    char prefix[155];             // 345\n                                    // 500\n    };\n    */\n\n    var utils = window.utils,\n        headerFormat;\n    headerFormat = [{\n      field: 'fileName',\n      length: 100\n    }, {\n      field: 'fileMode',\n      length: 8\n    }, {\n      field: 'uid',\n      length: 8\n    }, {\n      field: 'gid',\n      length: 8\n    }, {\n      field: 'fileSize',\n      length: 12\n    }, {\n      field: 'mtime',\n      length: 12\n    }, {\n      field: 'checksum',\n      length: 8\n    }, {\n      field: 'type',\n      length: 1\n    }, {\n      field: 'linkName',\n      length: 100\n    }, {\n      field: 'ustar',\n      length: 8\n    }, {\n      field: 'owner',\n      length: 32\n    }, {\n      field: 'group',\n      length: 32\n    }, {\n      field: 'majorNumber',\n      length: 8\n    }, {\n      field: 'minorNumber',\n      length: 8\n    }, {\n      field: 'filenamePrefix',\n      length: 155\n    }, {\n      field: 'padding',\n      length: 12\n    }];\n\n    function formatHeader(data, cb) {\n      var buffer = utils.clean(512),\n          offset = 0;\n      headerFormat.forEach(function (value) {\n        var str = data[value.field] || '',\n            i,\n            length;\n\n        for (i = 0, length = str.length; i < length; i += 1) {\n          buffer[offset] = str.charCodeAt(i);\n          offset += 1;\n        }\n\n        offset += value.length - i; // space it out with nulls\n      });\n\n      if (typeof cb === 'function') {\n        return cb(buffer, offset);\n      }\n\n      return buffer;\n    }\n\n    window.header = {};\n    window.header.structure = headerFormat;\n    window.header.format = formatHeader;\n  })();\n\n  (function () {\n\n    var header = window.header,\n        utils = window.utils,\n        recordSize = 512,\n        blockSize;\n\n    function Tar(recordsPerBlock) {\n      this.written = 0;\n      blockSize = (recordsPerBlock || 20) * recordSize;\n      this.out = utils.clean(blockSize);\n      this.blocks = [];\n      this.length = 0;\n    }\n\n    Tar.prototype.append = function (filepath, input, opts, callback) {\n      var data, checksum, mode, mtime, uid, gid, headerArr;\n\n      if (typeof input === 'string') {\n        input = utils.stringToUint8(input);\n      } else if (input.constructor !== Uint8Array.prototype.constructor) {\n        throw 'Invalid input type. You gave me: ' + input.constructor.toString().match(/function\\s*([$A-Za-z_][0-9A-Za-z_]*)\\s*\\(/)[1];\n      }\n\n      if (typeof opts === 'function') {\n        opts = {};\n      }\n\n      opts = opts || {};\n      mode = opts.mode || parseInt('777', 8) & 0xfff;\n      mtime = opts.mtime || Math.floor(+new Date() / 1000);\n      uid = opts.uid || 0;\n      gid = opts.gid || 0;\n      data = {\n        fileName: filepath,\n        fileMode: utils.pad(mode, 7),\n        uid: utils.pad(uid, 7),\n        gid: utils.pad(gid, 7),\n        fileSize: utils.pad(input.length, 11),\n        mtime: utils.pad(mtime, 11),\n        checksum: '        ',\n        type: '0',\n        // just a file\n        ustar: 'ustar  ',\n        owner: opts.owner || '',\n        group: opts.group || ''\n      }; // calculate the checksum\n\n      checksum = 0;\n      Object.keys(data).forEach(function (key) {\n        var i,\n            value = data[key],\n            length;\n\n        for (i = 0, length = value.length; i < length; i += 1) {\n          checksum += value.charCodeAt(i);\n        }\n      });\n      data.checksum = utils.pad(checksum, 6) + '\\u0000 ';\n      headerArr = header.format(data);\n      var headerLength = Math.ceil(headerArr.length / recordSize) * recordSize;\n      var inputLength = Math.ceil(input.length / recordSize) * recordSize;\n      this.blocks.push({\n        header: headerArr,\n        input: input,\n        headerLength: headerLength,\n        inputLength: inputLength\n      });\n    };\n\n    Tar.prototype.save = function () {\n      var buffers = [];\n      var chunks = [];\n      var length = 0;\n      var max = Math.pow(2, 20);\n      var chunk = [];\n      this.blocks.forEach(function (b) {\n        if (length + b.headerLength + b.inputLength > max) {\n          chunks.push({\n            blocks: chunk,\n            length: length\n          });\n          chunk = [];\n          length = 0;\n        }\n\n        chunk.push(b);\n        length += b.headerLength + b.inputLength;\n      });\n      chunks.push({\n        blocks: chunk,\n        length: length\n      });\n      chunks.forEach(function (c) {\n        var buffer = new Uint8Array(c.length);\n        var written = 0;\n        c.blocks.forEach(function (b) {\n          buffer.set(b.header, written);\n          written += b.headerLength;\n          buffer.set(b.input, written);\n          written += b.inputLength;\n        });\n        buffers.push(buffer);\n      });\n      buffers.push(new Uint8Array(2 * recordSize));\n      return new Blob(buffers, {\n        type: 'octet/stream'\n      });\n    };\n\n    Tar.prototype.clear = function () {\n      this.written = 0;\n      this.out = utils.clean(blockSize);\n    };\n\n    {\n      module.exports = Tar;\n    }\n  })();\n})(tar);\n\nvar download = {exports: {}};\n\n(function (module, exports) {\n\n  (function (root, factory) {\n    {\n      // Node. Does not work with strict CommonJS, but\n      // only CommonJS-like environments that support module.exports,\n      // like Node.\n      module.exports = factory();\n    }\n  })(_commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c, function () {\n    return function download(data, strFileName, strMimeType) {\n      var self = window,\n          // this script is only for browsers anyway...\n      defaultMime = 'application/octet-stream',\n          // this default mime also triggers iframe downloads\n      mimeType = strMimeType || defaultMime,\n          payload = data,\n          url = !strFileName && !strMimeType && payload,\n          anchor = document.createElement('a'),\n          toString = function (a) {\n        return String(a);\n      },\n          myBlob = self.Blob || self.MozBlob || self.WebKitBlob || toString,\n          fileName = strFileName || 'download',\n          blob,\n          reader;\n\n      myBlob = myBlob.call ? myBlob.bind(self) : Blob;\n\n      if (String(this) === 'true') {\n        //reverse arguments, allowing download.bind(true, \"text/xml\", \"export.xml\") to act as a callback\n        payload = [payload, mimeType];\n        mimeType = payload[0];\n        payload = payload[1];\n      }\n\n      if (url && url.length < 2048) {\n        // if no filename and no mime, assume a url was passed as the only argument\n        fileName = url.split('/').pop().split('?')[0];\n        anchor.href = url; // assign href prop to temp anchor\n\n        if (anchor.href.indexOf(url) !== -1) {\n          // if the browser determines that it's a potentially valid url path:\n          var ajax = new XMLHttpRequest();\n          ajax.open('GET', url, true);\n          ajax.responseType = 'blob';\n\n          ajax.onload = function (e) {\n            download(e.target.response, fileName, defaultMime);\n          };\n\n          setTimeout(function () {\n            ajax.send();\n          }, 0); // allows setting custom ajax headers using the return:\n\n          return ajax;\n        } // end if valid url?\n\n      } // end if url?\n      //go ahead and download dataURLs right away\n\n\n      if (/^data:([\\w+-]+\\/[\\w+.-]+)?[,;]/.test(payload)) {\n        if (payload.length > 1024 * 1024 * 1.999 && myBlob !== toString) {\n          payload = dataUrlToBlob(payload);\n          mimeType = payload.type || defaultMime;\n        } else {\n          return navigator.msSaveBlob // IE10 can't do a[download], only Blobs:\n          ? navigator.msSaveBlob(dataUrlToBlob(payload), fileName) : saver(payload); // everyone else can save dataURLs un-processed\n        }\n      } else {\n        //not data url, is it a string with special needs?\n        if (/([\\x80-\\xff])/.test(payload)) {\n          var i = 0,\n              tempUiArr = new Uint8Array(payload.length),\n              mx = tempUiArr.length;\n\n          for (i; i < mx; ++i) tempUiArr[i] = payload.charCodeAt(i);\n\n          payload = new myBlob([tempUiArr], {\n            type: mimeType\n          });\n        }\n      }\n\n      blob = payload instanceof myBlob ? payload : new myBlob([payload], {\n        type: mimeType\n      });\n\n      function dataUrlToBlob(strUrl) {\n        var parts = strUrl.split(/[:;,]/),\n            type = parts[1],\n            indexDecoder = strUrl.indexOf('charset') > 0 ? 3 : 2,\n            decoder = parts[indexDecoder] == 'base64' ? atob : decodeURIComponent,\n            binData = decoder(parts.pop()),\n            mx = binData.length,\n            i = 0,\n            uiArr = new Uint8Array(mx);\n\n        for (i; i < mx; ++i) uiArr[i] = binData.charCodeAt(i);\n\n        return new myBlob([uiArr], {\n          type: type\n        });\n      }\n\n      function saver(url, winMode) {\n        if ('download' in anchor) {\n          //html5 A[download]\n          anchor.href = url;\n          anchor.setAttribute('download', fileName);\n          anchor.className = 'download-js-link';\n          anchor.innerHTML = 'downloading...';\n          anchor.style.display = 'none';\n          anchor.addEventListener('click', function (e) {\n            e.stopPropagation();\n            this.removeEventListener('click', arguments.callee);\n          });\n          document.body.appendChild(anchor);\n          setTimeout(function () {\n            anchor.click();\n            document.body.removeChild(anchor);\n\n            if (winMode === true) {\n              setTimeout(function () {\n                self.URL.revokeObjectURL(anchor.href);\n              }, 250);\n            }\n          }, 66);\n          return true;\n        } // handle non-a[download] safari as best we can:\n\n\n        if (/(Version)\\/(\\d+)\\.(\\d+)(?:\\.(\\d+))?.*Safari\\//.test(navigator.userAgent)) {\n          if (/^data:/.test(url)) url = 'data:' + url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n\n          if (!window.open(url)) {\n            // popup blocked, offer direct download:\n            if (confirm('Displaying New Document\\n\\nUse Save As... to download, then click back to return to this page.')) {\n              location.href = url;\n            }\n          }\n\n          return true;\n        } //do iframe dataURL download (old ch+FF):\n\n\n        var f = document.createElement('iframe');\n        document.body.appendChild(f);\n\n        if (!winMode && /^data:/.test(url)) {\n          // force a mime that will download:\n          url = 'data:' + url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n        }\n\n        f.src = url;\n        setTimeout(function () {\n          document.body.removeChild(f);\n        }, 333);\n      } //end saver\n\n\n      if (navigator.msSaveBlob) {\n        // IE10+ : (has Blob, but not a[download] or URL)\n        return navigator.msSaveBlob(blob, fileName);\n      }\n\n      if (self.URL) {\n        // simple fast and modern way using Blob and URL:\n        saver(self.URL.createObjectURL(blob), true);\n      } else {\n        // handle non-Blob()+non-URL browsers:\n        if (typeof blob === 'string' || blob.constructor === toString) {\n          try {\n            return saver('data:' + mimeType + ';base64,' + self.btoa(blob));\n          } catch (y) {\n            return saver('data:' + mimeType + ',' + encodeURIComponent(blob));\n          }\n        } // Blob but not URL support:\n\n\n        reader = new FileReader();\n\n        reader.onload = function (e) {\n          saver(this.result);\n        };\n\n        reader.readAsDataURL(blob);\n      }\n\n      return true;\n    };\n    /* end download() */\n  });\n})(download);\n\nvar gif = {};\n\n(function (c) {\n  function a(b, d) {\n    if ({}.hasOwnProperty.call(a.cache, b)) return a.cache[b];\n    var e = a.resolve(b);\n    if (!e) throw new Error('Failed to resolve module ' + b);\n    var c = {\n      id: b,\n      require: a,\n      filename: b,\n      exports: {},\n      loaded: !1,\n      parent: d,\n      children: []\n    };\n    d && d.children.push(c);\n    var f = b.slice(0, b.lastIndexOf('/') + 1);\n    return a.cache[b] = c.exports, e.call(c.exports, c, c.exports, f, b), c.loaded = !0, a.cache[b] = c.exports;\n  }\n  a.modules = {}, a.cache = {}, a.resolve = function (b) {\n    return {}.hasOwnProperty.call(a.modules, b) ? a.modules[b] : void 0;\n  }, a.define = function (b, c) {\n    a.modules[b] = c;\n  };\n\n  var b = function (a) {\n    return a = '/', {\n      title: 'browser',\n      version: 'v0.10.26',\n      browser: !0,\n      env: {},\n      argv: [],\n      nextTick: c.setImmediate || function (a) {\n        setTimeout(a, 0);\n      },\n      cwd: function () {\n        return a;\n      },\n      chdir: function (b) {\n        a = b;\n      }\n    };\n  }();\n\n  a.define('/gif.coffee', function (d, m, l, k) {\n    function g(a, b) {\n      return {}.hasOwnProperty.call(a, b);\n    }\n\n    function j(d, b) {\n      for (var a = 0, c = b.length; a < c; ++a) if (a in b && b[a] === d) return !0;\n\n      return !1;\n    }\n\n    function i(a, b) {\n      function d() {\n        this.constructor = a;\n      }\n\n      for (var c in b) g(b, c) && (a[c] = b[c]);\n\n      return d.prototype = b.prototype, a.prototype = new d(), a.__super__ = b.prototype, a;\n    }\n\n    var h, c, f, b, e;\n    f = a('events', d).EventEmitter, h = a('/browser.coffee', d), e = function (d) {\n      function a(d) {\n        var a, b;\n        this.running = !1, this.options = {}, this.frames = [], this.freeWorkers = [], this.activeWorkers = [], this.setOptions(d);\n\n        for (a in c) b = c[a], null != this.options[a] ? this.options[a] : this.options[a] = b;\n      }\n\n      return i(a, d), c = {\n        workerScript: 'gif.worker.js',\n        workers: 2,\n        repeat: 0,\n        background: '#fff',\n        quality: 10,\n        width: null,\n        height: null,\n        transparent: null\n      }, b = {\n        delay: 500,\n        copy: !1\n      }, a.prototype.setOption = function (a, b) {\n        return this.options[a] = b, null != this._canvas && (a === 'width' || a === 'height') ? this._canvas[a] = b : void 0;\n      }, a.prototype.setOptions = function (b) {\n        var a, c;\n        return function (d) {\n          for (a in b) {\n            if (!g(b, a)) continue;\n            c = b[a], d.push(this.setOption(a, c));\n          }\n\n          return d;\n        }.call(this, []);\n      }, a.prototype.addFrame = function (a, d) {\n        var c, e;\n        null == d && (d = {}), c = {}, c.transparent = this.options.transparent;\n\n        for (e in b) c[e] = d[e] || b[e];\n\n        if (null != this.options.width || this.setOption('width', a.width), null != this.options.height || this.setOption('height', a.height), 'undefined' !== typeof ImageData && null != ImageData && a instanceof ImageData) c.data = a.data;else if ('undefined' !== typeof CanvasRenderingContext2D && null != CanvasRenderingContext2D && a instanceof CanvasRenderingContext2D || 'undefined' !== typeof WebGLRenderingContext && null != WebGLRenderingContext && a instanceof WebGLRenderingContext) d.copy ? c.data = this.getContextData(a) : c.context = a;else if (null != a.childNodes) d.copy ? c.data = this.getImageData(a) : c.image = a;else throw new Error('Invalid image');\n        return this.frames.push(c);\n      }, a.prototype.render = function () {\n        var a;\n        if (this.running) throw new Error('Already running');\n        if (!(null != this.options.width && null != this.options.height)) throw new Error('Width and height must be set prior to rendering');\n        this.running = !0, this.nextFrame = 0, this.finishedFrames = 0, this.imageParts = function (c) {\n          for (var b = function () {\n            var b;\n            b = [];\n\n            for (var a = 0; 0 <= this.frames.length ? a < this.frames.length : a > this.frames.length; 0 <= this.frames.length ? ++a : --a) b.push(a);\n\n            return b;\n          }.apply(this, arguments), a = 0, e = b.length; a < e; ++a) c.push(null);\n\n          return c;\n        }.call(this, []), a = this.spawnWorkers();\n\n        for (var c = function () {\n          var c;\n          c = [];\n\n          for (var b = 0; 0 <= a ? b < a : b > a; 0 <= a ? ++b : --b) c.push(b);\n\n          return c;\n        }.apply(this, arguments), b = 0, e = c.length; b < e; ++b) this.renderNextFrame();\n\n        return this.emit('start'), this.emit('progress', 0);\n      }, a.prototype.abort = function () {\n        var a;\n\n        while (!0) {\n          if (a = this.activeWorkers.shift(), !(null != a)) break;\n          console.log('killing active worker'), a.terminate();\n        }\n\n        return this.running = !1, this.emit('abort');\n      }, a.prototype.spawnWorkers = function () {\n        var a;\n        return a = Math.min(this.options.workers, this.frames.length), function () {\n          var c;\n          c = [];\n\n          for (var b = this.freeWorkers.length; this.freeWorkers.length <= a ? b < a : b > a; this.freeWorkers.length <= a ? ++b : --b) c.push(b);\n\n          return c;\n        }.apply(this, arguments).forEach(function (a) {\n          return function (c) {\n            var b;\n            return console.log('spawning worker ' + c), b = new Worker(a.options.workerScript), b.onmessage = function (a) {\n              return function (c) {\n                return a.activeWorkers.splice(a.activeWorkers.indexOf(b), 1), a.freeWorkers.push(b), a.frameFinished(c.data);\n              };\n            }(a), a.freeWorkers.push(b);\n          };\n        }(this)), a;\n      }, a.prototype.frameFinished = function (a) {\n        return console.log('frame ' + a.index + ' finished - ' + this.activeWorkers.length + ' active'), this.finishedFrames++, this.emit('progress', this.finishedFrames / this.frames.length), this.imageParts[a.index] = a, j(null, this.imageParts) ? this.renderNextFrame() : this.finishRendering();\n      }, a.prototype.finishRendering = function () {\n        var e, a, k, m, b, d, h;\n        b = 0;\n\n        for (var f = 0, j = this.imageParts.length; f < j; ++f) a = this.imageParts[f], b += (a.data.length - 1) * a.pageSize + a.cursor;\n\n        b += a.pageSize - a.cursor, console.log('rendering finished - filesize ' + Math.round(b / 1e3) + 'kb'), e = new Uint8Array(b), d = 0;\n\n        for (var g = 0, l = this.imageParts.length; g < l; ++g) {\n          a = this.imageParts[g];\n\n          for (var c = 0, i = a.data.length; c < i; ++c) h = a.data[c], k = c, e.set(h, d), k === a.data.length - 1 ? d += a.cursor : d += a.pageSize;\n        }\n\n        return m = new Blob([e], {\n          type: 'image/gif'\n        }), this.emit('finished', m, e);\n      }, a.prototype.renderNextFrame = function () {\n        var c, a, b;\n        if (this.freeWorkers.length === 0) throw new Error('No free workers');\n        return this.nextFrame >= this.frames.length ? void 0 : (c = this.frames[this.nextFrame++], b = this.freeWorkers.shift(), a = this.getTask(c), console.log('starting frame ' + (a.index + 1) + ' of ' + this.frames.length), this.activeWorkers.push(b), b.postMessage(a));\n      }, a.prototype.getContextData = function (a) {\n        return a.getImageData(0, 0, this.options.width, this.options.height).data;\n      }, a.prototype.getImageData = function (b) {\n        var a;\n        return null != this._canvas || (this._canvas = document.createElement('canvas'), this._canvas.width = this.options.width, this._canvas.height = this.options.height), a = this._canvas.getContext('2d'), a.setFill = this.options.background, a.fillRect(0, 0, this.options.width, this.options.height), a.drawImage(b, 0, 0), this.getContextData(a);\n      }, a.prototype.getTask = function (a) {\n        var c, b;\n        if (c = this.frames.indexOf(a), b = {\n          index: c,\n          last: c === this.frames.length - 1,\n          delay: a.delay,\n          transparent: a.transparent,\n          width: this.options.width,\n          height: this.options.height,\n          quality: this.options.quality,\n          repeat: this.options.repeat,\n          canTransfer: h.name === 'chrome'\n        }, null != a.data) b.data = a.data;else if (null != a.context) b.data = this.getContextData(a.context);else if (null != a.image) b.data = this.getImageData(a.image);else throw new Error('Invalid frame');\n        return b;\n      }, a;\n    }(f), d.exports = e;\n  }), a.define('/browser.coffee', function (f, g, h, i) {\n    var a, d, e, c, b;\n    c = navigator.userAgent.toLowerCase(), e = navigator.platform.toLowerCase(), b = c.match(/(opera|ie|firefox|chrome|version)[\\s\\/:]([\\w\\d\\.]+)?.*?(safari|version[\\s\\/:]([\\w\\d\\.]+)|$)/) || [null, 'unknown', 0], d = b[1] === 'ie' && document.documentMode, a = {\n      name: b[1] === 'version' ? b[3] : b[1],\n      version: d || parseFloat(b[1] === 'opera' && b[4] ? b[4] : b[2]),\n      platform: {\n        name: c.match(/ip(?:ad|od|hone)/) ? 'ios' : (c.match(/(?:webos|android)/) || e.match(/mac|win|linux/) || ['other'])[0]\n      }\n    }, a[a.name] = !0, a[a.name + parseInt(a.version, 10)] = !0, a.platform[a.platform.name] = !0, f.exports = a;\n  }), a.define('events', function (f, e, g, h) {\n    b.EventEmitter || (b.EventEmitter = function () {});\n    var a = e.EventEmitter = b.EventEmitter,\n        c = typeof Array.isArray === 'function' ? Array.isArray : function (a) {\n      return Object.prototype.toString.call(a) === '[object Array]';\n    },\n        d = 10;\n    a.prototype.setMaxListeners = function (a) {\n      this._events || (this._events = {}), this._events.maxListeners = a;\n    }, a.prototype.emit = function (f) {\n      if (f === 'error' && (!(this._events && this._events.error) || c(this._events.error) && !this._events.error.length)) throw arguments[1] instanceof Error ? arguments[1] : new Error(\"Uncaught, unspecified 'error' event.\");\n      if (!this._events) return !1;\n      var a = this._events[f];\n      if (!a) return !1;\n      if (!(typeof a == 'function')) if (c(a)) {\n        var b = Array.prototype.slice.call(arguments, 1),\n            e = a.slice();\n\n        for (var d = 0, g = e.length; d < g; d++) e[d].apply(this, b);\n\n        return !0;\n      } else return !1;\n\n      switch (arguments.length) {\n        case 1:\n          a.call(this);\n          break;\n\n        case 2:\n          a.call(this, arguments[1]);\n          break;\n\n        case 3:\n          a.call(this, arguments[1], arguments[2]);\n          break;\n\n        default:\n          var b = Array.prototype.slice.call(arguments, 1);\n          a.apply(this, b);\n      }\n\n      return !0;\n    }, a.prototype.addListener = function (a, b) {\n      if ('function' !== typeof b) throw new Error('addListener only takes instances of Function');\n      if (this._events || (this._events = {}), this.emit('newListener', a, b), !this._events[a]) this._events[a] = b;else if (c(this._events[a])) {\n        if (!this._events[a].warned) {\n          var e;\n          this._events.maxListeners !== undefined ? e = this._events.maxListeners : e = d, e && e > 0 && this._events[a].length > e && (this._events[a].warned = !0, console.error('(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.', this._events[a].length), console.trace());\n        }\n\n        this._events[a].push(b);\n      } else this._events[a] = [this._events[a], b];\n      return this;\n    }, a.prototype.on = a.prototype.addListener, a.prototype.once = function (b, c) {\n      var a = this;\n      return a.on(b, function d() {\n        a.removeListener(b, d), c.apply(this, arguments);\n      }), this;\n    }, a.prototype.removeListener = function (a, d) {\n      if ('function' !== typeof d) throw new Error('removeListener only takes instances of Function');\n      if (!(this._events && this._events[a])) return this;\n      var b = this._events[a];\n\n      if (c(b)) {\n        var e = b.indexOf(d);\n        if (e < 0) return this;\n        b.splice(e, 1), b.length == 0 && delete this._events[a];\n      } else this._events[a] === d && delete this._events[a];\n\n      return this;\n    }, a.prototype.removeAllListeners = function (a) {\n      return a && this._events && this._events[a] && (this._events[a] = null), this;\n    }, a.prototype.listeners = function (a) {\n      return this._events || (this._events = {}), this._events[a] || (this._events[a] = []), c(this._events[a]) || (this._events[a] = [this._events[a]]), this._events[a];\n    };\n  }), c.GIF = a('/gif.coffee');\n}).call(_commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c, _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c); // gif.js 0.1.6 - https://github.com/jnordberg/gif.js\n\nvar webmWriter0_2_0 = {exports: {}};\n\n/**\n * A tool for presenting an ArrayBuffer as a stream for writing some simple data types.\n *\n * By Nicholas Sherlock\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n(function (module) {\n\n  (function () {\n    var isNodeEnviroment = 'object' !== 'undefined';\n    var isNodeEnviroment = false;\n    /**\n     * Create an ArrayBuffer of the given length and present it as a writable stream with methods\n     * for writing data in different formats.\n     */\n\n    var ArrayBufferDataStream = function (length) {\n      this.data = new Uint8Array(length);\n      this.pos = 0;\n    };\n\n    ArrayBufferDataStream.prototype.seek = function (offset) {\n      this.pos = offset;\n    };\n\n    ArrayBufferDataStream.prototype.writeBytes = function (arr) {\n      for (var i = 0; i < arr.length; i++) {\n        this.data[this.pos++] = arr[i];\n      }\n    };\n\n    ArrayBufferDataStream.prototype.writeByte = function (b) {\n      this.data[this.pos++] = b;\n    }; //Synonym:\n\n\n    ArrayBufferDataStream.prototype.writeU8 = ArrayBufferDataStream.prototype.writeByte;\n\n    ArrayBufferDataStream.prototype.writeU16BE = function (u) {\n      this.data[this.pos++] = u >> 8;\n      this.data[this.pos++] = u;\n    };\n\n    ArrayBufferDataStream.prototype.writeDoubleBE = function (d) {\n      var bytes = new Uint8Array(new Float64Array([d]).buffer);\n\n      for (var i = bytes.length - 1; i >= 0; i--) {\n        this.writeByte(bytes[i]);\n      }\n    };\n\n    ArrayBufferDataStream.prototype.writeFloatBE = function (d) {\n      var bytes = new Uint8Array(new Float32Array([d]).buffer);\n\n      for (var i = bytes.length - 1; i >= 0; i--) {\n        this.writeByte(bytes[i]);\n      }\n    };\n    /**\n     * Write an ASCII string to the stream\n     */\n\n\n    ArrayBufferDataStream.prototype.writeString = function (s) {\n      for (var i = 0; i < s.length; i++) {\n        this.data[this.pos++] = s.charCodeAt(i);\n      }\n    };\n    /**\n     * Write the given 32-bit integer to the stream as an EBML variable-length integer using the given byte width\n     * (use measureEBMLVarInt).\n     *\n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     *\n     * @param i Integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n\n\n    ArrayBufferDataStream.prototype.writeEBMLVarIntWidth = function (i, width) {\n      switch (width) {\n        case 1:\n          this.writeU8(1 << 7 | i);\n          break;\n\n        case 2:\n          this.writeU8(1 << 6 | i >> 8);\n          this.writeU8(i);\n          break;\n\n        case 3:\n          this.writeU8(1 << 5 | i >> 16);\n          this.writeU8(i >> 8);\n          this.writeU8(i);\n          break;\n\n        case 4:\n          this.writeU8(1 << 4 | i >> 24);\n          this.writeU8(i >> 16);\n          this.writeU8(i >> 8);\n          this.writeU8(i);\n          break;\n\n        case 5:\n          /*\n           * JavaScript converts its doubles to 32-bit integers for bitwise operations, so we need to do a\n           * division by 2^32 instead of a right-shift of 32 to retain those top 3 bits\n           */\n          this.writeU8(1 << 3 | i / 4294967296 & 0x7);\n          this.writeU8(i >> 24);\n          this.writeU8(i >> 16);\n          this.writeU8(i >> 8);\n          this.writeU8(i);\n          break;\n\n        default:\n          throw new RuntimeException('Bad EBML VINT size ' + width);\n      }\n    };\n    /**\n     * Return the number of bytes needed to encode the given integer as an EBML VINT.\n     */\n\n\n    ArrayBufferDataStream.prototype.measureEBMLVarInt = function (val) {\n      if (val < (1 << 7) - 1) {\n        /* Top bit is set, leaving 7 bits to hold the integer, but we can't store 127 because\n         * \"all bits set to one\" is a reserved value. Same thing for the other cases below:\n         */\n        return 1;\n      } else if (val < (1 << 14) - 1) {\n        return 2;\n      } else if (val < (1 << 21) - 1) {\n        return 3;\n      } else if (val < (1 << 28) - 1) {\n        return 4;\n      } else if (val < 34359738367) {\n        // 2 ^ 35 - 1 (can address 32GB)\n        return 5;\n      } else {\n        throw new RuntimeException('EBML VINT size not supported ' + val);\n      }\n    };\n\n    ArrayBufferDataStream.prototype.writeEBMLVarInt = function (i) {\n      this.writeEBMLVarIntWidth(i, this.measureEBMLVarInt(i));\n    };\n    /**\n     * Write the given unsigned 32-bit integer to the stream in big-endian order using the given byte width.\n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     *\n     * Omit the width parameter to have it determined automatically for you.\n     *\n     * @param u Unsigned integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n\n\n    ArrayBufferDataStream.prototype.writeUnsignedIntBE = function (u, width) {\n      if (width === undefined) {\n        width = this.measureUnsignedInt(u);\n      } // Each case falls through:\n\n\n      switch (width) {\n        case 5:\n          this.writeU8(Math.floor(u / 4294967296));\n        // Need to use division to access >32 bits of floating point var\n\n        case 4:\n          this.writeU8(u >> 24);\n\n        case 3:\n          this.writeU8(u >> 16);\n\n        case 2:\n          this.writeU8(u >> 8);\n\n        case 1:\n          this.writeU8(u);\n          break;\n\n        default:\n          throw new RuntimeException('Bad UINT size ' + width);\n      }\n    };\n    /**\n     * Return the number of bytes needed to hold the non-zero bits of the given unsigned integer.\n     */\n\n\n    ArrayBufferDataStream.prototype.measureUnsignedInt = function (val) {\n      // Force to 32-bit unsigned integer\n      if (val < 1 << 8) {\n        return 1;\n      } else if (val < 1 << 16) {\n        return 2;\n      } else if (val < 1 << 24) {\n        return 3;\n      } else if (val < 4294967296) {\n        return 4;\n      } else {\n        return 5;\n      }\n    };\n    /**\n     * Return a view on the portion of the buffer from the beginning to the current seek position as a Uint8Array.\n     */\n\n\n    ArrayBufferDataStream.prototype.getAsDataArray = function () {\n      if (this.pos < this.data.byteLength) {\n        return this.data.subarray(0, this.pos);\n      } else if (this.pos == this.data.byteLength) {\n        return this.data;\n      } else {\n        throw \"ArrayBufferDataStream's pos lies beyond end of buffer\";\n      }\n    };\n\n    window.ArrayBufferDataStream = ArrayBufferDataStream;\n    /**\n     * Allows a series of Blob-convertible objects (ArrayBuffer, Blob, String, etc) to be added to a buffer. Seeking and\n     * overwriting of blobs is allowed.\n     *\n     * You can supply a FileWriter, in which case the BlobBuffer is just used as temporary storage before it writes it\n     * through to the disk.\n     *\n     * By Nicholas Sherlock\n     *\n     * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n     */\n\n    var BlobBuffer = function (fs) {\n      return function (destination) {\n        var buffer = [],\n            writePromise = Promise.resolve(),\n            fileWriter = null,\n            fd = null;\n\n        if (typeof FileWriter !== 'undefined' && destination instanceof FileWriter) {\n          fileWriter = destination;\n        } else if (fs && destination) {\n          fd = destination;\n        } // Current seek offset\n\n\n        this.pos = 0; // One more than the index of the highest byte ever written\n\n        this.length = 0; // Returns a promise that converts the blob to an ArrayBuffer\n\n        function readBlobAsBuffer(blob) {\n          return new Promise(function (resolve, reject) {\n            var reader = new FileReader();\n            reader.addEventListener('loadend', function () {\n              resolve(reader.result);\n            });\n            reader.readAsArrayBuffer(blob);\n          });\n        }\n\n        function convertToUint8Array(thing) {\n          return new Promise(function (resolve, reject) {\n            if (thing instanceof Uint8Array) {\n              resolve(thing);\n            } else if (thing instanceof ArrayBuffer || ArrayBuffer.isView(thing)) {\n              resolve(new Uint8Array(thing));\n            } else if (thing instanceof Blob) {\n              resolve(readBlobAsBuffer(thing).then(function (buffer) {\n                return new Uint8Array(buffer);\n              }));\n            } else {\n              //Assume that Blob will know how to read this thing\n              resolve(readBlobAsBuffer(new Blob([thing])).then(function (buffer) {\n                return new Uint8Array(buffer);\n              }));\n            }\n          });\n        }\n\n        function measureData(data) {\n          var result = data.byteLength || data.length || data.size;\n\n          if (!Number.isInteger(result)) {\n            throw 'Failed to determine size of element';\n          }\n\n          return result;\n        }\n        /**\n         * Seek to the given absolute offset.\n         *\n         * You may not seek beyond the end of the file (this would create a hole and/or allow blocks to be written in non-\n         * sequential order, which isn't currently supported by the memory buffer backend).\n         */\n\n\n        this.seek = function (offset) {\n          if (offset < 0) {\n            throw 'Offset may not be negative';\n          }\n\n          if (isNaN(offset)) {\n            throw 'Offset may not be NaN';\n          }\n\n          if (offset > this.length) {\n            throw 'Seeking beyond the end of file is not allowed';\n          }\n\n          this.pos = offset;\n        };\n        /**\n         * Write the Blob-convertible data to the buffer at the current seek position.\n         *\n         * Note: If overwriting existing data, the write must not cross preexisting block boundaries (written data must\n         * be fully contained by the extent of a previous write).\n         */\n\n\n        this.write = function (data) {\n          var newEntry = {\n            offset: this.pos,\n            data: data,\n            length: measureData(data)\n          },\n              isAppend = newEntry.offset >= this.length;\n          this.pos += newEntry.length;\n          this.length = Math.max(this.length, this.pos); // After previous writes complete, perform our write\n\n          writePromise = writePromise.then(function () {\n            if (fd) {\n              return new Promise(function (resolve, reject) {\n                convertToUint8Array(newEntry.data).then(function (dataArray) {\n                  var totalWritten = 0,\n                      buffer = Buffer.from(dataArray.buffer),\n                      handleWriteComplete = function (err, written, buffer) {\n                    totalWritten += written;\n\n                    if (totalWritten >= buffer.length) {\n                      resolve();\n                    } else {\n                      // We still have more to write...\n                      fs.write(fd, buffer, totalWritten, buffer.length - totalWritten, newEntry.offset + totalWritten, handleWriteComplete);\n                    }\n                  };\n\n                  fs.write(fd, buffer, 0, buffer.length, newEntry.offset, handleWriteComplete);\n                });\n              });\n            } else if (fileWriter) {\n              return new Promise(function (resolve, reject) {\n                fileWriter.onwriteend = resolve;\n                fileWriter.seek(newEntry.offset);\n                fileWriter.write(new Blob([newEntry.data]));\n              });\n            } else if (!isAppend) {\n              // We might be modifying a write that was already buffered in memory.\n              // Slow linear search to find a block we might be overwriting\n              for (var i = 0; i < buffer.length; i++) {\n                var entry = buffer[i]; // If our new entry overlaps the old one in any way...\n\n                if (!(newEntry.offset + newEntry.length <= entry.offset || newEntry.offset >= entry.offset + entry.length)) {\n                  if (newEntry.offset < entry.offset || newEntry.offset + newEntry.length > entry.offset + entry.length) {\n                    throw new Error('Overwrite crosses blob boundaries');\n                  }\n\n                  if (newEntry.offset == entry.offset && newEntry.length == entry.length) {\n                    // We overwrote the entire block\n                    entry.data = newEntry.data; // We're done\n\n                    return;\n                  } else {\n                    return convertToUint8Array(entry.data).then(function (entryArray) {\n                      entry.data = entryArray;\n                      return convertToUint8Array(newEntry.data);\n                    }).then(function (newEntryArray) {\n                      newEntry.data = newEntryArray;\n                      entry.data.set(newEntry.data, newEntry.offset - entry.offset);\n                    });\n                  }\n                }\n              } // Else fall through to do a simple append, as we didn't overwrite any pre-existing blocks\n\n            }\n\n            buffer.push(newEntry);\n          });\n        };\n        /**\n         * Finish all writes to the buffer, returning a promise that signals when that is complete.\n         *\n         * If a FileWriter was not provided, the promise is resolved with a Blob that represents the completed BlobBuffer\n         * contents. You can optionally pass in a mimeType to be used for this blob.\n         *\n         * If a FileWriter was provided, the promise is resolved with null as the first argument.\n         */\n\n\n        this.complete = function (mimeType) {\n          if (fd || fileWriter) {\n            writePromise = writePromise.then(function () {\n              return null;\n            });\n          } else {\n            // After writes complete we need to merge the buffer to give to the caller\n            writePromise = writePromise.then(function () {\n              var result = [];\n\n              for (var i = 0; i < buffer.length; i++) {\n                result.push(buffer[i].data);\n              }\n\n              return new Blob(result, {\n                mimeType: mimeType\n              });\n            });\n          }\n\n          return writePromise;\n        };\n      };\n    }(isNodeEnviroment ? null : null);\n\n    window.BlobBuffer = BlobBuffer;\n    /**\n     * WebM video encoder for Google Chrome. This implementation is suitable for creating very large video files, because\n     * it can stream Blobs directly to a FileWriter without buffering the entire video in memory.\n     *\n     * When FileWriter is not available or not desired, it can buffer the video in memory as a series of Blobs which are\n     * eventually returned as one composite Blob.\n     *\n     * By Nicholas Sherlock.\n     *\n     * Based on the ideas from Whammy: https://github.com/antimatter15/whammy\n     *\n     * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n     */\n\n    var WebMWriter = function (ArrayBufferDataStream, BlobBuffer) {\n      function extend(base, top) {\n        var target = {};\n        [base, top].forEach(function (obj) {\n          for (var prop in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n              target[prop] = obj[prop];\n            }\n          }\n        });\n        return target;\n      }\n      /**\n       * Decode a Base64 data URL into a binary string.\n       *\n       * Returns the binary string, or false if the URL could not be decoded.\n       */\n\n\n      function decodeBase64WebPDataURL(url) {\n        if (typeof url !== 'string' || !url.match(/^data:image\\/webp;base64,/i)) {\n          return false;\n        }\n\n        return window.atob(url.substring('data:image/webp;base64,'.length));\n      }\n      /**\n       * Convert the given canvas to a WebP encoded image and return the image data as a string.\n       */\n\n\n      function renderAsWebP(canvas, quality) {\n        var frame = canvas.toDataURL('image/webp', {\n          quality: quality\n        });\n        return decodeBase64WebPDataURL(frame);\n      }\n\n      function extractKeyframeFromWebP(webP) {\n        // Assume that Chrome will generate a Simple Lossy WebP which has this header:\n        var keyframeStartIndex = webP.indexOf('VP8 ');\n\n        if (keyframeStartIndex == -1) {\n          throw 'Failed to identify beginning of keyframe in WebP image';\n        } // Skip the header and the 4 bytes that encode the length of the VP8 chunk\n\n\n        keyframeStartIndex += 'VP8 '.length + 4;\n        return webP.substring(keyframeStartIndex);\n      } // Just a little utility so we can tag values as floats for the EBML encoder's benefit\n\n\n      function EBMLFloat32(value) {\n        this.value = value;\n      }\n\n      function EBMLFloat64(value) {\n        this.value = value;\n      }\n      /**\n       * Write the given EBML object to the provided ArrayBufferStream.\n       *\n       * The buffer's first byte is at bufferFileOffset inside the video file. This is used to complete offset and\n       * dataOffset fields in each EBML structure, indicating the file offset of the first byte of the EBML element and\n       * its data payload.\n       */\n\n\n      function writeEBML(buffer, bufferFileOffset, ebml) {\n        // Is the ebml an array of sibling elements?\n        if (Array.isArray(ebml)) {\n          for (var i = 0; i < ebml.length; i++) {\n            writeEBML(buffer, bufferFileOffset, ebml[i]);\n          } // Is this some sort of raw data that we want to write directly?\n\n        } else if (typeof ebml === 'string') {\n          buffer.writeString(ebml);\n        } else if (ebml instanceof Uint8Array) {\n          buffer.writeBytes(ebml);\n        } else if (ebml.id) {\n          // We're writing an EBML element\n          ebml.offset = buffer.pos + bufferFileOffset;\n          buffer.writeUnsignedIntBE(ebml.id); // ID field\n          // Now we need to write the size field, so we must know the payload size:\n\n          if (Array.isArray(ebml.data)) {\n            // Writing an array of child elements. We won't try to measure the size of the children up-front\n            var sizePos, dataBegin, dataEnd;\n\n            if (ebml.size === -1) {\n              // Write the reserved all-one-bits marker to note that the size of this element is unknown/unbounded\n              buffer.writeByte(0xff);\n            } else {\n              sizePos = buffer.pos;\n              /* Write a dummy size field to overwrite later. 4 bytes allows an element maximum size of 256MB,\n               * which should be plenty (we don't want to have to buffer that much data in memory at one time\n               * anyway!)\n               */\n\n              buffer.writeBytes([0, 0, 0, 0]);\n            }\n\n            dataBegin = buffer.pos;\n            ebml.dataOffset = dataBegin + bufferFileOffset;\n            writeEBML(buffer, bufferFileOffset, ebml.data);\n\n            if (ebml.size !== -1) {\n              dataEnd = buffer.pos;\n              ebml.size = dataEnd - dataBegin;\n              buffer.seek(sizePos);\n              buffer.writeEBMLVarIntWidth(ebml.size, 4); // Size field\n\n              buffer.seek(dataEnd);\n            }\n          } else if (typeof ebml.data === 'string') {\n            buffer.writeEBMLVarInt(ebml.data.length); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeString(ebml.data);\n          } else if (typeof ebml.data === 'number') {\n            // Allow the caller to explicitly choose the size if they wish by supplying a size field\n            if (!ebml.size) {\n              ebml.size = buffer.measureUnsignedInt(ebml.data);\n            }\n\n            buffer.writeEBMLVarInt(ebml.size); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeUnsignedIntBE(ebml.data, ebml.size);\n          } else if (ebml.data instanceof EBMLFloat64) {\n            buffer.writeEBMLVarInt(8); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeDoubleBE(ebml.data.value);\n          } else if (ebml.data instanceof EBMLFloat32) {\n            buffer.writeEBMLVarInt(4); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeFloatBE(ebml.data.value);\n          } else if (ebml.data instanceof Uint8Array) {\n            buffer.writeEBMLVarInt(ebml.data.byteLength); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeBytes(ebml.data);\n          } else {\n            throw 'Bad EBML datatype ' + typeof ebml.data;\n          }\n        } else {\n          throw 'Bad EBML datatype ' + typeof ebml.data;\n        }\n      }\n\n      return function (options) {\n        var MAX_CLUSTER_DURATION_MSEC = 5000,\n            DEFAULT_TRACK_NUMBER = 1,\n            writtenHeader = false,\n            videoWidth,\n            videoHeight,\n            clusterFrameBuffer = [],\n            clusterStartTime = 0,\n            clusterDuration = 0,\n            optionDefaults = {\n          quality: 0.95,\n          // WebM image quality from 0.0 (worst) to 1.0 (best)\n          fileWriter: null,\n          // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)\n          fd: null,\n          // Node.JS file descriptor to write to instead of buffering (optional)\n          // You must supply one of:\n          frameDuration: null,\n          // Duration of frames in milliseconds\n          frameRate: null // Number of frames per second\n\n        },\n            seekPoints = {\n          Cues: {\n            id: new Uint8Array([0x1c, 0x53, 0xbb, 0x6b]),\n            positionEBML: null\n          },\n          SegmentInfo: {\n            id: new Uint8Array([0x15, 0x49, 0xa9, 0x66]),\n            positionEBML: null\n          },\n          Tracks: {\n            id: new Uint8Array([0x16, 0x54, 0xae, 0x6b]),\n            positionEBML: null\n          }\n        },\n            ebmlSegment,\n            segmentDuration = {\n          id: 0x4489,\n          // Duration\n          data: new EBMLFloat64(0)\n        },\n            seekHead,\n            cues = [],\n            blobBuffer = new BlobBuffer(options.fileWriter || options.fd);\n\n        function fileOffsetToSegmentRelative(fileOffset) {\n          return fileOffset - ebmlSegment.dataOffset;\n        }\n        /**\n         * Create a SeekHead element with descriptors for the points in the global seekPoints array.\n         *\n         * 5 bytes of position values are reserved for each node, which lie at the offset point.positionEBML.dataOffset,\n         * to be overwritten later.\n         */\n\n\n        function createSeekHead() {\n          var seekPositionEBMLTemplate = {\n            id: 0x53ac,\n            // SeekPosition\n            size: 5,\n            // Allows for 32GB video files\n            data: 0 // We'll overwrite this when the file is complete\n\n          },\n              result = {\n            id: 0x114d9b74,\n            // SeekHead\n            data: []\n          };\n\n          for (var name in seekPoints) {\n            var seekPoint = seekPoints[name];\n            seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);\n            result.data.push({\n              id: 0x4dbb,\n              // Seek\n              data: [{\n                id: 0x53ab,\n                // SeekID\n                data: seekPoint.id\n              }, seekPoint.positionEBML]\n            });\n          }\n\n          return result;\n        }\n        /**\n         * Write the WebM file header to the stream.\n         */\n\n\n        function writeHeader() {\n          seekHead = createSeekHead();\n          var ebmlHeader = {\n            id: 0x1a45dfa3,\n            // EBML\n            data: [{\n              id: 0x4286,\n              // EBMLVersion\n              data: 1\n            }, {\n              id: 0x42f7,\n              // EBMLReadVersion\n              data: 1\n            }, {\n              id: 0x42f2,\n              // EBMLMaxIDLength\n              data: 4\n            }, {\n              id: 0x42f3,\n              // EBMLMaxSizeLength\n              data: 8\n            }, {\n              id: 0x4282,\n              // DocType\n              data: 'webm'\n            }, {\n              id: 0x4287,\n              // DocTypeVersion\n              data: 2\n            }, {\n              id: 0x4285,\n              // DocTypeReadVersion\n              data: 2\n            }]\n          },\n              segmentInfo = {\n            id: 0x1549a966,\n            // Info\n            data: [{\n              id: 0x2ad7b1,\n              // TimecodeScale\n              data: 1e6 // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)\n\n            }, {\n              id: 0x4d80,\n              // MuxingApp\n              data: 'webm-writer-js'\n            }, {\n              id: 0x5741,\n              // WritingApp\n              data: 'webm-writer-js'\n            }, segmentDuration // To be filled in later\n            ]\n          },\n              tracks = {\n            id: 0x1654ae6b,\n            // Tracks\n            data: [{\n              id: 0xae,\n              // TrackEntry\n              data: [{\n                id: 0xd7,\n                // TrackNumber\n                data: DEFAULT_TRACK_NUMBER\n              }, {\n                id: 0x73c5,\n                // TrackUID\n                data: DEFAULT_TRACK_NUMBER\n              }, {\n                id: 0x9c,\n                // FlagLacing\n                data: 0\n              }, {\n                id: 0x22b59c,\n                // Language\n                data: 'und'\n              }, {\n                id: 0x86,\n                // CodecID\n                data: 'V_VP8'\n              }, {\n                id: 0x258688,\n                // CodecName\n                data: 'VP8'\n              }, {\n                id: 0x83,\n                // TrackType\n                data: 1\n              }, {\n                id: 0xe0,\n                // Video\n                data: [{\n                  id: 0xb0,\n                  // PixelWidth\n                  data: videoWidth\n                }, {\n                  id: 0xba,\n                  // PixelHeight\n                  data: videoHeight\n                }]\n              }]\n            }]\n          };\n          ebmlSegment = {\n            id: 0x18538067,\n            // Segment\n            size: -1,\n            // Unbounded size\n            data: [seekHead, segmentInfo, tracks]\n          };\n          var bufferStream = new ArrayBufferDataStream(256);\n          writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);\n          blobBuffer.write(bufferStream.getAsDataArray()); // Now we know where these top-level elements lie in the file:\n\n          seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(segmentInfo.offset);\n          seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(tracks.offset);\n        }\n        /**\n         * Create a SimpleBlock keyframe header using these fields:\n         *     timecode    - Time of this keyframe\n         *     trackNumber - Track number from 1 to 126 (inclusive)\n         *     frame       - Raw frame data payload string\n         *\n         * Returns an EBML element.\n         */\n\n\n        function createKeyframeBlock(keyframe) {\n          var bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n\n          if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n            throw 'TrackNumber must be > 0 and < 127';\n          }\n\n          bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n\n          bufferStream.writeU16BE(keyframe.timecode); // Flags byte\n\n          bufferStream.writeByte(1 << 7 // Keyframe\n          );\n          return {\n            id: 0xa3,\n            // SimpleBlock\n            data: [bufferStream.getAsDataArray(), keyframe.frame]\n          };\n        }\n        /**\n         * Create a Cluster node using these fields:\n         *\n         *    timecode    - Start time for the cluster\n         *\n         * Returns an EBML element.\n         */\n\n\n        function createCluster(cluster) {\n          return {\n            id: 0x1f43b675,\n            data: [{\n              id: 0xe7,\n              // Timecode\n              data: Math.round(cluster.timecode)\n            }]\n          };\n        }\n\n        function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {\n          cues.push({\n            id: 0xbb,\n            // Cue\n            data: [{\n              id: 0xb3,\n              // CueTime\n              data: clusterTime\n            }, {\n              id: 0xb7,\n              // CueTrackPositions\n              data: [{\n                id: 0xf7,\n                // CueTrack\n                data: trackIndex\n              }, {\n                id: 0xf1,\n                // CueClusterPosition\n                data: fileOffsetToSegmentRelative(clusterFileOffset)\n              }]\n            }]\n          });\n        }\n        /**\n         * Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\n         * The seek entry for the Cues in the SeekHead is updated.\n         */\n\n\n        function writeCues() {\n          var ebml = {\n            id: 0x1c53bb6b,\n            data: cues\n          },\n              cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n\n          writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n          blobBuffer.write(cuesBuffer.getAsDataArray()); // Now we know where the Cues element has ended up, we can update the SeekHead\n\n          seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);\n        }\n        /**\n         * Flush the frames in the current clusterFrameBuffer out to the stream as a Cluster.\n         */\n\n\n        function flushClusterFrameBuffer() {\n          if (clusterFrameBuffer.length == 0) {\n            return;\n          } // First work out how large of a buffer we need to hold the cluster data\n\n\n          var rawImageSize = 0;\n\n          for (var i = 0; i < clusterFrameBuffer.length; i++) {\n            rawImageSize += clusterFrameBuffer[i].frame.length;\n          }\n\n          var buffer = new ArrayBufferDataStream(rawImageSize + clusterFrameBuffer.length * 32),\n              // Estimate 32 bytes per SimpleBlock header\n          cluster = createCluster({\n            timecode: Math.round(clusterStartTime)\n          });\n\n          for (var i = 0; i < clusterFrameBuffer.length; i++) {\n            cluster.data.push(createKeyframeBlock(clusterFrameBuffer[i]));\n          }\n\n          writeEBML(buffer, blobBuffer.pos, cluster);\n          blobBuffer.write(buffer.getAsDataArray());\n          addCuePoint(DEFAULT_TRACK_NUMBER, Math.round(clusterStartTime), cluster.offset);\n          clusterFrameBuffer = [];\n          clusterStartTime += clusterDuration;\n          clusterDuration = 0;\n        }\n\n        function validateOptions() {\n          // Derive frameDuration setting if not already supplied\n          if (!options.frameDuration) {\n            if (options.frameRate) {\n              options.frameDuration = 1000 / options.frameRate;\n            } else {\n              throw 'Missing required frameDuration or frameRate setting';\n            }\n          }\n        }\n\n        function addFrameToCluster(frame) {\n          frame.trackNumber = DEFAULT_TRACK_NUMBER; // Frame timecodes are relative to the start of their cluster:\n\n          frame.timecode = Math.round(clusterDuration);\n          clusterFrameBuffer.push(frame);\n          clusterDuration += frame.duration;\n\n          if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {\n            flushClusterFrameBuffer();\n          }\n        }\n        /**\n         * Rewrites the SeekHead element that was initially written to the stream with the offsets of top level elements.\n         *\n         * Call once writing is complete (so the offset of all top level elements is known).\n         */\n\n\n        function rewriteSeekHead() {\n          var seekHeadBuffer = new ArrayBufferDataStream(seekHead.size),\n              oldPos = blobBuffer.pos; // Write the rewritten SeekHead element's data payload to the stream (don't need to update the id or size)\n\n          writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data); // And write that through to the file\n\n          blobBuffer.seek(seekHead.dataOffset);\n          blobBuffer.write(seekHeadBuffer.getAsDataArray());\n          blobBuffer.seek(oldPos);\n        }\n        /**\n         * Rewrite the Duration field of the Segment with the newly-discovered video duration.\n         */\n\n\n        function rewriteDuration() {\n          var buffer = new ArrayBufferDataStream(8),\n              oldPos = blobBuffer.pos; // Rewrite the data payload (don't need to update the id or size)\n\n          buffer.writeDoubleBE(clusterStartTime); // And write that through to the file\n\n          blobBuffer.seek(segmentDuration.dataOffset);\n          blobBuffer.write(buffer.getAsDataArray());\n          blobBuffer.seek(oldPos);\n        }\n        /**\n         * Add a frame to the video. Currently the frame must be a Canvas element.\n         */\n\n\n        this.addFrame = function (canvas) {\n          if (writtenHeader) {\n            if (canvas.width != videoWidth || canvas.height != videoHeight) {\n              throw 'Frame size differs from previous frames';\n            }\n          } else {\n            videoWidth = canvas.width;\n            videoHeight = canvas.height;\n            writeHeader();\n            writtenHeader = true;\n          }\n\n          var webP = renderAsWebP(canvas, {\n            quality: options.quality\n          });\n\n          if (!webP) {\n            throw \"Couldn't decode WebP frame, does the browser support WebP?\";\n          }\n\n          addFrameToCluster({\n            frame: extractKeyframeFromWebP(webP),\n            duration: options.frameDuration\n          });\n        };\n        /**\n         * Finish writing the video and return a Promise to signal completion.\n         *\n         * If the destination device was memory (i.e. options.fileWriter was not supplied), the Promise is resolved with\n         * a Blob with the contents of the entire video.\n         */\n\n\n        this.complete = function () {\n          flushClusterFrameBuffer();\n          writeCues();\n          rewriteSeekHead();\n          rewriteDuration();\n          return blobBuffer.complete('video/webm');\n        };\n\n        this.getWrittenSize = function () {\n          return blobBuffer.length;\n        };\n\n        options = extend(optionDefaults, options || {});\n        validateOptions();\n      };\n    };\n\n    if (isNodeEnviroment) {\n      module.exports = WebMWriter(ArrayBufferDataStream, BlobBuffer);\n    } else {\n      window.WebMWriter = WebMWriter(ArrayBufferDataStream, BlobBuffer);\n    }\n  })();\n})(webmWriter0_2_0);\n\n(function (module, exports) {\n  !function () {\n\n    var t = void 0 !== module.exports,\n        e = t ? tar.exports : window.Tar,\n        M = t ? download.exports : window.download,\n        i = t ? gif.GIF : window.GIF,\n        n = t ? webmWriter0_2_0.exports : window.WebMWriter,\n        o = {\n      function: !0,\n      object: !0\n    };\n\n    function r(t) {\n      return t && t.Object === Object ? t : null;\n    }\n    var a = exports && !exports.nodeType ? exports : void 0,\n        s = module && !module.nodeType ? module : void 0,\n        c = s && s.exports === a ? a : void 0,\n        h = r(a && s && 'object' == typeof _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c && _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c),\n        p = r(o[typeof self] && self),\n        m = r(o[typeof window] && window),\n        d = r(o[typeof this] && this),\n        u = h || m !== (d && d.window) && m || p || d || Function('return this')();\n\n    function l(t) {\n      return String('0000000' + t).slice(-7);\n    }\n\n    'gc' in window || (window.gc = function () {}), HTMLCanvasElement.prototype.toBlob || Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n      value: function (t, e, i) {\n        for (var n = atob(this.toDataURL(e, i).split(',')[1]), o = n.length, r = new Uint8Array(o), a = 0; a < o; a++) r[a] = n.charCodeAt(a);\n\n        t(new Blob([r], {\n          type: e || 'image/png'\n        }));\n      }\n    }), function () {\n      if ('performance' in window == 0 && (window.performance = {}), Date.now = Date.now || function () {\n        return new Date().getTime();\n      }, 'now' in window.performance == 0) {\n        var t = Date.now();\n        performance.timing && performance.timing.navigationStart && (t = performance.timing.navigationStart), window.performance.now = function () {\n          return Date.now() - t;\n        };\n      }\n    }();\n    var W = window.Date.now();\n\n    function f(t) {\n      var i = {};\n      this.settings = t, this.on = function (t, e) {\n        i[t] = e;\n      }, this.emit = function (t) {\n        var e = i[t];\n        e && e.apply(null, Array.prototype.slice.call(arguments, 1));\n      }, this.filename = t.name || function () {\n        function t() {\n          return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);\n        }\n\n        return t() + t() + '-' + t() + '-' + t() + '-' + t() + '-' + t() + t() + t();\n      }(), this.extension = '', this.mimeType = '';\n    }\n\n    function w(t) {\n      f.call(this, t), this.extension = '.tar', this.mimeType = 'application/x-tar', this.fileExtension = '', this.baseFilename = this.filename, this.tape = null, this.count = 0, this.part = 1, this.frames = 0;\n    }\n\n    function z(t) {\n      w.call(this, t), this.type = 'image/png', this.fileExtension = '.png';\n    }\n\n    function U(t) {\n      w.call(this, t), this.type = 'image/jpeg', this.fileExtension = '.jpg', this.quality = t.quality / 100 || 0.8;\n    }\n\n    function _(t) {\n      'image/webp' !== document.createElement('canvas').toDataURL('image/webp').substr(5, 10) && console.log('WebP not supported - try another export format'), f.call(this, t), this.quality = t.quality / 100 || 0.8, this.extension = '.webm', this.mimeType = 'video/webm', this.baseFilename = this.filename, this.framerate = t.framerate, this.frames = 0, this.part = 1, this.videoWriter = new n({\n        quality: this.quality,\n        fileWriter: null,\n        fd: null,\n        frameRate: this.framerate\n      });\n    }\n\n    function H(t) {\n      f.call(this, t), t.quality = t.quality / 100 || 0.8, this.encoder = new FFMpegServer.Video(t), this.encoder.on('process', function () {\n        this.emit('process');\n      }.bind(this)), this.encoder.on('finished', function (t, e) {\n        var i = this.callback;\n        i && (this.callback = void 0, i(t, e));\n      }.bind(this)), this.encoder.on('progress', function (t) {\n        this.settings.onProgress && this.settings.onProgress(t);\n      }.bind(this)), this.encoder.on('error', function (t) {\n        alert(JSON.stringify(t, null, 2));\n      }.bind(this));\n    }\n\n    function V(t) {\n      f.call(this, t), this.framerate = this.settings.framerate, this.type = 'video/webm', this.extension = '.webm', this.stream = null, this.mediaRecorder = null, this.chunks = [];\n    }\n\n    function G(t) {\n      f.call(this, t), t.quality = 31 - (30 * t.quality / 100 || 10), t.workers = t.workers || 4, this.extension = '.gif', this.mimeType = 'image/gif', this.canvas = document.createElement('canvas'), this.ctx = this.canvas.getContext('2d'), this.sizeSet = !1, this.encoder = new i({\n        workers: t.workers,\n        quality: t.quality,\n        workerScript: t.workersPath + 'gif.worker.js'\n      }), this.encoder.on('progress', function (t) {\n        this.settings.onProgress && this.settings.onProgress(t);\n      }.bind(this)), this.encoder.on('finished', function (t) {\n        var e = this.callback;\n        e && (this.callback = void 0, e(t));\n      }.bind(this));\n    }\n\n    function y(t) {\n      var e,\n          n,\n          o,\n          r,\n          a,\n          i,\n          s,\n          c = t || {},\n          h = ([]),\n          p = [],\n          m = 0,\n          d = 0,\n          u = [],\n          l = !1,\n          f = {};\n      c.framerate = c.framerate || 60, c.motionBlurFrames = 2 * (c.motionBlurFrames || 1), e = c.verbose || !1, c.display, c.step = 1e3 / c.framerate, c.timeLimit = c.timeLimit || 0, c.frameLimit = c.frameLimit || 0, c.startTime = c.startTime || 0;\n      var w = document.createElement('div');\n      w.style.position = 'absolute', w.style.left = w.style.top = 0, w.style.backgroundColor = 'black', w.style.fontFamily = 'monospace', w.style.fontSize = '11px', w.style.padding = '5px', w.style.color = 'red', w.style.zIndex = 1e5, c.display && document.body.appendChild(w);\n      var y,\n          g,\n          v = document.createElement('canvas'),\n          b = v.getContext('2d');\n      P('Step is set to ' + c.step + 'ms');\n      var T = {\n        gif: G,\n        webm: _,\n        ffmpegserver: H,\n        png: z,\n        jpg: U,\n        'webm-mediarecorder': V\n      },\n          F = T[c.format];\n      if (!F) throw 'Error: Incorrect or missing format: Valid formats are ' + Object.keys(T).join(', ');\n\n      if ((s = new F(c)).step = i, s.on('process', R), s.on('progress', function (t) {\n        !function (t) {\n          var e = f[t];\n          e && e.apply(null, Array.prototype.slice.call(arguments, 1));\n        }('progress', t);\n      }), 'performance' in window == 0 && (window.performance = {}), Date.now = Date.now || function () {\n        return new Date().getTime();\n      }, 'now' in window.performance == 0) {\n        var x = Date.now();\n        performance.timing && performance.timing.navigationStart && (x = performance.timing.navigationStart), window.performance.now = function () {\n          return Date.now() - x;\n        };\n      }\n\n      var k = window.setTimeout,\n          S = window.setInterval,\n          D = window.clearInterval,\n          C = window.clearTimeout,\n          q = window.requestAnimationFrame,\n          j = window.Date.now,\n          I = window.performance.now,\n          O = window.Date.prototype.getTime,\n          B = [];\n\n      function E() {\n        l = !1, s.stop(), P('Capturer stop'), window.setTimeout = k, window.setInterval = S, window.clearInterval = D, window.clearTimeout = C, window.requestAnimationFrame = q, window.Date.prototype.getTime = O, window.Date.now = j, window.performance.now = I;\n      }\n\n      function L(t, e) {\n        k(t, 0, e);\n      }\n\n      function i() {\n        L(R);\n      }\n\n      function R() {\n        var t = 1e3 / c.framerate,\n            e = (m + d / c.motionBlurFrames) * t;\n        n = o + e, r = a + e, B.forEach(function (t) {\n          t._hookedTime = e / 1e3;\n        }), function () {\n          var t = m / c.framerate;\n          (c.frameLimit && m >= c.frameLimit || c.timeLimit && t >= c.timeLimit) && (E(), A());\n          var e = new Date(null);\n          e.setSeconds(t), 2 < c.motionBlurFrames ? w.textContent = 'CCapture ' + c.format + ' | ' + m + ' frames (' + d + ' inter) | ' + e.toISOString().substr(11, 8) : w.textContent = 'CCapture ' + c.format + ' | ' + m + ' frames | ' + e.toISOString().substr(11, 8);\n        }(), P('Frame: ' + m + ' ' + d);\n\n        for (var i = 0; i < h.length; i++) n >= h[i].triggerTime && (L(h[i].callback), h.splice(i, 1));\n\n        for (i = 0; i < p.length; i++) n >= p[i].triggerTime && (L(p[i].callback), p[i].triggerTime += p[i].time);\n\n        u.forEach(function (t) {\n          L(t, n - W);\n        }), u = [];\n      }\n\n      function A(t) {\n        t || (t = function (t) {\n          return M(t, s.filename + s.extension, s.mimeType), !1;\n        }), s.save(t);\n      }\n\n      function P(t) {\n        e && console.log(t);\n      }\n\n      return {\n        start: function () {\n          !function () {\n            function t() {\n              return this._hooked || (this._hooked = !0, this._hookedTime = this.currentTime || 0, this.pause(), B.push(this)), this._hookedTime + c.startTime;\n            }\n\n            P('Capturer start'), o = window.Date.now(), n = o + c.startTime, a = window.performance.now(), r = a + c.startTime, window.Date.prototype.getTime = function () {\n              return n;\n            }, window.Date.now = function () {\n              return n;\n            }, window.setTimeout = function (t, e) {\n              e = 5000000;\n              var i = {\n                callback: t,\n                time: e,\n                triggerTime: n + e\n              };\n              return h.push(i), P('Timeout set to ' + i.time), i;\n            }, window.clearTimeout = function (t) {\n              for (var e = 0; e < h.length; e++) h[e] != t || (h.splice(e, 1), P('Timeout cleared'));\n            }, window.setInterval = function (t, e) {\n              e = 5000000;\n              var i = {\n                callback: t,\n                time: e,\n                triggerTime: n + e\n              };\n              return p.push(i), P('Interval set to ' + i.time), i;\n            }, window.clearInterval = function (t) {\n              return P('clear Interval'), null;\n            }, window.requestAnimationFrame = function (t) {\n              u.push(t);\n            }, window.performance.now = function () {\n              return r;\n            };\n\n            try {\n              Object.defineProperty(HTMLVideoElement.prototype, 'currentTime', {\n                get: t\n              }), Object.defineProperty(HTMLAudioElement.prototype, 'currentTime', {\n                get: t\n              });\n            } catch (t) {\n              P(t);\n            }\n          }(), s.start(), l = !0;\n        },\n        capture: function (t) {\n          var e;\n          l && (2 < c.motionBlurFrames ? (e = t, v.width === e.width && v.height === e.height || (v.width = e.width, v.height = e.height, y = new Uint16Array(v.height * v.width * 4), b.fillStyle = '#0', b.fillRect(0, 0, v.width, v.height)), function (t) {\n            b.drawImage(t, 0, 0), g = b.getImageData(0, 0, v.width, v.height);\n\n            for (var e = 0; e < y.length; e += 4) y[e] += g.data[e], y[e + 1] += g.data[e + 1], y[e + 2] += g.data[e + 2];\n\n            d++;\n          }(t), d >= 0.5 * c.motionBlurFrames ? function () {\n            for (var t = g.data, e = 0; e < y.length; e += 4) t[e] = 2 * y[e] / c.motionBlurFrames, t[e + 1] = 2 * y[e + 1] / c.motionBlurFrames, t[e + 2] = 2 * y[e + 2] / c.motionBlurFrames;\n\n            for (b.putImageData(g, 0, 0), s.add(v), d = 0, P('Full MB Frame! ' + ++m + ' ' + n), e = 0; e < y.length; e += 4) y[e] = 0, y[e + 1] = 0, y[e + 2] = 0;\n\n            gc();\n          }() : i()) : (s.add(t), P('Full Frame! ' + ++m)));\n        },\n        stop: E,\n        save: A,\n        on: function (t, e) {\n          f[t] = e;\n        }\n      };\n    }\n    f.prototype.start = function () {}, f.prototype.stop = function () {}, f.prototype.add = function () {}, f.prototype.save = function () {}, f.prototype.dispose = function () {}, f.prototype.safeToProceed = function () {\n      return !0;\n    }, f.prototype.step = function () {\n      console.log('Step not set!');\n    }, (w.prototype = Object.create(f.prototype)).start = function () {\n      this.dispose();\n    }, w.prototype.add = function (t) {\n      var e = new FileReader();\n      e.onload = function () {\n        this.tape.append(l(this.count) + this.fileExtension, new Uint8Array(e.result)), 0 < this.settings.autoSaveTime && this.frames / this.settings.framerate >= this.settings.autoSaveTime ? this.save(function (t) {\n          this.filename = this.baseFilename + '-part-' + l(this.part), M(t, this.filename + this.extension, this.mimeType);\n          var e = this.count;\n          this.dispose(), this.count = e + 1, this.part++, this.filename = this.baseFilename + '-part-' + l(this.part), this.frames = 0, this.step();\n        }.bind(this)) : (this.count++, this.frames++, this.step());\n      }.bind(this), e.readAsArrayBuffer(t);\n    }, w.prototype.save = function (t) {\n      t(this.tape.save());\n    }, w.prototype.dispose = function () {\n      this.tape = new e(), this.count = 0;\n    }, (z.prototype = Object.create(w.prototype)).add = function (t) {\n      t.toBlob(function (t) {\n        w.prototype.add.call(this, t);\n      }.bind(this), this.type);\n    }, (U.prototype = Object.create(w.prototype)).add = function (t) {\n      t.toBlob(function (t) {\n        w.prototype.add.call(this, t);\n      }.bind(this), this.type, this.quality);\n    }, (_.prototype = Object.create(f.prototype)).start = function (t) {\n      this.dispose();\n    }, _.prototype.add = function (t) {\n      this.videoWriter.addFrame(t), 0 < this.settings.autoSaveTime && this.frames / this.settings.framerate >= this.settings.autoSaveTime ? this.save(function (t) {\n        this.filename = this.baseFilename + '-part-' + l(this.part), M(t, this.filename + this.extension, this.mimeType), this.dispose(), this.part++, this.filename = this.baseFilename + '-part-' + l(this.part), this.step();\n      }.bind(this)) : (this.frames++, this.step());\n    }, _.prototype.save = function (t) {\n      this.videoWriter.complete().then(t);\n    }, _.prototype.dispose = function (t) {\n      this.frames = 0, this.videoWriter = new n({\n        quality: this.quality,\n        fileWriter: null,\n        fd: null,\n        frameRate: this.framerate\n      });\n    }, (H.prototype = Object.create(f.prototype)).start = function () {\n      this.encoder.start(this.settings);\n    }, H.prototype.add = function (t) {\n      this.encoder.add(t);\n    }, H.prototype.save = function (t) {\n      this.callback = t, this.encoder.end();\n    }, H.prototype.safeToProceed = function () {\n      return this.encoder.safeToProceed();\n    }, (V.prototype = Object.create(f.prototype)).add = function (t) {\n      this.stream || (this.stream = t.captureStream(this.framerate), this.mediaRecorder = new MediaRecorder(this.stream), this.mediaRecorder.start(), this.mediaRecorder.ondataavailable = function (t) {\n        this.chunks.push(t.data);\n      }.bind(this)), this.step();\n    }, V.prototype.save = function (i) {\n      this.mediaRecorder.onstop = function (t) {\n        var e = new Blob(this.chunks, {\n          type: 'video/webm'\n        });\n        this.chunks = [], i(e);\n      }.bind(this), this.mediaRecorder.stop();\n    }, (G.prototype = Object.create(f.prototype)).add = function (t) {\n      this.sizeSet || (this.encoder.setOption('width', t.width), this.encoder.setOption('height', t.height), this.sizeSet = !0), this.canvas.width = t.width, this.canvas.height = t.height, this.ctx.drawImage(t, 0, 0), this.encoder.addFrame(this.ctx, {\n        copy: !0,\n        delay: this.settings.step\n      }), this.step();\n    }, G.prototype.save = function (t) {\n      this.callback = t, this.encoder.render();\n    }, (m || p || {}).CCapture = y, a && s ? (c && ((s.exports = y).CCapture = y), a.CCapture = y) : u.CCapture = y;\n  }();\n})(CCapture_min$2, CCapture_min$2.exports);\n\nvar CCapture_min = CCapture_min$2.exports;\n\nvar CCapture_min$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), CCapture_min$2.exports, {\n  'default': CCapture_min\n}));\n\n\n//# sourceMappingURL=CCapture.min-23f4504b.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3JlYWN0LXN3aWZ0L2Rpc3QvQ0NhcHR1cmUubWluLTIzZjQ1MDRiLmpzP2Y1ZDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFFOztBQUVyRSxzQkFBc0I7O0FBRXRCLFdBQVc7O0FBRVg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkMsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtB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QUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsY0FBYzs7QUFFekM7QUFDQSxXQUFXO0FBQ1gsdUNBQXVDLGNBQWM7O0FBRXJELHVHQUF1RyxjQUFjOztBQUVySDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUNBQW1DLGtDQUFrQyxtQ0FBbUMsc0NBQXNDO0FBQ3BMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUssZUFBZTtBQUNwQixHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFOEI7QUFDL0IiLCJmaWxlIjoiLi4vLi4vcmVhY3Qtc3dpZnQvZGlzdC9DQ2FwdHVyZS5taW4tMjNmNDUwNGIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjIGFzIGNvbW1vbmpzR2xvYmFsIH0gZnJvbSAnLi9fY29tbW9uanNIZWxwZXJzLTFjOGJlYjVmLmpzJztcblxudmFyIENDYXB0dXJlX21pbiQyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIHRhciA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG5cbiAgKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBsb29rdXAgPSBbJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLCAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICcrJywgJy8nXTtcblxuICAgIGZ1bmN0aW9uIGNsZWFuKGxlbmd0aCkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKG9yaWcsIGxlbmd0aCwgYWRkTGVuZ3RoLCBtdWx0aXBsZU9mKSB7XG4gICAgICB2YXIgbmV3U2l6ZSA9IGxlbmd0aCArIGFkZExlbmd0aCxcbiAgICAgICAgICBidWZmZXIgPSBjbGVhbigocGFyc2VJbnQobmV3U2l6ZSAvIG11bHRpcGxlT2YpICsgMSkgKiBtdWx0aXBsZU9mKTtcbiAgICAgIGJ1ZmZlci5zZXQob3JpZyk7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhZChudW0sIGJ5dGVzLCBiYXNlKSB7XG4gICAgICBudW0gPSBudW0udG9TdHJpbmcoYmFzZSB8fCA4KTtcbiAgICAgIHJldHVybiAnMDAwMDAwMDAwMDAwJy5zdWJzdHIobnVtLmxlbmd0aCArIDEyIC0gYnl0ZXMpICsgbnVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1RvVWludDgoaW5wdXQsIG91dCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgaSwgbGVuZ3RoO1xuICAgICAgb3V0ID0gb3V0IHx8IGNsZWFuKGlucHV0Lmxlbmd0aCk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gaW5wdXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgb3V0W29mZnNldF0gPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMyxcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICAgICAgb3V0cHV0ID0gJycsXG4gICAgICAgICAgdGVtcCxcbiAgICAgICAgICBsZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pIHtcbiAgICAgICAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNmXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNmXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M2ZdICsgbG9va3VwW251bSAmIDB4M2ZdO1xuICAgICAgfSAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArIHVpbnQ4W2kgKyAyXTtcbiAgICAgICAgb3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKTtcbiAgICAgIH0gLy8gdGhpcyBwcmV2ZW50cyBhbiBFUlJfSU5WQUxJRF9VUkwgaW4gQ2hyb21lIChGaXJlZm94IG9rYXkpXG5cblxuICAgICAgc3dpdGNoIChvdXRwdXQubGVuZ3RoICUgNCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgb3V0cHV0ICs9ICc9JztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgb3V0cHV0ICs9ICc9PSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgd2luZG93LnV0aWxzID0ge307XG4gICAgd2luZG93LnV0aWxzLmNsZWFuID0gY2xlYW47XG4gICAgd2luZG93LnV0aWxzLnBhZCA9IHBhZDtcbiAgICB3aW5kb3cudXRpbHMuZXh0ZW5kID0gZXh0ZW5kO1xuICAgIHdpbmRvdy51dGlscy5zdHJpbmdUb1VpbnQ4ID0gc3RyaW5nVG9VaW50ODtcbiAgICB3aW5kb3cudXRpbHMudWludDhUb0Jhc2U2NCA9IHVpbnQ4VG9CYXNlNjQ7XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAvKlxuICAgIHN0cnVjdCBwb3NpeF9oZWFkZXIgeyAgICAgICAgICAgICAvLyBieXRlIG9mZnNldFxuICAgIGNoYXIgbmFtZVsxMDBdOyAgICAgICAgICAgICAgIC8vICAgMFxuICAgIGNoYXIgbW9kZVs4XTsgICAgICAgICAgICAgICAgIC8vIDEwMFxuICAgIGNoYXIgdWlkWzhdOyAgICAgICAgICAgICAgICAgIC8vIDEwOFxuICAgIGNoYXIgZ2lkWzhdOyAgICAgICAgICAgICAgICAgIC8vIDExNlxuICAgIGNoYXIgc2l6ZVsxMl07ICAgICAgICAgICAgICAgIC8vIDEyNFxuICAgIGNoYXIgbXRpbWVbMTJdOyAgICAgICAgICAgICAgIC8vIDEzNlxuICAgIGNoYXIgY2hrc3VtWzhdOyAgICAgICAgICAgICAgIC8vIDE0OFxuICAgIGNoYXIgdHlwZWZsYWc7ICAgICAgICAgICAgICAgIC8vIDE1NlxuICAgIGNoYXIgbGlua25hbWVbMTAwXTsgICAgICAgICAgIC8vIDE1N1xuICAgIGNoYXIgbWFnaWNbNl07ICAgICAgICAgICAgICAgIC8vIDI1N1xuICAgIGNoYXIgdmVyc2lvblsyXTsgICAgICAgICAgICAgIC8vIDI2M1xuICAgIGNoYXIgdW5hbWVbMzJdOyAgICAgICAgICAgICAgIC8vIDI2NVxuICAgIGNoYXIgZ25hbWVbMzJdOyAgICAgICAgICAgICAgIC8vIDI5N1xuICAgIGNoYXIgZGV2bWFqb3JbOF07ICAgICAgICAgICAgIC8vIDMyOVxuICAgIGNoYXIgZGV2bWlub3JbOF07ICAgICAgICAgICAgIC8vIDMzN1xuICAgIGNoYXIgcHJlZml4WzE1NV07ICAgICAgICAgICAgIC8vIDM0NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNTAwXG4gICAgfTtcbiAgICAqL1xuXG4gICAgdmFyIHV0aWxzID0gd2luZG93LnV0aWxzLFxuICAgICAgICBoZWFkZXJGb3JtYXQ7XG4gICAgaGVhZGVyRm9ybWF0ID0gW3tcbiAgICAgIGZpZWxkOiAnZmlsZU5hbWUnLFxuICAgICAgbGVuZ3RoOiAxMDBcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ2ZpbGVNb2RlJyxcbiAgICAgIGxlbmd0aDogOFxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAndWlkJyxcbiAgICAgIGxlbmd0aDogOFxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAnZ2lkJyxcbiAgICAgIGxlbmd0aDogOFxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAnZmlsZVNpemUnLFxuICAgICAgbGVuZ3RoOiAxMlxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAnbXRpbWUnLFxuICAgICAgbGVuZ3RoOiAxMlxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAnY2hlY2tzdW0nLFxuICAgICAgbGVuZ3RoOiA4XG4gICAgfSwge1xuICAgICAgZmllbGQ6ICd0eXBlJyxcbiAgICAgIGxlbmd0aDogMVxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAnbGlua05hbWUnLFxuICAgICAgbGVuZ3RoOiAxMDBcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ3VzdGFyJyxcbiAgICAgIGxlbmd0aDogOFxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAnb3duZXInLFxuICAgICAgbGVuZ3RoOiAzMlxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAnZ3JvdXAnLFxuICAgICAgbGVuZ3RoOiAzMlxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAnbWFqb3JOdW1iZXInLFxuICAgICAgbGVuZ3RoOiA4XG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdtaW5vck51bWJlcicsXG4gICAgICBsZW5ndGg6IDhcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ2ZpbGVuYW1lUHJlZml4JyxcbiAgICAgIGxlbmd0aDogMTU1XG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdwYWRkaW5nJyxcbiAgICAgIGxlbmd0aDogMTJcbiAgICB9XTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdEhlYWRlcihkYXRhLCBjYikge1xuICAgICAgdmFyIGJ1ZmZlciA9IHV0aWxzLmNsZWFuKDUxMiksXG4gICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGhlYWRlckZvcm1hdC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc3RyID0gZGF0YVt2YWx1ZS5maWVsZF0gfHwgJycsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHN0ci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXQgKz0gdmFsdWUubGVuZ3RoIC0gaTsgLy8gc3BhY2UgaXQgb3V0IHdpdGggbnVsbHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjYihidWZmZXIsIG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG4gICAgd2luZG93LmhlYWRlciA9IHt9O1xuICAgIHdpbmRvdy5oZWFkZXIuc3RydWN0dXJlID0gaGVhZGVyRm9ybWF0O1xuICAgIHdpbmRvdy5oZWFkZXIuZm9ybWF0ID0gZm9ybWF0SGVhZGVyO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgaGVhZGVyID0gd2luZG93LmhlYWRlcixcbiAgICAgICAgdXRpbHMgPSB3aW5kb3cudXRpbHMsXG4gICAgICAgIHJlY29yZFNpemUgPSA1MTIsXG4gICAgICAgIGJsb2NrU2l6ZTtcblxuICAgIGZ1bmN0aW9uIFRhcihyZWNvcmRzUGVyQmxvY2spIHtcbiAgICAgIHRoaXMud3JpdHRlbiA9IDA7XG4gICAgICBibG9ja1NpemUgPSAocmVjb3Jkc1BlckJsb2NrIHx8IDIwKSAqIHJlY29yZFNpemU7XG4gICAgICB0aGlzLm91dCA9IHV0aWxzLmNsZWFuKGJsb2NrU2l6ZSk7XG4gICAgICB0aGlzLmJsb2NrcyA9IFtdO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIFRhci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGZpbGVwYXRoLCBpbnB1dCwgb3B0cywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBkYXRhLCBjaGVja3N1bSwgbW9kZSwgbXRpbWUsIHVpZCwgZ2lkLCBoZWFkZXJBcnI7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlucHV0ID0gdXRpbHMuc3RyaW5nVG9VaW50OChpbnB1dCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LmNvbnN0cnVjdG9yICE9PSBVaW50OEFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aHJvdyAnSW52YWxpZCBpbnB1dCB0eXBlLiBZb3UgZ2F2ZSBtZTogJyArIGlucHV0LmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkubWF0Y2goL2Z1bmN0aW9uXFxzKihbJEEtWmEtel9dWzAtOUEtWmEtel9dKilcXHMqXFwoLylbMV07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG5cbiAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgbW9kZSA9IG9wdHMubW9kZSB8fCBwYXJzZUludCgnNzc3JywgOCkgJiAweGZmZjtcbiAgICAgIG10aW1lID0gb3B0cy5tdGltZSB8fCBNYXRoLmZsb29yKCtuZXcgRGF0ZSgpIC8gMTAwMCk7XG4gICAgICB1aWQgPSBvcHRzLnVpZCB8fCAwO1xuICAgICAgZ2lkID0gb3B0cy5naWQgfHwgMDtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIGZpbGVOYW1lOiBmaWxlcGF0aCxcbiAgICAgICAgZmlsZU1vZGU6IHV0aWxzLnBhZChtb2RlLCA3KSxcbiAgICAgICAgdWlkOiB1dGlscy5wYWQodWlkLCA3KSxcbiAgICAgICAgZ2lkOiB1dGlscy5wYWQoZ2lkLCA3KSxcbiAgICAgICAgZmlsZVNpemU6IHV0aWxzLnBhZChpbnB1dC5sZW5ndGgsIDExKSxcbiAgICAgICAgbXRpbWU6IHV0aWxzLnBhZChtdGltZSwgMTEpLFxuICAgICAgICBjaGVja3N1bTogJyAgICAgICAgJyxcbiAgICAgICAgdHlwZTogJzAnLFxuICAgICAgICAvLyBqdXN0IGEgZmlsZVxuICAgICAgICB1c3RhcjogJ3VzdGFyICAnLFxuICAgICAgICBvd25lcjogb3B0cy5vd25lciB8fCAnJyxcbiAgICAgICAgZ3JvdXA6IG9wdHMuZ3JvdXAgfHwgJydcbiAgICAgIH07IC8vIGNhbGN1bGF0ZSB0aGUgY2hlY2tzdW1cblxuICAgICAgY2hlY2tzdW0gPSAwO1xuICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgdmFsdWUgPSBkYXRhW2tleV0sXG4gICAgICAgICAgICBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjaGVja3N1bSArPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRhdGEuY2hlY2tzdW0gPSB1dGlscy5wYWQoY2hlY2tzdW0sIDYpICsgJ1xcdTAwMDAgJztcbiAgICAgIGhlYWRlckFyciA9IGhlYWRlci5mb3JtYXQoZGF0YSk7XG4gICAgICB2YXIgaGVhZGVyTGVuZ3RoID0gTWF0aC5jZWlsKGhlYWRlckFyci5sZW5ndGggLyByZWNvcmRTaXplKSAqIHJlY29yZFNpemU7XG4gICAgICB2YXIgaW5wdXRMZW5ndGggPSBNYXRoLmNlaWwoaW5wdXQubGVuZ3RoIC8gcmVjb3JkU2l6ZSkgKiByZWNvcmRTaXplO1xuICAgICAgdGhpcy5ibG9ja3MucHVzaCh7XG4gICAgICAgIGhlYWRlcjogaGVhZGVyQXJyLFxuICAgICAgICBpbnB1dDogaW5wdXQsXG4gICAgICAgIGhlYWRlckxlbmd0aDogaGVhZGVyTGVuZ3RoLFxuICAgICAgICBpbnB1dExlbmd0aDogaW5wdXRMZW5ndGhcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUYXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYnVmZmVycyA9IFtdO1xuICAgICAgdmFyIGNodW5rcyA9IFtdO1xuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICB2YXIgbWF4ID0gTWF0aC5wb3coMiwgMjApO1xuICAgICAgdmFyIGNodW5rID0gW107XG4gICAgICB0aGlzLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGlmIChsZW5ndGggKyBiLmhlYWRlckxlbmd0aCArIGIuaW5wdXRMZW5ndGggPiBtYXgpIHtcbiAgICAgICAgICBjaHVua3MucHVzaCh7XG4gICAgICAgICAgICBibG9ja3M6IGNodW5rLFxuICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjaHVuayA9IFtdO1xuICAgICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjaHVuay5wdXNoKGIpO1xuICAgICAgICBsZW5ndGggKz0gYi5oZWFkZXJMZW5ndGggKyBiLmlucHV0TGVuZ3RoO1xuICAgICAgfSk7XG4gICAgICBjaHVua3MucHVzaCh7XG4gICAgICAgIGJsb2NrczogY2h1bmssXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShjLmxlbmd0aCk7XG4gICAgICAgIHZhciB3cml0dGVuID0gMDtcbiAgICAgICAgYy5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGJ1ZmZlci5zZXQoYi5oZWFkZXIsIHdyaXR0ZW4pO1xuICAgICAgICAgIHdyaXR0ZW4gKz0gYi5oZWFkZXJMZW5ndGg7XG4gICAgICAgICAgYnVmZmVyLnNldChiLmlucHV0LCB3cml0dGVuKTtcbiAgICAgICAgICB3cml0dGVuICs9IGIuaW5wdXRMZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICAgIH0pO1xuICAgICAgYnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KDIgKiByZWNvcmRTaXplKSk7XG4gICAgICByZXR1cm4gbmV3IEJsb2IoYnVmZmVycywge1xuICAgICAgICB0eXBlOiAnb2N0ZXQvc3RyZWFtJ1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRhci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLndyaXR0ZW4gPSAwO1xuICAgICAgdGhpcy5vdXQgPSB1dGlscy5jbGVhbihibG9ja1NpemUpO1xuICAgIH07XG5cbiAgICB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IFRhcjtcbiAgICB9XG4gIH0pKCk7XG59KSh0YXIpO1xuXG52YXIgZG93bmxvYWQgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIChmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIHtcbiAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9XG4gIH0pKGNvbW1vbmpzR2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRvd25sb2FkKGRhdGEsIHN0ckZpbGVOYW1lLCBzdHJNaW1lVHlwZSkge1xuICAgICAgdmFyIHNlbGYgPSB3aW5kb3csXG4gICAgICAgICAgLy8gdGhpcyBzY3JpcHQgaXMgb25seSBmb3IgYnJvd3NlcnMgYW55d2F5Li4uXG4gICAgICBkZWZhdWx0TWltZSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICAgIC8vIHRoaXMgZGVmYXVsdCBtaW1lIGFsc28gdHJpZ2dlcnMgaWZyYW1lIGRvd25sb2Fkc1xuICAgICAgbWltZVR5cGUgPSBzdHJNaW1lVHlwZSB8fCBkZWZhdWx0TWltZSxcbiAgICAgICAgICBwYXlsb2FkID0gZGF0YSxcbiAgICAgICAgICB1cmwgPSAhc3RyRmlsZU5hbWUgJiYgIXN0ck1pbWVUeXBlICYmIHBheWxvYWQsXG4gICAgICAgICAgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpLFxuICAgICAgICAgIHRvU3RyaW5nID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhKTtcbiAgICAgIH0sXG4gICAgICAgICAgbXlCbG9iID0gc2VsZi5CbG9iIHx8IHNlbGYuTW96QmxvYiB8fCBzZWxmLldlYktpdEJsb2IgfHwgdG9TdHJpbmcsXG4gICAgICAgICAgZmlsZU5hbWUgPSBzdHJGaWxlTmFtZSB8fCAnZG93bmxvYWQnLFxuICAgICAgICAgIGJsb2IsXG4gICAgICAgICAgcmVhZGVyO1xuXG4gICAgICBteUJsb2IgPSBteUJsb2IuY2FsbCA/IG15QmxvYi5iaW5kKHNlbGYpIDogQmxvYjtcblxuICAgICAgaWYgKFN0cmluZyh0aGlzKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIC8vcmV2ZXJzZSBhcmd1bWVudHMsIGFsbG93aW5nIGRvd25sb2FkLmJpbmQodHJ1ZSwgXCJ0ZXh0L3htbFwiLCBcImV4cG9ydC54bWxcIikgdG8gYWN0IGFzIGEgY2FsbGJhY2tcbiAgICAgICAgcGF5bG9hZCA9IFtwYXlsb2FkLCBtaW1lVHlwZV07XG4gICAgICAgIG1pbWVUeXBlID0gcGF5bG9hZFswXTtcbiAgICAgICAgcGF5bG9hZCA9IHBheWxvYWRbMV07XG4gICAgICB9XG5cbiAgICAgIGlmICh1cmwgJiYgdXJsLmxlbmd0aCA8IDIwNDgpIHtcbiAgICAgICAgLy8gaWYgbm8gZmlsZW5hbWUgYW5kIG5vIG1pbWUsIGFzc3VtZSBhIHVybCB3YXMgcGFzc2VkIGFzIHRoZSBvbmx5IGFyZ3VtZW50XG4gICAgICAgIGZpbGVOYW1lID0gdXJsLnNwbGl0KCcvJykucG9wKCkuc3BsaXQoJz8nKVswXTtcbiAgICAgICAgYW5jaG9yLmhyZWYgPSB1cmw7IC8vIGFzc2lnbiBocmVmIHByb3AgdG8gdGVtcCBhbmNob3JcblxuICAgICAgICBpZiAoYW5jaG9yLmhyZWYuaW5kZXhPZih1cmwpICE9PSAtMSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBicm93c2VyIGRldGVybWluZXMgdGhhdCBpdCdzIGEgcG90ZW50aWFsbHkgdmFsaWQgdXJsIHBhdGg6XG4gICAgICAgICAgdmFyIGFqYXggPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICBhamF4Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgICAgYWpheC5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG5cbiAgICAgICAgICBhamF4Lm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBkb3dubG9hZChlLnRhcmdldC5yZXNwb25zZSwgZmlsZU5hbWUsIGRlZmF1bHRNaW1lKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhamF4LnNlbmQoKTtcbiAgICAgICAgICB9LCAwKTsgLy8gYWxsb3dzIHNldHRpbmcgY3VzdG9tIGFqYXggaGVhZGVycyB1c2luZyB0aGUgcmV0dXJuOlxuXG4gICAgICAgICAgcmV0dXJuIGFqYXg7XG4gICAgICAgIH0gLy8gZW5kIGlmIHZhbGlkIHVybD9cblxuICAgICAgfSAvLyBlbmQgaWYgdXJsP1xuICAgICAgLy9nbyBhaGVhZCBhbmQgZG93bmxvYWQgZGF0YVVSTHMgcmlnaHQgYXdheVxuXG5cbiAgICAgIGlmICgvXmRhdGE6KFtcXHcrLV0rXFwvW1xcdysuLV0rKT9bLDtdLy50ZXN0KHBheWxvYWQpKSB7XG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA+IDEwMjQgKiAxMDI0ICogMS45OTkgJiYgbXlCbG9iICE9PSB0b1N0cmluZykge1xuICAgICAgICAgIHBheWxvYWQgPSBkYXRhVXJsVG9CbG9iKHBheWxvYWQpO1xuICAgICAgICAgIG1pbWVUeXBlID0gcGF5bG9hZC50eXBlIHx8IGRlZmF1bHRNaW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubXNTYXZlQmxvYiAvLyBJRTEwIGNhbid0IGRvIGFbZG93bmxvYWRdLCBvbmx5IEJsb2JzOlxuICAgICAgICAgID8gbmF2aWdhdG9yLm1zU2F2ZUJsb2IoZGF0YVVybFRvQmxvYihwYXlsb2FkKSwgZmlsZU5hbWUpIDogc2F2ZXIocGF5bG9hZCk7IC8vIGV2ZXJ5b25lIGVsc2UgY2FuIHNhdmUgZGF0YVVSTHMgdW4tcHJvY2Vzc2VkXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vbm90IGRhdGEgdXJsLCBpcyBpdCBhIHN0cmluZyB3aXRoIHNwZWNpYWwgbmVlZHM/XG4gICAgICAgIGlmICgvKFtcXHg4MC1cXHhmZl0pLy50ZXN0KHBheWxvYWQpKSB7XG4gICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICB0ZW1wVWlBcnIgPSBuZXcgVWludDhBcnJheShwYXlsb2FkLmxlbmd0aCksXG4gICAgICAgICAgICAgIG14ID0gdGVtcFVpQXJyLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaTsgaSA8IG14OyArK2kpIHRlbXBVaUFycltpXSA9IHBheWxvYWQuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAgIHBheWxvYWQgPSBuZXcgbXlCbG9iKFt0ZW1wVWlBcnJdLCB7XG4gICAgICAgICAgICB0eXBlOiBtaW1lVHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJsb2IgPSBwYXlsb2FkIGluc3RhbmNlb2YgbXlCbG9iID8gcGF5bG9hZCA6IG5ldyBteUJsb2IoW3BheWxvYWRdLCB7XG4gICAgICAgIHR5cGU6IG1pbWVUeXBlXG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gZGF0YVVybFRvQmxvYihzdHJVcmwpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gc3RyVXJsLnNwbGl0KC9bOjssXS8pLFxuICAgICAgICAgICAgdHlwZSA9IHBhcnRzWzFdLFxuICAgICAgICAgICAgaW5kZXhEZWNvZGVyID0gc3RyVXJsLmluZGV4T2YoJ2NoYXJzZXQnKSA+IDAgPyAzIDogMixcbiAgICAgICAgICAgIGRlY29kZXIgPSBwYXJ0c1tpbmRleERlY29kZXJdID09ICdiYXNlNjQnID8gYXRvYiA6IGRlY29kZVVSSUNvbXBvbmVudCxcbiAgICAgICAgICAgIGJpbkRhdGEgPSBkZWNvZGVyKHBhcnRzLnBvcCgpKSxcbiAgICAgICAgICAgIG14ID0gYmluRGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIHVpQXJyID0gbmV3IFVpbnQ4QXJyYXkobXgpO1xuXG4gICAgICAgIGZvciAoaTsgaSA8IG14OyArK2kpIHVpQXJyW2ldID0gYmluRGF0YS5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIHJldHVybiBuZXcgbXlCbG9iKFt1aUFycl0sIHtcbiAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzYXZlcih1cmwsIHdpbk1vZGUpIHtcbiAgICAgICAgaWYgKCdkb3dubG9hZCcgaW4gYW5jaG9yKSB7XG4gICAgICAgICAgLy9odG1sNSBBW2Rvd25sb2FkXVxuICAgICAgICAgIGFuY2hvci5ocmVmID0gdXJsO1xuICAgICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ2Rvd25sb2FkJywgZmlsZU5hbWUpO1xuICAgICAgICAgIGFuY2hvci5jbGFzc05hbWUgPSAnZG93bmxvYWQtanMtbGluayc7XG4gICAgICAgICAgYW5jaG9yLmlubmVySFRNTCA9ICdkb3dubG9hZGluZy4uLic7XG4gICAgICAgICAgYW5jaG9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgYW5jaG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhbmNob3IpO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYW5jaG9yLmNsaWNrKCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGFuY2hvcik7XG5cbiAgICAgICAgICAgIGlmICh3aW5Nb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTChhbmNob3IuaHJlZik7XG4gICAgICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgNjYpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIGhhbmRsZSBub24tYVtkb3dubG9hZF0gc2FmYXJpIGFzIGJlc3Qgd2UgY2FuOlxuXG5cbiAgICAgICAgaWYgKC8oVmVyc2lvbilcXC8oXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPy4qU2FmYXJpXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgaWYgKC9eZGF0YTovLnRlc3QodXJsKSkgdXJsID0gJ2RhdGE6JyArIHVybC5yZXBsYWNlKC9eZGF0YTooW1xcd1xcL1xcLVxcK10rKS8sIGRlZmF1bHRNaW1lKTtcblxuICAgICAgICAgIGlmICghd2luZG93Lm9wZW4odXJsKSkge1xuICAgICAgICAgICAgLy8gcG9wdXAgYmxvY2tlZCwgb2ZmZXIgZGlyZWN0IGRvd25sb2FkOlxuICAgICAgICAgICAgaWYgKGNvbmZpcm0oJ0Rpc3BsYXlpbmcgTmV3IERvY3VtZW50XFxuXFxuVXNlIFNhdmUgQXMuLi4gdG8gZG93bmxvYWQsIHRoZW4gY2xpY2sgYmFjayB0byByZXR1cm4gdG8gdGhpcyBwYWdlLicpKSB7XG4gICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy9kbyBpZnJhbWUgZGF0YVVSTCBkb3dubG9hZCAob2xkIGNoK0ZGKTpcblxuXG4gICAgICAgIHZhciBmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZik7XG5cbiAgICAgICAgaWYgKCF3aW5Nb2RlICYmIC9eZGF0YTovLnRlc3QodXJsKSkge1xuICAgICAgICAgIC8vIGZvcmNlIGEgbWltZSB0aGF0IHdpbGwgZG93bmxvYWQ6XG4gICAgICAgICAgdXJsID0gJ2RhdGE6JyArIHVybC5yZXBsYWNlKC9eZGF0YTooW1xcd1xcL1xcLVxcK10rKS8sIGRlZmF1bHRNaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGYuc3JjID0gdXJsO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGYpO1xuICAgICAgICB9LCAzMzMpO1xuICAgICAgfSAvL2VuZCBzYXZlclxuXG5cbiAgICAgIGlmIChuYXZpZ2F0b3IubXNTYXZlQmxvYikge1xuICAgICAgICAvLyBJRTEwKyA6IChoYXMgQmxvYiwgYnV0IG5vdCBhW2Rvd25sb2FkXSBvciBVUkwpXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubXNTYXZlQmxvYihibG9iLCBmaWxlTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLlVSTCkge1xuICAgICAgICAvLyBzaW1wbGUgZmFzdCBhbmQgbW9kZXJuIHdheSB1c2luZyBCbG9iIGFuZCBVUkw6XG4gICAgICAgIHNhdmVyKHNlbGYuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoYW5kbGUgbm9uLUJsb2IoKStub24tVVJMIGJyb3dzZXJzOlxuICAgICAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdzdHJpbmcnIHx8IGJsb2IuY29uc3RydWN0b3IgPT09IHRvU3RyaW5nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzYXZlcignZGF0YTonICsgbWltZVR5cGUgKyAnO2Jhc2U2NCwnICsgc2VsZi5idG9hKGJsb2IpKTtcbiAgICAgICAgICB9IGNhdGNoICh5KSB7XG4gICAgICAgICAgICByZXR1cm4gc2F2ZXIoJ2RhdGE6JyArIG1pbWVUeXBlICsgJywnICsgZW5jb2RlVVJJQ29tcG9uZW50KGJsb2IpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQmxvYiBidXQgbm90IFVSTCBzdXBwb3J0OlxuXG5cbiAgICAgICAgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBzYXZlcih0aGlzLnJlc3VsdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyogZW5kIGRvd25sb2FkKCkgKi9cbiAgfSk7XG59KShkb3dubG9hZCk7XG5cbnZhciBnaWYgPSB7fTtcblxuKGZ1bmN0aW9uIChjKSB7XG4gIGZ1bmN0aW9uIGEoYiwgZCkge1xuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEuY2FjaGUsIGIpKSByZXR1cm4gYS5jYWNoZVtiXTtcbiAgICB2YXIgZSA9IGEucmVzb2x2ZShiKTtcbiAgICBpZiAoIWUpIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc29sdmUgbW9kdWxlICcgKyBiKTtcbiAgICB2YXIgYyA9IHtcbiAgICAgIGlkOiBiLFxuICAgICAgcmVxdWlyZTogYSxcbiAgICAgIGZpbGVuYW1lOiBiLFxuICAgICAgZXhwb3J0czoge30sXG4gICAgICBsb2FkZWQ6ICExLFxuICAgICAgcGFyZW50OiBkLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfTtcbiAgICBkICYmIGQuY2hpbGRyZW4ucHVzaChjKTtcbiAgICB2YXIgZiA9IGIuc2xpY2UoMCwgYi5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgcmV0dXJuIGEuY2FjaGVbYl0gPSBjLmV4cG9ydHMsIGUuY2FsbChjLmV4cG9ydHMsIGMsIGMuZXhwb3J0cywgZiwgYiksIGMubG9hZGVkID0gITAsIGEuY2FjaGVbYl0gPSBjLmV4cG9ydHM7XG4gIH1cbiAgYS5tb2R1bGVzID0ge30sIGEuY2FjaGUgPSB7fSwgYS5yZXNvbHZlID0gZnVuY3Rpb24gKGIpIHtcbiAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChhLm1vZHVsZXMsIGIpID8gYS5tb2R1bGVzW2JdIDogdm9pZCAwO1xuICB9LCBhLmRlZmluZSA9IGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgYS5tb2R1bGVzW2JdID0gYztcbiAgfTtcblxuICB2YXIgYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGEgPSAnLycsIHtcbiAgICAgIHRpdGxlOiAnYnJvd3NlcicsXG4gICAgICB2ZXJzaW9uOiAndjAuMTAuMjYnLFxuICAgICAgYnJvd3NlcjogITAsXG4gICAgICBlbnY6IHt9LFxuICAgICAgYXJndjogW10sXG4gICAgICBuZXh0VGljazogYy5zZXRJbW1lZGlhdGUgfHwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgc2V0VGltZW91dChhLCAwKTtcbiAgICAgIH0sXG4gICAgICBjd2Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LFxuICAgICAgY2hkaXI6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgfVxuICAgIH07XG4gIH0oKTtcblxuICBhLmRlZmluZSgnL2dpZi5jb2ZmZWUnLCBmdW5jdGlvbiAoZCwgbSwgbCwgaykge1xuICAgIGZ1bmN0aW9uIGcoYSwgYikge1xuICAgICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaihkLCBiKSB7XG4gICAgICBmb3IgKHZhciBhID0gMCwgYyA9IGIubGVuZ3RoOyBhIDwgYzsgKythKSBpZiAoYSBpbiBiICYmIGJbYV0gPT09IGQpIHJldHVybiAhMDtcblxuICAgICAgcmV0dXJuICExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGkoYSwgYikge1xuICAgICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGE7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGMgaW4gYikgZyhiLCBjKSAmJiAoYVtjXSA9IGJbY10pO1xuXG4gICAgICByZXR1cm4gZC5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgYS5wcm90b3R5cGUgPSBuZXcgZCgpLCBhLl9fc3VwZXJfXyA9IGIucHJvdG90eXBlLCBhO1xuICAgIH1cblxuICAgIHZhciBoLCBjLCBmLCBiLCBlO1xuICAgIGYgPSBhKCdldmVudHMnLCBkKS5FdmVudEVtaXR0ZXIsIGggPSBhKCcvYnJvd3Nlci5jb2ZmZWUnLCBkKSwgZSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICBmdW5jdGlvbiBhKGQpIHtcbiAgICAgICAgdmFyIGEsIGI7XG4gICAgICAgIHRoaXMucnVubmluZyA9ICExLCB0aGlzLm9wdGlvbnMgPSB7fSwgdGhpcy5mcmFtZXMgPSBbXSwgdGhpcy5mcmVlV29ya2VycyA9IFtdLCB0aGlzLmFjdGl2ZVdvcmtlcnMgPSBbXSwgdGhpcy5zZXRPcHRpb25zKGQpO1xuXG4gICAgICAgIGZvciAoYSBpbiBjKSBiID0gY1thXSwgbnVsbCAhPSB0aGlzLm9wdGlvbnNbYV0gPyB0aGlzLm9wdGlvbnNbYV0gOiB0aGlzLm9wdGlvbnNbYV0gPSBiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaShhLCBkKSwgYyA9IHtcbiAgICAgICAgd29ya2VyU2NyaXB0OiAnZ2lmLndvcmtlci5qcycsXG4gICAgICAgIHdvcmtlcnM6IDIsXG4gICAgICAgIHJlcGVhdDogMCxcbiAgICAgICAgYmFja2dyb3VuZDogJyNmZmYnLFxuICAgICAgICBxdWFsaXR5OiAxMCxcbiAgICAgICAgd2lkdGg6IG51bGwsXG4gICAgICAgIGhlaWdodDogbnVsbCxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IG51bGxcbiAgICAgIH0sIGIgPSB7XG4gICAgICAgIGRlbGF5OiA1MDAsXG4gICAgICAgIGNvcHk6ICExXG4gICAgICB9LCBhLnByb3RvdHlwZS5zZXRPcHRpb24gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW2FdID0gYiwgbnVsbCAhPSB0aGlzLl9jYW52YXMgJiYgKGEgPT09ICd3aWR0aCcgfHwgYSA9PT0gJ2hlaWdodCcpID8gdGhpcy5fY2FudmFzW2FdID0gYiA6IHZvaWQgMDtcbiAgICAgIH0sIGEucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSwgYztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZm9yIChhIGluIGIpIHtcbiAgICAgICAgICAgIGlmICghZyhiLCBhKSkgY29udGludWU7XG4gICAgICAgICAgICBjID0gYlthXSwgZC5wdXNoKHRoaXMuc2V0T3B0aW9uKGEsIGMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfS5jYWxsKHRoaXMsIFtdKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLmFkZEZyYW1lID0gZnVuY3Rpb24gKGEsIGQpIHtcbiAgICAgICAgdmFyIGMsIGU7XG4gICAgICAgIG51bGwgPT0gZCAmJiAoZCA9IHt9KSwgYyA9IHt9LCBjLnRyYW5zcGFyZW50ID0gdGhpcy5vcHRpb25zLnRyYW5zcGFyZW50O1xuXG4gICAgICAgIGZvciAoZSBpbiBiKSBjW2VdID0gZFtlXSB8fCBiW2VdO1xuXG4gICAgICAgIGlmIChudWxsICE9IHRoaXMub3B0aW9ucy53aWR0aCB8fCB0aGlzLnNldE9wdGlvbignd2lkdGgnLCBhLndpZHRoKSwgbnVsbCAhPSB0aGlzLm9wdGlvbnMuaGVpZ2h0IHx8IHRoaXMuc2V0T3B0aW9uKCdoZWlnaHQnLCBhLmhlaWdodCksICd1bmRlZmluZWQnICE9PSB0eXBlb2YgSW1hZ2VEYXRhICYmIG51bGwgIT0gSW1hZ2VEYXRhICYmIGEgaW5zdGFuY2VvZiBJbWFnZURhdGEpIGMuZGF0YSA9IGEuZGF0YTtlbHNlIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAmJiBudWxsICE9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAmJiBhIGluc3RhbmNlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHx8ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmIG51bGwgIT0gV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmIGEgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpIGQuY29weSA/IGMuZGF0YSA9IHRoaXMuZ2V0Q29udGV4dERhdGEoYSkgOiBjLmNvbnRleHQgPSBhO2Vsc2UgaWYgKG51bGwgIT0gYS5jaGlsZE5vZGVzKSBkLmNvcHkgPyBjLmRhdGEgPSB0aGlzLmdldEltYWdlRGF0YShhKSA6IGMuaW1hZ2UgPSBhO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGltYWdlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYW1lcy5wdXNoKGMpO1xuICAgICAgfSwgYS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZykgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICAgICAgaWYgKCEobnVsbCAhPSB0aGlzLm9wdGlvbnMud2lkdGggJiYgbnVsbCAhPSB0aGlzLm9wdGlvbnMuaGVpZ2h0KSkgdGhyb3cgbmV3IEVycm9yKCdXaWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgc2V0IHByaW9yIHRvIHJlbmRlcmluZycpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSAhMCwgdGhpcy5uZXh0RnJhbWUgPSAwLCB0aGlzLmZpbmlzaGVkRnJhbWVzID0gMCwgdGhpcy5pbWFnZVBhcnRzID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBmb3IgKHZhciBiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGI7XG4gICAgICAgICAgICBiID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyAwIDw9IHRoaXMuZnJhbWVzLmxlbmd0aCA/IGEgPCB0aGlzLmZyYW1lcy5sZW5ndGggOiBhID4gdGhpcy5mcmFtZXMubGVuZ3RoOyAwIDw9IHRoaXMuZnJhbWVzLmxlbmd0aCA/ICsrYSA6IC0tYSkgYi5wdXNoKGEpO1xuXG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICB9LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGEgPSAwLCBlID0gYi5sZW5ndGg7IGEgPCBlOyArK2EpIGMucHVzaChudWxsKTtcblxuICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9LmNhbGwodGhpcywgW10pLCBhID0gdGhpcy5zcGF3bldvcmtlcnMoKTtcblxuICAgICAgICBmb3IgKHZhciBjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBjO1xuICAgICAgICAgIGMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGIgPSAwOyAwIDw9IGEgPyBiIDwgYSA6IGIgPiBhOyAwIDw9IGEgPyArK2IgOiAtLWIpIGMucHVzaChiKTtcblxuICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGIgPSAwLCBlID0gYy5sZW5ndGg7IGIgPCBlOyArK2IpIHRoaXMucmVuZGVyTmV4dEZyYW1lKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnc3RhcnQnKSwgdGhpcy5lbWl0KCdwcm9ncmVzcycsIDApO1xuICAgICAgfSwgYS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhO1xuXG4gICAgICAgIHdoaWxlICghMCkge1xuICAgICAgICAgIGlmIChhID0gdGhpcy5hY3RpdmVXb3JrZXJzLnNoaWZ0KCksICEobnVsbCAhPSBhKSkgYnJlYWs7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2tpbGxpbmcgYWN0aXZlIHdvcmtlcicpLCBhLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucnVubmluZyA9ICExLCB0aGlzLmVtaXQoJ2Fib3J0Jyk7XG4gICAgICB9LCBhLnByb3RvdHlwZS5zcGF3bldvcmtlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhO1xuICAgICAgICByZXR1cm4gYSA9IE1hdGgubWluKHRoaXMub3B0aW9ucy53b3JrZXJzLCB0aGlzLmZyYW1lcy5sZW5ndGgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGM7XG4gICAgICAgICAgYyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgYiA9IHRoaXMuZnJlZVdvcmtlcnMubGVuZ3RoOyB0aGlzLmZyZWVXb3JrZXJzLmxlbmd0aCA8PSBhID8gYiA8IGEgOiBiID4gYTsgdGhpcy5mcmVlV29ya2Vycy5sZW5ndGggPD0gYSA/ICsrYiA6IC0tYikgYy5wdXNoKGIpO1xuXG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0uYXBwbHkodGhpcywgYXJndW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICB2YXIgYjtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZygnc3Bhd25pbmcgd29ya2VyICcgKyBjKSwgYiA9IG5ldyBXb3JrZXIoYS5vcHRpb25zLndvcmtlclNjcmlwdCksIGIub25tZXNzYWdlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuYWN0aXZlV29ya2Vycy5zcGxpY2UoYS5hY3RpdmVXb3JrZXJzLmluZGV4T2YoYiksIDEpLCBhLmZyZWVXb3JrZXJzLnB1c2goYiksIGEuZnJhbWVGaW5pc2hlZChjLmRhdGEpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfShhKSwgYS5mcmVlV29ya2Vycy5wdXNoKGIpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0odGhpcykpLCBhO1xuICAgICAgfSwgYS5wcm90b3R5cGUuZnJhbWVGaW5pc2hlZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmxvZygnZnJhbWUgJyArIGEuaW5kZXggKyAnIGZpbmlzaGVkIC0gJyArIHRoaXMuYWN0aXZlV29ya2Vycy5sZW5ndGggKyAnIGFjdGl2ZScpLCB0aGlzLmZpbmlzaGVkRnJhbWVzKyssIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCB0aGlzLmZpbmlzaGVkRnJhbWVzIC8gdGhpcy5mcmFtZXMubGVuZ3RoKSwgdGhpcy5pbWFnZVBhcnRzW2EuaW5kZXhdID0gYSwgaihudWxsLCB0aGlzLmltYWdlUGFydHMpID8gdGhpcy5yZW5kZXJOZXh0RnJhbWUoKSA6IHRoaXMuZmluaXNoUmVuZGVyaW5nKCk7XG4gICAgICB9LCBhLnByb3RvdHlwZS5maW5pc2hSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlLCBhLCBrLCBtLCBiLCBkLCBoO1xuICAgICAgICBiID0gMDtcblxuICAgICAgICBmb3IgKHZhciBmID0gMCwgaiA9IHRoaXMuaW1hZ2VQYXJ0cy5sZW5ndGg7IGYgPCBqOyArK2YpIGEgPSB0aGlzLmltYWdlUGFydHNbZl0sIGIgKz0gKGEuZGF0YS5sZW5ndGggLSAxKSAqIGEucGFnZVNpemUgKyBhLmN1cnNvcjtcblxuICAgICAgICBiICs9IGEucGFnZVNpemUgLSBhLmN1cnNvciwgY29uc29sZS5sb2coJ3JlbmRlcmluZyBmaW5pc2hlZCAtIGZpbGVzaXplICcgKyBNYXRoLnJvdW5kKGIgLyAxZTMpICsgJ2tiJyksIGUgPSBuZXcgVWludDhBcnJheShiKSwgZCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgZyA9IDAsIGwgPSB0aGlzLmltYWdlUGFydHMubGVuZ3RoOyBnIDwgbDsgKytnKSB7XG4gICAgICAgICAgYSA9IHRoaXMuaW1hZ2VQYXJ0c1tnXTtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwLCBpID0gYS5kYXRhLmxlbmd0aDsgYyA8IGk7ICsrYykgaCA9IGEuZGF0YVtjXSwgayA9IGMsIGUuc2V0KGgsIGQpLCBrID09PSBhLmRhdGEubGVuZ3RoIC0gMSA/IGQgKz0gYS5jdXJzb3IgOiBkICs9IGEucGFnZVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbSA9IG5ldyBCbG9iKFtlXSwge1xuICAgICAgICAgIHR5cGU6ICdpbWFnZS9naWYnXG4gICAgICAgIH0pLCB0aGlzLmVtaXQoJ2ZpbmlzaGVkJywgbSwgZSk7XG4gICAgICB9LCBhLnByb3RvdHlwZS5yZW5kZXJOZXh0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjLCBhLCBiO1xuICAgICAgICBpZiAodGhpcy5mcmVlV29ya2Vycy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignTm8gZnJlZSB3b3JrZXJzJyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRGcmFtZSA+PSB0aGlzLmZyYW1lcy5sZW5ndGggPyB2b2lkIDAgOiAoYyA9IHRoaXMuZnJhbWVzW3RoaXMubmV4dEZyYW1lKytdLCBiID0gdGhpcy5mcmVlV29ya2Vycy5zaGlmdCgpLCBhID0gdGhpcy5nZXRUYXNrKGMpLCBjb25zb2xlLmxvZygnc3RhcnRpbmcgZnJhbWUgJyArIChhLmluZGV4ICsgMSkgKyAnIG9mICcgKyB0aGlzLmZyYW1lcy5sZW5ndGgpLCB0aGlzLmFjdGl2ZVdvcmtlcnMucHVzaChiKSwgYi5wb3N0TWVzc2FnZShhKSk7XG4gICAgICB9LCBhLnByb3RvdHlwZS5nZXRDb250ZXh0RGF0YSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhLmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLm9wdGlvbnMud2lkdGgsIHRoaXMub3B0aW9ucy5oZWlnaHQpLmRhdGE7XG4gICAgICB9LCBhLnByb3RvdHlwZS5nZXRJbWFnZURhdGEgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgcmV0dXJuIG51bGwgIT0gdGhpcy5fY2FudmFzIHx8ICh0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSwgdGhpcy5fY2FudmFzLndpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gdGhpcy5vcHRpb25zLmhlaWdodCksIGEgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSwgYS5zZXRGaWxsID0gdGhpcy5vcHRpb25zLmJhY2tncm91bmQsIGEuZmlsbFJlY3QoMCwgMCwgdGhpcy5vcHRpb25zLndpZHRoLCB0aGlzLm9wdGlvbnMuaGVpZ2h0KSwgYS5kcmF3SW1hZ2UoYiwgMCwgMCksIHRoaXMuZ2V0Q29udGV4dERhdGEoYSk7XG4gICAgICB9LCBhLnByb3RvdHlwZS5nZXRUYXNrID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMsIGI7XG4gICAgICAgIGlmIChjID0gdGhpcy5mcmFtZXMuaW5kZXhPZihhKSwgYiA9IHtcbiAgICAgICAgICBpbmRleDogYyxcbiAgICAgICAgICBsYXN0OiBjID09PSB0aGlzLmZyYW1lcy5sZW5ndGggLSAxLFxuICAgICAgICAgIGRlbGF5OiBhLmRlbGF5LFxuICAgICAgICAgIHRyYW5zcGFyZW50OiBhLnRyYW5zcGFyZW50LFxuICAgICAgICAgIHdpZHRoOiB0aGlzLm9wdGlvbnMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMuaGVpZ2h0LFxuICAgICAgICAgIHF1YWxpdHk6IHRoaXMub3B0aW9ucy5xdWFsaXR5LFxuICAgICAgICAgIHJlcGVhdDogdGhpcy5vcHRpb25zLnJlcGVhdCxcbiAgICAgICAgICBjYW5UcmFuc2ZlcjogaC5uYW1lID09PSAnY2hyb21lJ1xuICAgICAgICB9LCBudWxsICE9IGEuZGF0YSkgYi5kYXRhID0gYS5kYXRhO2Vsc2UgaWYgKG51bGwgIT0gYS5jb250ZXh0KSBiLmRhdGEgPSB0aGlzLmdldENvbnRleHREYXRhKGEuY29udGV4dCk7ZWxzZSBpZiAobnVsbCAhPSBhLmltYWdlKSBiLmRhdGEgPSB0aGlzLmdldEltYWdlRGF0YShhLmltYWdlKTtlbHNlIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmcmFtZScpO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sIGE7XG4gICAgfShmKSwgZC5leHBvcnRzID0gZTtcbiAgfSksIGEuZGVmaW5lKCcvYnJvd3Nlci5jb2ZmZWUnLCBmdW5jdGlvbiAoZiwgZywgaCwgaSkge1xuICAgIHZhciBhLCBkLCBlLCBjLCBiO1xuICAgIGMgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksIGUgPSBuYXZpZ2F0b3IucGxhdGZvcm0udG9Mb3dlckNhc2UoKSwgYiA9IGMubWF0Y2goLyhvcGVyYXxpZXxmaXJlZm94fGNocm9tZXx2ZXJzaW9uKVtcXHNcXC86XShbXFx3XFxkXFwuXSspPy4qPyhzYWZhcml8dmVyc2lvbltcXHNcXC86XShbXFx3XFxkXFwuXSspfCQpLykgfHwgW251bGwsICd1bmtub3duJywgMF0sIGQgPSBiWzFdID09PSAnaWUnICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSwgYSA9IHtcbiAgICAgIG5hbWU6IGJbMV0gPT09ICd2ZXJzaW9uJyA/IGJbM10gOiBiWzFdLFxuICAgICAgdmVyc2lvbjogZCB8fCBwYXJzZUZsb2F0KGJbMV0gPT09ICdvcGVyYScgJiYgYls0XSA/IGJbNF0gOiBiWzJdKSxcbiAgICAgIHBsYXRmb3JtOiB7XG4gICAgICAgIG5hbWU6IGMubWF0Y2goL2lwKD86YWR8b2R8aG9uZSkvKSA/ICdpb3MnIDogKGMubWF0Y2goLyg/OndlYm9zfGFuZHJvaWQpLykgfHwgZS5tYXRjaCgvbWFjfHdpbnxsaW51eC8pIHx8IFsnb3RoZXInXSlbMF1cbiAgICAgIH1cbiAgICB9LCBhW2EubmFtZV0gPSAhMCwgYVthLm5hbWUgKyBwYXJzZUludChhLnZlcnNpb24sIDEwKV0gPSAhMCwgYS5wbGF0Zm9ybVthLnBsYXRmb3JtLm5hbWVdID0gITAsIGYuZXhwb3J0cyA9IGE7XG4gIH0pLCBhLmRlZmluZSgnZXZlbnRzJywgZnVuY3Rpb24gKGYsIGUsIGcsIGgpIHtcbiAgICBiLkV2ZW50RW1pdHRlciB8fCAoYi5FdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7fSk7XG4gICAgdmFyIGEgPSBlLkV2ZW50RW1pdHRlciA9IGIuRXZlbnRFbWl0dGVyLFxuICAgICAgICBjID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbicgPyBBcnJheS5pc0FycmF5IDogZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfSxcbiAgICAgICAgZCA9IDEwO1xuICAgIGEucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KSwgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IGE7XG4gICAgfSwgYS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICBpZiAoZiA9PT0gJ2Vycm9yJyAmJiAoISh0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzLmVycm9yKSB8fCBjKHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB0aHJvdyBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBFcnJvciA/IGFyZ3VtZW50c1sxXSA6IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gITE7XG4gICAgICB2YXIgYSA9IHRoaXMuX2V2ZW50c1tmXTtcbiAgICAgIGlmICghYSkgcmV0dXJuICExO1xuICAgICAgaWYgKCEodHlwZW9mIGEgPT0gJ2Z1bmN0aW9uJykpIGlmIChjKGEpKSB7XG4gICAgICAgIHZhciBiID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIGUgPSBhLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgZCA9IDAsIGcgPSBlLmxlbmd0aDsgZCA8IGc7IGQrKykgZVtkXS5hcHBseSh0aGlzLCBiKTtcblxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9IGVsc2UgcmV0dXJuICExO1xuXG4gICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGEuY2FsbCh0aGlzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGEuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YXIgYiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgYS5hcHBseSh0aGlzLCBiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIGEucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgYikgdGhyb3cgbmV3IEVycm9yKCdhZGRMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgICAgaWYgKHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pLCB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgYSwgYiksICF0aGlzLl9ldmVudHNbYV0pIHRoaXMuX2V2ZW50c1thXSA9IGI7ZWxzZSBpZiAoYyh0aGlzLl9ldmVudHNbYV0pKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzW2FdLndhcm5lZCkge1xuICAgICAgICAgIHZhciBlO1xuICAgICAgICAgIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCA/IGUgPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzIDogZSA9IGQsIGUgJiYgZSA+IDAgJiYgdGhpcy5fZXZlbnRzW2FdLmxlbmd0aCA+IGUgJiYgKHRoaXMuX2V2ZW50c1thXS53YXJuZWQgPSAhMCwgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLCB0aGlzLl9ldmVudHNbYV0ubGVuZ3RoKSwgY29uc29sZS50cmFjZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V2ZW50c1thXS5wdXNoKGIpO1xuICAgICAgfSBlbHNlIHRoaXMuX2V2ZW50c1thXSA9IFt0aGlzLl9ldmVudHNbYV0sIGJdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgYS5wcm90b3R5cGUub24gPSBhLnByb3RvdHlwZS5hZGRMaXN0ZW5lciwgYS5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICByZXR1cm4gYS5vbihiLCBmdW5jdGlvbiBkKCkge1xuICAgICAgICBhLnJlbW92ZUxpc3RlbmVyKGIsIGQpLCBjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KSwgdGhpcztcbiAgICB9LCBhLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChhLCBkKSB7XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGQpIHRocm93IG5ldyBFcnJvcigncmVtb3ZlTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgICAgIGlmICghKHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbYV0pKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBiID0gdGhpcy5fZXZlbnRzW2FdO1xuXG4gICAgICBpZiAoYyhiKSkge1xuICAgICAgICB2YXIgZSA9IGIuaW5kZXhPZihkKTtcbiAgICAgICAgaWYgKGUgPCAwKSByZXR1cm4gdGhpcztcbiAgICAgICAgYi5zcGxpY2UoZSwgMSksIGIubGVuZ3RoID09IDAgJiYgZGVsZXRlIHRoaXMuX2V2ZW50c1thXTtcbiAgICAgIH0gZWxzZSB0aGlzLl9ldmVudHNbYV0gPT09IGQgJiYgZGVsZXRlIHRoaXMuX2V2ZW50c1thXTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgYS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBhICYmIHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbYV0gJiYgKHRoaXMuX2V2ZW50c1thXSA9IG51bGwpLCB0aGlzO1xuICAgIH0sIGEucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSksIHRoaXMuX2V2ZW50c1thXSB8fCAodGhpcy5fZXZlbnRzW2FdID0gW10pLCBjKHRoaXMuX2V2ZW50c1thXSkgfHwgKHRoaXMuX2V2ZW50c1thXSA9IFt0aGlzLl9ldmVudHNbYV1dKSwgdGhpcy5fZXZlbnRzW2FdO1xuICAgIH07XG4gIH0pLCBjLkdJRiA9IGEoJy9naWYuY29mZmVlJyk7XG59KS5jYWxsKGNvbW1vbmpzR2xvYmFsLCBjb21tb25qc0dsb2JhbCk7IC8vIGdpZi5qcyAwLjEuNiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9qbm9yZGJlcmcvZ2lmLmpzXG5cbnZhciB3ZWJtV3JpdGVyMF8yXzAgPSB7ZXhwb3J0czoge319O1xuXG4vKipcbiAqIEEgdG9vbCBmb3IgcHJlc2VudGluZyBhbiBBcnJheUJ1ZmZlciBhcyBhIHN0cmVhbSBmb3Igd3JpdGluZyBzb21lIHNpbXBsZSBkYXRhIHR5cGVzLlxuICpcbiAqIEJ5IE5pY2hvbGFzIFNoZXJsb2NrXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIFdURlBMdjIgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV1RGUExcbiAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlzTm9kZUVudmlyb21lbnQgPSAnb2JqZWN0JyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGlzTm9kZUVudmlyb21lbnQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gQXJyYXlCdWZmZXIgb2YgdGhlIGdpdmVuIGxlbmd0aCBhbmQgcHJlc2VudCBpdCBhcyBhIHdyaXRhYmxlIHN0cmVhbSB3aXRoIG1ldGhvZHNcbiAgICAgKiBmb3Igd3JpdGluZyBkYXRhIGluIGRpZmZlcmVudCBmb3JtYXRzLlxuICAgICAqL1xuXG4gICAgdmFyIEFycmF5QnVmZmVyRGF0YVN0cmVhbSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfTtcblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIHRoaXMucG9zID0gb2Zmc2V0O1xuICAgIH07XG5cbiAgICBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlQnl0ZXMgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPSBhcnJbaV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IGI7XG4gICAgfTsgLy9TeW5vbnltOlxuXG5cbiAgICBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlVTggPSBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlQnl0ZTtcblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVVMTZCRSA9IGZ1bmN0aW9uICh1KSB7XG4gICAgICB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPSB1ID4+IDg7XG4gICAgICB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPSB1O1xuICAgIH07XG5cbiAgICBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobmV3IEZsb2F0NjRBcnJheShbZF0pLmJ1ZmZlcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSBieXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndyaXRlQnl0ZShieXRlc1tpXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KG5ldyBGbG9hdDMyQXJyYXkoW2RdKS5idWZmZXIpO1xuXG4gICAgICBmb3IgKHZhciBpID0gYnl0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53cml0ZUJ5dGUoYnl0ZXNbaV0pO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JpdGUgYW4gQVNDSUkgc3RyaW5nIHRvIHRoZSBzdHJlYW1cbiAgICAgKi9cblxuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZVN0cmluZyA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5kYXRhW3RoaXMucG9zKytdID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JpdGUgdGhlIGdpdmVuIDMyLWJpdCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0gYXMgYW4gRUJNTCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciB1c2luZyB0aGUgZ2l2ZW4gYnl0ZSB3aWR0aFxuICAgICAqICh1c2UgbWVhc3VyZUVCTUxWYXJJbnQpLlxuICAgICAqXG4gICAgICogTm8gZXJyb3IgY2hlY2tpbmcgaXMgcGVyZm9ybWVkIHRvIGVuc3VyZSB0aGF0IHRoZSBzdXBwbGllZCB3aWR0aCBpcyBjb3JyZWN0IGZvciB0aGUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpIEludGVnZXIgdG8gYmUgd3JpdHRlblxuICAgICAqIEBwYXJhbSB3aWR0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUgdG8gdGhlIHN0cmVhbVxuICAgICAqL1xuXG5cbiAgICBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlRUJNTFZhckludFdpZHRoID0gZnVuY3Rpb24gKGksIHdpZHRoKSB7XG4gICAgICBzd2l0Y2ggKHdpZHRoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMSA8PCA3IHwgaSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRoaXMud3JpdGVVOCgxIDw8IDYgfCBpID4+IDgpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDEgPDwgNSB8IGkgPj4gMTYpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChpID4+IDgpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDEgPDwgNCB8IGkgPj4gMjQpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChpID4+IDE2KTtcbiAgICAgICAgICB0aGlzLndyaXRlVTgoaSA+PiA4KTtcbiAgICAgICAgICB0aGlzLndyaXRlVTgoaSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIC8qXG4gICAgICAgICAgICogSmF2YVNjcmlwdCBjb252ZXJ0cyBpdHMgZG91YmxlcyB0byAzMi1iaXQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucywgc28gd2UgbmVlZCB0byBkbyBhXG4gICAgICAgICAgICogZGl2aXNpb24gYnkgMl4zMiBpbnN0ZWFkIG9mIGEgcmlnaHQtc2hpZnQgb2YgMzIgdG8gcmV0YWluIHRob3NlIHRvcCAzIGJpdHNcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLndyaXRlVTgoMSA8PCAzIHwgaSAvIDQyOTQ5NjcyOTYgJiAweDcpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChpID4+IDI0KTtcbiAgICAgICAgICB0aGlzLndyaXRlVTgoaSA+PiAxNik7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkgPj4gOCk7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oJ0JhZCBFQk1MIFZJTlQgc2l6ZSAnICsgd2lkdGgpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvIGVuY29kZSB0aGUgZ2l2ZW4gaW50ZWdlciBhcyBhbiBFQk1MIFZJTlQuXG4gICAgICovXG5cblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUubWVhc3VyZUVCTUxWYXJJbnQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBpZiAodmFsIDwgKDEgPDwgNykgLSAxKSB7XG4gICAgICAgIC8qIFRvcCBiaXQgaXMgc2V0LCBsZWF2aW5nIDcgYml0cyB0byBob2xkIHRoZSBpbnRlZ2VyLCBidXQgd2UgY2FuJ3Qgc3RvcmUgMTI3IGJlY2F1c2VcbiAgICAgICAgICogXCJhbGwgYml0cyBzZXQgdG8gb25lXCIgaXMgYSByZXNlcnZlZCB2YWx1ZS4gU2FtZSB0aGluZyBmb3IgdGhlIG90aGVyIGNhc2VzIGJlbG93OlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA8ICgxIDw8IDE0KSAtIDEpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA8ICgxIDw8IDIxKSAtIDEpIHtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA8ICgxIDw8IDI4KSAtIDEpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA8IDM0MzU5NzM4MzY3KSB7XG4gICAgICAgIC8vIDIgXiAzNSAtIDEgKGNhbiBhZGRyZXNzIDMyR0IpXG4gICAgICAgIHJldHVybiA1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oJ0VCTUwgVklOVCBzaXplIG5vdCBzdXBwb3J0ZWQgJyArIHZhbCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVFQk1MVmFySW50ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHRoaXMud3JpdGVFQk1MVmFySW50V2lkdGgoaSwgdGhpcy5tZWFzdXJlRUJNTFZhckludChpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgZ2l2ZW4gdW5zaWduZWQgMzItYml0IGludGVnZXIgdG8gdGhlIHN0cmVhbSBpbiBiaWctZW5kaWFuIG9yZGVyIHVzaW5nIHRoZSBnaXZlbiBieXRlIHdpZHRoLlxuICAgICAqIE5vIGVycm9yIGNoZWNraW5nIGlzIHBlcmZvcm1lZCB0byBlbnN1cmUgdGhhdCB0aGUgc3VwcGxpZWQgd2lkdGggaXMgY29ycmVjdCBmb3IgdGhlIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBPbWl0IHRoZSB3aWR0aCBwYXJhbWV0ZXIgdG8gaGF2ZSBpdCBkZXRlcm1pbmVkIGF1dG9tYXRpY2FsbHkgZm9yIHlvdS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1IFVuc2lnbmVkIGludGVnZXIgdG8gYmUgd3JpdHRlblxuICAgICAqIEBwYXJhbSB3aWR0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUgdG8gdGhlIHN0cmVhbVxuICAgICAqL1xuXG5cbiAgICBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlVW5zaWduZWRJbnRCRSA9IGZ1bmN0aW9uICh1LCB3aWR0aCkge1xuICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLm1lYXN1cmVVbnNpZ25lZEludCh1KTtcbiAgICAgIH0gLy8gRWFjaCBjYXNlIGZhbGxzIHRocm91Z2g6XG5cblxuICAgICAgc3dpdGNoICh3aWR0aCkge1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgdGhpcy53cml0ZVU4KE1hdGguZmxvb3IodSAvIDQyOTQ5NjcyOTYpKTtcbiAgICAgICAgLy8gTmVlZCB0byB1c2UgZGl2aXNpb24gdG8gYWNjZXNzID4zMiBiaXRzIG9mIGZsb2F0aW5nIHBvaW50IHZhclxuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0aGlzLndyaXRlVTgodSA+PiAyNCk7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRoaXMud3JpdGVVOCh1ID4+IDE2KTtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhpcy53cml0ZVU4KHUgPj4gOCk7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMud3JpdGVVOCh1KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXhjZXB0aW9uKCdCYWQgVUlOVCBzaXplICcgKyB3aWR0aCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyBuZWVkZWQgdG8gaG9sZCB0aGUgbm9uLXplcm8gYml0cyBvZiB0aGUgZ2l2ZW4gdW5zaWduZWQgaW50ZWdlci5cbiAgICAgKi9cblxuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS5tZWFzdXJlVW5zaWduZWRJbnQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAvLyBGb3JjZSB0byAzMi1iaXQgdW5zaWduZWQgaW50ZWdlclxuICAgICAgaWYgKHZhbCA8IDEgPDwgOCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgMSA8PCAxNikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgMSA8PCAyNCkge1xuICAgICAgICByZXR1cm4gMztcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICByZXR1cm4gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiA1O1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdmlldyBvbiB0aGUgcG9ydGlvbiBvZiB0aGUgYnVmZmVyIGZyb20gdGhlIGJlZ2lubmluZyB0byB0aGUgY3VycmVudCBzZWVrIHBvc2l0aW9uIGFzIGEgVWludDhBcnJheS5cbiAgICAgKi9cblxuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS5nZXRBc0RhdGFBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc3ViYXJyYXkoMCwgdGhpcy5wb3MpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBvcyA9PSB0aGlzLmRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJBcnJheUJ1ZmZlckRhdGFTdHJlYW0ncyBwb3MgbGllcyBiZXlvbmQgZW5kIG9mIGJ1ZmZlclwiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuQXJyYXlCdWZmZXJEYXRhU3RyZWFtID0gQXJyYXlCdWZmZXJEYXRhU3RyZWFtO1xuICAgIC8qKlxuICAgICAqIEFsbG93cyBhIHNlcmllcyBvZiBCbG9iLWNvbnZlcnRpYmxlIG9iamVjdHMgKEFycmF5QnVmZmVyLCBCbG9iLCBTdHJpbmcsIGV0YykgdG8gYmUgYWRkZWQgdG8gYSBidWZmZXIuIFNlZWtpbmcgYW5kXG4gICAgICogb3ZlcndyaXRpbmcgb2YgYmxvYnMgaXMgYWxsb3dlZC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gc3VwcGx5IGEgRmlsZVdyaXRlciwgaW4gd2hpY2ggY2FzZSB0aGUgQmxvYkJ1ZmZlciBpcyBqdXN0IHVzZWQgYXMgdGVtcG9yYXJ5IHN0b3JhZ2UgYmVmb3JlIGl0IHdyaXRlcyBpdFxuICAgICAqIHRocm91Z2ggdG8gdGhlIGRpc2suXG4gICAgICpcbiAgICAgKiBCeSBOaWNob2xhcyBTaGVybG9ja1xuICAgICAqXG4gICAgICogUmVsZWFzZWQgdW5kZXIgdGhlIFdURlBMdjIgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV1RGUExcbiAgICAgKi9cblxuICAgIHZhciBCbG9iQnVmZmVyID0gZnVuY3Rpb24gKGZzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBbXSxcbiAgICAgICAgICAgIHdyaXRlUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAgICAgZmlsZVdyaXRlciA9IG51bGwsXG4gICAgICAgICAgICBmZCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBGaWxlV3JpdGVyICE9PSAndW5kZWZpbmVkJyAmJiBkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIEZpbGVXcml0ZXIpIHtcbiAgICAgICAgICBmaWxlV3JpdGVyID0gZGVzdGluYXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoZnMgJiYgZGVzdGluYXRpb24pIHtcbiAgICAgICAgICBmZCA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB9IC8vIEN1cnJlbnQgc2VlayBvZmZzZXRcblxuXG4gICAgICAgIHRoaXMucG9zID0gMDsgLy8gT25lIG1vcmUgdGhhbiB0aGUgaW5kZXggb2YgdGhlIGhpZ2hlc3QgYnl0ZSBldmVyIHdyaXR0ZW5cblxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7IC8vIFJldHVybnMgYSBwcm9taXNlIHRoYXQgY29udmVydHMgdGhlIGJsb2IgdG8gYW4gQXJyYXlCdWZmZXJcblxuICAgICAgICBmdW5jdGlvbiByZWFkQmxvYkFzQnVmZmVyKGJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29udmVydFRvVWludDhBcnJheSh0aGluZykge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh0aGluZykpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheSh0aGluZykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGluZyBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZWFkQmxvYkFzQnVmZmVyKHRoaW5nKS50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy9Bc3N1bWUgdGhhdCBCbG9iIHdpbGwga25vdyBob3cgdG8gcmVhZCB0aGlzIHRoaW5nXG4gICAgICAgICAgICAgIHJlc29sdmUocmVhZEJsb2JBc0J1ZmZlcihuZXcgQmxvYihbdGhpbmddKSkudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lYXN1cmVEYXRhKGRhdGEpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YS5ieXRlTGVuZ3RoIHx8IGRhdGEubGVuZ3RoIHx8IGRhdGEuc2l6ZTtcblxuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyAnRmFpbGVkIHRvIGRldGVybWluZSBzaXplIG9mIGVsZW1lbnQnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZWsgdG8gdGhlIGdpdmVuIGFic29sdXRlIG9mZnNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogWW91IG1heSBub3Qgc2VlayBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgZmlsZSAodGhpcyB3b3VsZCBjcmVhdGUgYSBob2xlIGFuZC9vciBhbGxvdyBibG9ja3MgdG8gYmUgd3JpdHRlbiBpbiBub24tXG4gICAgICAgICAqIHNlcXVlbnRpYWwgb3JkZXIsIHdoaWNoIGlzbid0IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIG1lbW9yeSBidWZmZXIgYmFja2VuZCkuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgdGhpcy5zZWVrID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyAnT2Zmc2V0IG1heSBub3QgYmUgbmVnYXRpdmUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyAnT2Zmc2V0IG1heSBub3QgYmUgTmFOJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93ICdTZWVraW5nIGJleW9uZCB0aGUgZW5kIG9mIGZpbGUgaXMgbm90IGFsbG93ZWQnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucG9zID0gb2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGUgdGhlIEJsb2ItY29udmVydGlibGUgZGF0YSB0byB0aGUgYnVmZmVyIGF0IHRoZSBjdXJyZW50IHNlZWsgcG9zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IElmIG92ZXJ3cml0aW5nIGV4aXN0aW5nIGRhdGEsIHRoZSB3cml0ZSBtdXN0IG5vdCBjcm9zcyBwcmVleGlzdGluZyBibG9jayBib3VuZGFyaWVzICh3cml0dGVuIGRhdGEgbXVzdFxuICAgICAgICAgKiBiZSBmdWxseSBjb250YWluZWQgYnkgdGhlIGV4dGVudCBvZiBhIHByZXZpb3VzIHdyaXRlKS5cbiAgICAgICAgICovXG5cblxuICAgICAgICB0aGlzLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICB2YXIgbmV3RW50cnkgPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMucG9zLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGxlbmd0aDogbWVhc3VyZURhdGEoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpc0FwcGVuZCA9IG5ld0VudHJ5Lm9mZnNldCA+PSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLnBvcyArPSBuZXdFbnRyeS5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgdGhpcy5wb3MpOyAvLyBBZnRlciBwcmV2aW91cyB3cml0ZXMgY29tcGxldGUsIHBlcmZvcm0gb3VyIHdyaXRlXG5cbiAgICAgICAgICB3cml0ZVByb21pc2UgPSB3cml0ZVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0VG9VaW50OEFycmF5KG5ld0VudHJ5LmRhdGEpLnRoZW4oZnVuY3Rpb24gKGRhdGFBcnJheSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsV3JpdHRlbiA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YUFycmF5LmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlV3JpdGVDb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIsIHdyaXR0ZW4sIGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbFdyaXR0ZW4gKz0gd3JpdHRlbjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxXcml0dGVuID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc3RpbGwgaGF2ZSBtb3JlIHRvIHdyaXRlLi4uXG4gICAgICAgICAgICAgICAgICAgICAgZnMud3JpdGUoZmQsIGJ1ZmZlciwgdG90YWxXcml0dGVuLCBidWZmZXIubGVuZ3RoIC0gdG90YWxXcml0dGVuLCBuZXdFbnRyeS5vZmZzZXQgKyB0b3RhbFdyaXR0ZW4sIGhhbmRsZVdyaXRlQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICBmcy53cml0ZShmZCwgYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoLCBuZXdFbnRyeS5vZmZzZXQsIGhhbmRsZVdyaXRlQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZVdyaXRlcikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGZpbGVXcml0ZXIub253cml0ZWVuZCA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgZmlsZVdyaXRlci5zZWVrKG5ld0VudHJ5Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZmlsZVdyaXRlci53cml0ZShuZXcgQmxvYihbbmV3RW50cnkuZGF0YV0pKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0FwcGVuZCkge1xuICAgICAgICAgICAgICAvLyBXZSBtaWdodCBiZSBtb2RpZnlpbmcgYSB3cml0ZSB0aGF0IHdhcyBhbHJlYWR5IGJ1ZmZlcmVkIGluIG1lbW9yeS5cbiAgICAgICAgICAgICAgLy8gU2xvdyBsaW5lYXIgc2VhcmNoIHRvIGZpbmQgYSBibG9jayB3ZSBtaWdodCBiZSBvdmVyd3JpdGluZ1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGJ1ZmZlcltpXTsgLy8gSWYgb3VyIG5ldyBlbnRyeSBvdmVybGFwcyB0aGUgb2xkIG9uZSBpbiBhbnkgd2F5Li4uXG5cbiAgICAgICAgICAgICAgICBpZiAoIShuZXdFbnRyeS5vZmZzZXQgKyBuZXdFbnRyeS5sZW5ndGggPD0gZW50cnkub2Zmc2V0IHx8IG5ld0VudHJ5Lm9mZnNldCA+PSBlbnRyeS5vZmZzZXQgKyBlbnRyeS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobmV3RW50cnkub2Zmc2V0IDwgZW50cnkub2Zmc2V0IHx8IG5ld0VudHJ5Lm9mZnNldCArIG5ld0VudHJ5Lmxlbmd0aCA+IGVudHJ5Lm9mZnNldCArIGVudHJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJ3cml0ZSBjcm9zc2VzIGJsb2IgYm91bmRhcmllcycpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAobmV3RW50cnkub2Zmc2V0ID09IGVudHJ5Lm9mZnNldCAmJiBuZXdFbnRyeS5sZW5ndGggPT0gZW50cnkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG92ZXJ3cm90ZSB0aGUgZW50aXJlIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmRhdGEgPSBuZXdFbnRyeS5kYXRhOyAvLyBXZSdyZSBkb25lXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1VpbnQ4QXJyYXkoZW50cnkuZGF0YSkudGhlbihmdW5jdGlvbiAoZW50cnlBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmRhdGEgPSBlbnRyeUFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9VaW50OEFycmF5KG5ld0VudHJ5LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChuZXdFbnRyeUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV3RW50cnkuZGF0YSA9IG5ld0VudHJ5QXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgZW50cnkuZGF0YS5zZXQobmV3RW50cnkuZGF0YSwgbmV3RW50cnkub2Zmc2V0IC0gZW50cnkub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IC8vIEVsc2UgZmFsbCB0aHJvdWdoIHRvIGRvIGEgc2ltcGxlIGFwcGVuZCwgYXMgd2UgZGlkbid0IG92ZXJ3cml0ZSBhbnkgcHJlLWV4aXN0aW5nIGJsb2Nrc1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5ld0VudHJ5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmlzaCBhbGwgd3JpdGVzIHRvIHRoZSBidWZmZXIsIHJldHVybmluZyBhIHByb21pc2UgdGhhdCBzaWduYWxzIHdoZW4gdGhhdCBpcyBjb21wbGV0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBGaWxlV3JpdGVyIHdhcyBub3QgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggYSBCbG9iIHRoYXQgcmVwcmVzZW50cyB0aGUgY29tcGxldGVkIEJsb2JCdWZmZXJcbiAgICAgICAgICogY29udGVudHMuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGluIGEgbWltZVR5cGUgdG8gYmUgdXNlZCBmb3IgdGhpcyBibG9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIEZpbGVXcml0ZXIgd2FzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIG51bGwgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIHRoaXMuY29tcGxldGUgPSBmdW5jdGlvbiAobWltZVR5cGUpIHtcbiAgICAgICAgICBpZiAoZmQgfHwgZmlsZVdyaXRlcikge1xuICAgICAgICAgICAgd3JpdGVQcm9taXNlID0gd3JpdGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBZnRlciB3cml0ZXMgY29tcGxldGUgd2UgbmVlZCB0byBtZXJnZSB0aGUgYnVmZmVyIHRvIGdpdmUgdG8gdGhlIGNhbGxlclxuICAgICAgICAgICAgd3JpdGVQcm9taXNlID0gd3JpdGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChidWZmZXJbaV0uZGF0YSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2IocmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHdyaXRlUHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfShpc05vZGVFbnZpcm9tZW50ID8gbnVsbCA6IG51bGwpO1xuXG4gICAgd2luZG93LkJsb2JCdWZmZXIgPSBCbG9iQnVmZmVyO1xuICAgIC8qKlxuICAgICAqIFdlYk0gdmlkZW8gZW5jb2RlciBmb3IgR29vZ2xlIENocm9tZS4gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBzdWl0YWJsZSBmb3IgY3JlYXRpbmcgdmVyeSBsYXJnZSB2aWRlbyBmaWxlcywgYmVjYXVzZVxuICAgICAqIGl0IGNhbiBzdHJlYW0gQmxvYnMgZGlyZWN0bHkgdG8gYSBGaWxlV3JpdGVyIHdpdGhvdXQgYnVmZmVyaW5nIHRoZSBlbnRpcmUgdmlkZW8gaW4gbWVtb3J5LlxuICAgICAqXG4gICAgICogV2hlbiBGaWxlV3JpdGVyIGlzIG5vdCBhdmFpbGFibGUgb3Igbm90IGRlc2lyZWQsIGl0IGNhbiBidWZmZXIgdGhlIHZpZGVvIGluIG1lbW9yeSBhcyBhIHNlcmllcyBvZiBCbG9icyB3aGljaCBhcmVcbiAgICAgKiBldmVudHVhbGx5IHJldHVybmVkIGFzIG9uZSBjb21wb3NpdGUgQmxvYi5cbiAgICAgKlxuICAgICAqIEJ5IE5pY2hvbGFzIFNoZXJsb2NrLlxuICAgICAqXG4gICAgICogQmFzZWQgb24gdGhlIGlkZWFzIGZyb20gV2hhbW15OiBodHRwczovL2dpdGh1Yi5jb20vYW50aW1hdHRlcjE1L3doYW1teVxuICAgICAqXG4gICAgICogUmVsZWFzZWQgdW5kZXIgdGhlIFdURlBMdjIgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV1RGUExcbiAgICAgKi9cblxuICAgIHZhciBXZWJNV3JpdGVyID0gZnVuY3Rpb24gKEFycmF5QnVmZmVyRGF0YVN0cmVhbSwgQmxvYkJ1ZmZlcikge1xuICAgICAgZnVuY3Rpb24gZXh0ZW5kKGJhc2UsIHRvcCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgICAgIFtiYXNlLCB0b3BdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIERlY29kZSBhIEJhc2U2NCBkYXRhIFVSTCBpbnRvIGEgYmluYXJ5IHN0cmluZy5cbiAgICAgICAqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBiaW5hcnkgc3RyaW5nLCBvciBmYWxzZSBpZiB0aGUgVVJMIGNvdWxkIG5vdCBiZSBkZWNvZGVkLlxuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gZGVjb2RlQmFzZTY0V2ViUERhdGFVUkwodXJsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJyB8fCAhdXJsLm1hdGNoKC9eZGF0YTppbWFnZVxcL3dlYnA7YmFzZTY0LC9pKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3aW5kb3cuYXRvYih1cmwuc3Vic3RyaW5nKCdkYXRhOmltYWdlL3dlYnA7YmFzZTY0LCcubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnQgdGhlIGdpdmVuIGNhbnZhcyB0byBhIFdlYlAgZW5jb2RlZCBpbWFnZSBhbmQgcmV0dXJuIHRoZSBpbWFnZSBkYXRhIGFzIGEgc3RyaW5nLlxuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gcmVuZGVyQXNXZWJQKGNhbnZhcywgcXVhbGl0eSkge1xuICAgICAgICB2YXIgZnJhbWUgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS93ZWJwJywge1xuICAgICAgICAgIHF1YWxpdHk6IHF1YWxpdHlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWNvZGVCYXNlNjRXZWJQRGF0YVVSTChmcmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXlmcmFtZUZyb21XZWJQKHdlYlApIHtcbiAgICAgICAgLy8gQXNzdW1lIHRoYXQgQ2hyb21lIHdpbGwgZ2VuZXJhdGUgYSBTaW1wbGUgTG9zc3kgV2ViUCB3aGljaCBoYXMgdGhpcyBoZWFkZXI6XG4gICAgICAgIHZhciBrZXlmcmFtZVN0YXJ0SW5kZXggPSB3ZWJQLmluZGV4T2YoJ1ZQOCAnKTtcblxuICAgICAgICBpZiAoa2V5ZnJhbWVTdGFydEluZGV4ID09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgJ0ZhaWxlZCB0byBpZGVudGlmeSBiZWdpbm5pbmcgb2Yga2V5ZnJhbWUgaW4gV2ViUCBpbWFnZSc7XG4gICAgICAgIH0gLy8gU2tpcCB0aGUgaGVhZGVyIGFuZCB0aGUgNCBieXRlcyB0aGF0IGVuY29kZSB0aGUgbGVuZ3RoIG9mIHRoZSBWUDggY2h1bmtcblxuXG4gICAgICAgIGtleWZyYW1lU3RhcnRJbmRleCArPSAnVlA4ICcubGVuZ3RoICsgNDtcbiAgICAgICAgcmV0dXJuIHdlYlAuc3Vic3RyaW5nKGtleWZyYW1lU3RhcnRJbmRleCk7XG4gICAgICB9IC8vIEp1c3QgYSBsaXR0bGUgdXRpbGl0eSBzbyB3ZSBjYW4gdGFnIHZhbHVlcyBhcyBmbG9hdHMgZm9yIHRoZSBFQk1MIGVuY29kZXIncyBiZW5lZml0XG5cblxuICAgICAgZnVuY3Rpb24gRUJNTEZsb2F0MzIodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBFQk1MRmxvYXQ2NCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIHRoZSBnaXZlbiBFQk1MIG9iamVjdCB0byB0aGUgcHJvdmlkZWQgQXJyYXlCdWZmZXJTdHJlYW0uXG4gICAgICAgKlxuICAgICAgICogVGhlIGJ1ZmZlcidzIGZpcnN0IGJ5dGUgaXMgYXQgYnVmZmVyRmlsZU9mZnNldCBpbnNpZGUgdGhlIHZpZGVvIGZpbGUuIFRoaXMgaXMgdXNlZCB0byBjb21wbGV0ZSBvZmZzZXQgYW5kXG4gICAgICAgKiBkYXRhT2Zmc2V0IGZpZWxkcyBpbiBlYWNoIEVCTUwgc3RydWN0dXJlLCBpbmRpY2F0aW5nIHRoZSBmaWxlIG9mZnNldCBvZiB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgRUJNTCBlbGVtZW50IGFuZFxuICAgICAgICogaXRzIGRhdGEgcGF5bG9hZC5cbiAgICAgICAqL1xuXG5cbiAgICAgIGZ1bmN0aW9uIHdyaXRlRUJNTChidWZmZXIsIGJ1ZmZlckZpbGVPZmZzZXQsIGVibWwpIHtcbiAgICAgICAgLy8gSXMgdGhlIGVibWwgYW4gYXJyYXkgb2Ygc2libGluZyBlbGVtZW50cz9cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWJtbCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVibWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlRUJNTChidWZmZXIsIGJ1ZmZlckZpbGVPZmZzZXQsIGVibWxbaV0pO1xuICAgICAgICAgIH0gLy8gSXMgdGhpcyBzb21lIHNvcnQgb2YgcmF3IGRhdGEgdGhhdCB3ZSB3YW50IHRvIHdyaXRlIGRpcmVjdGx5P1xuXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVibWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgYnVmZmVyLndyaXRlU3RyaW5nKGVibWwpO1xuICAgICAgICB9IGVsc2UgaWYgKGVibWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgYnVmZmVyLndyaXRlQnl0ZXMoZWJtbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWJtbC5pZCkge1xuICAgICAgICAgIC8vIFdlJ3JlIHdyaXRpbmcgYW4gRUJNTCBlbGVtZW50XG4gICAgICAgICAgZWJtbC5vZmZzZXQgPSBidWZmZXIucG9zICsgYnVmZmVyRmlsZU9mZnNldDtcbiAgICAgICAgICBidWZmZXIud3JpdGVVbnNpZ25lZEludEJFKGVibWwuaWQpOyAvLyBJRCBmaWVsZFxuICAgICAgICAgIC8vIE5vdyB3ZSBuZWVkIHRvIHdyaXRlIHRoZSBzaXplIGZpZWxkLCBzbyB3ZSBtdXN0IGtub3cgdGhlIHBheWxvYWQgc2l6ZTpcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVibWwuZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIFdyaXRpbmcgYW4gYXJyYXkgb2YgY2hpbGQgZWxlbWVudHMuIFdlIHdvbid0IHRyeSB0byBtZWFzdXJlIHRoZSBzaXplIG9mIHRoZSBjaGlsZHJlbiB1cC1mcm9udFxuICAgICAgICAgICAgdmFyIHNpemVQb3MsIGRhdGFCZWdpbiwgZGF0YUVuZDtcblxuICAgICAgICAgICAgaWYgKGVibWwuc2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgLy8gV3JpdGUgdGhlIHJlc2VydmVkIGFsbC1vbmUtYml0cyBtYXJrZXIgdG8gbm90ZSB0aGF0IHRoZSBzaXplIG9mIHRoaXMgZWxlbWVudCBpcyB1bmtub3duL3VuYm91bmRlZFxuICAgICAgICAgICAgICBidWZmZXIud3JpdGVCeXRlKDB4ZmYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2l6ZVBvcyA9IGJ1ZmZlci5wb3M7XG4gICAgICAgICAgICAgIC8qIFdyaXRlIGEgZHVtbXkgc2l6ZSBmaWVsZCB0byBvdmVyd3JpdGUgbGF0ZXIuIDQgYnl0ZXMgYWxsb3dzIGFuIGVsZW1lbnQgbWF4aW11bSBzaXplIG9mIDI1Nk1CLFxuICAgICAgICAgICAgICAgKiB3aGljaCBzaG91bGQgYmUgcGxlbnR5ICh3ZSBkb24ndCB3YW50IHRvIGhhdmUgdG8gYnVmZmVyIHRoYXQgbXVjaCBkYXRhIGluIG1lbW9yeSBhdCBvbmUgdGltZVxuICAgICAgICAgICAgICAgKiBhbnl3YXkhKVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICBidWZmZXIud3JpdGVCeXRlcyhbMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhQmVnaW4gPSBidWZmZXIucG9zO1xuICAgICAgICAgICAgZWJtbC5kYXRhT2Zmc2V0ID0gZGF0YUJlZ2luICsgYnVmZmVyRmlsZU9mZnNldDtcbiAgICAgICAgICAgIHdyaXRlRUJNTChidWZmZXIsIGJ1ZmZlckZpbGVPZmZzZXQsIGVibWwuZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChlYm1sLnNpemUgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGRhdGFFbmQgPSBidWZmZXIucG9zO1xuICAgICAgICAgICAgICBlYm1sLnNpemUgPSBkYXRhRW5kIC0gZGF0YUJlZ2luO1xuICAgICAgICAgICAgICBidWZmZXIuc2VlayhzaXplUG9zKTtcbiAgICAgICAgICAgICAgYnVmZmVyLndyaXRlRUJNTFZhckludFdpZHRoKGVibWwuc2l6ZSwgNCk7IC8vIFNpemUgZmllbGRcblxuICAgICAgICAgICAgICBidWZmZXIuc2VlayhkYXRhRW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlYm1sLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVFQk1MVmFySW50KGVibWwuZGF0YS5sZW5ndGgpOyAvLyBTaXplIGZpZWxkXG5cbiAgICAgICAgICAgIGVibWwuZGF0YU9mZnNldCA9IGJ1ZmZlci5wb3MgKyBidWZmZXJGaWxlT2Zmc2V0O1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlU3RyaW5nKGVibWwuZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZWJtbC5kYXRhID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIGNhbGxlciB0byBleHBsaWNpdGx5IGNob29zZSB0aGUgc2l6ZSBpZiB0aGV5IHdpc2ggYnkgc3VwcGx5aW5nIGEgc2l6ZSBmaWVsZFxuICAgICAgICAgICAgaWYgKCFlYm1sLnNpemUpIHtcbiAgICAgICAgICAgICAgZWJtbC5zaXplID0gYnVmZmVyLm1lYXN1cmVVbnNpZ25lZEludChlYm1sLmRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWZmZXIud3JpdGVFQk1MVmFySW50KGVibWwuc2l6ZSk7IC8vIFNpemUgZmllbGRcblxuICAgICAgICAgICAgZWJtbC5kYXRhT2Zmc2V0ID0gYnVmZmVyLnBvcyArIGJ1ZmZlckZpbGVPZmZzZXQ7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVVbnNpZ25lZEludEJFKGVibWwuZGF0YSwgZWJtbC5zaXplKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVibWwuZGF0YSBpbnN0YW5jZW9mIEVCTUxGbG9hdDY0KSB7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVFQk1MVmFySW50KDgpOyAvLyBTaXplIGZpZWxkXG5cbiAgICAgICAgICAgIGVibWwuZGF0YU9mZnNldCA9IGJ1ZmZlci5wb3MgKyBidWZmZXJGaWxlT2Zmc2V0O1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlRG91YmxlQkUoZWJtbC5kYXRhLnZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVibWwuZGF0YSBpbnN0YW5jZW9mIEVCTUxGbG9hdDMyKSB7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVFQk1MVmFySW50KDQpOyAvLyBTaXplIGZpZWxkXG5cbiAgICAgICAgICAgIGVibWwuZGF0YU9mZnNldCA9IGJ1ZmZlci5wb3MgKyBidWZmZXJGaWxlT2Zmc2V0O1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXRCRShlYm1sLmRhdGEudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWJtbC5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlRUJNTFZhckludChlYm1sLmRhdGEuYnl0ZUxlbmd0aCk7IC8vIFNpemUgZmllbGRcblxuICAgICAgICAgICAgZWJtbC5kYXRhT2Zmc2V0ID0gYnVmZmVyLnBvcyArIGJ1ZmZlckZpbGVPZmZzZXQ7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVCeXRlcyhlYm1sLmRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnQmFkIEVCTUwgZGF0YXR5cGUgJyArIHR5cGVvZiBlYm1sLmRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93ICdCYWQgRUJNTCBkYXRhdHlwZSAnICsgdHlwZW9mIGVibWwuZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIE1BWF9DTFVTVEVSX0RVUkFUSU9OX01TRUMgPSA1MDAwLFxuICAgICAgICAgICAgREVGQVVMVF9UUkFDS19OVU1CRVIgPSAxLFxuICAgICAgICAgICAgd3JpdHRlbkhlYWRlciA9IGZhbHNlLFxuICAgICAgICAgICAgdmlkZW9XaWR0aCxcbiAgICAgICAgICAgIHZpZGVvSGVpZ2h0LFxuICAgICAgICAgICAgY2x1c3RlckZyYW1lQnVmZmVyID0gW10sXG4gICAgICAgICAgICBjbHVzdGVyU3RhcnRUaW1lID0gMCxcbiAgICAgICAgICAgIGNsdXN0ZXJEdXJhdGlvbiA9IDAsXG4gICAgICAgICAgICBvcHRpb25EZWZhdWx0cyA9IHtcbiAgICAgICAgICBxdWFsaXR5OiAwLjk1LFxuICAgICAgICAgIC8vIFdlYk0gaW1hZ2UgcXVhbGl0eSBmcm9tIDAuMCAod29yc3QpIHRvIDEuMCAoYmVzdClcbiAgICAgICAgICBmaWxlV3JpdGVyOiBudWxsLFxuICAgICAgICAgIC8vIENocm9tZSBGaWxlV3JpdGVyIGluIG9yZGVyIHRvIHN0cmVhbSB0byBhIGZpbGUgaW5zdGVhZCBvZiBidWZmZXJpbmcgdG8gbWVtb3J5IChvcHRpb25hbClcbiAgICAgICAgICBmZDogbnVsbCxcbiAgICAgICAgICAvLyBOb2RlLkpTIGZpbGUgZGVzY3JpcHRvciB0byB3cml0ZSB0byBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyAob3B0aW9uYWwpXG4gICAgICAgICAgLy8gWW91IG11c3Qgc3VwcGx5IG9uZSBvZjpcbiAgICAgICAgICBmcmFtZUR1cmF0aW9uOiBudWxsLFxuICAgICAgICAgIC8vIER1cmF0aW9uIG9mIGZyYW1lcyBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICBmcmFtZVJhdGU6IG51bGwgLy8gTnVtYmVyIG9mIGZyYW1lcyBwZXIgc2Vjb25kXG5cbiAgICAgICAgfSxcbiAgICAgICAgICAgIHNlZWtQb2ludHMgPSB7XG4gICAgICAgICAgQ3Vlczoge1xuICAgICAgICAgICAgaWQ6IG5ldyBVaW50OEFycmF5KFsweDFjLCAweDUzLCAweGJiLCAweDZiXSksXG4gICAgICAgICAgICBwb3NpdGlvbkVCTUw6IG51bGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFNlZ21lbnRJbmZvOiB7XG4gICAgICAgICAgICBpZDogbmV3IFVpbnQ4QXJyYXkoWzB4MTUsIDB4NDksIDB4YTksIDB4NjZdKSxcbiAgICAgICAgICAgIHBvc2l0aW9uRUJNTDogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgVHJhY2tzOiB7XG4gICAgICAgICAgICBpZDogbmV3IFVpbnQ4QXJyYXkoWzB4MTYsIDB4NTQsIDB4YWUsIDB4NmJdKSxcbiAgICAgICAgICAgIHBvc2l0aW9uRUJNTDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgICAgIGVibWxTZWdtZW50LFxuICAgICAgICAgICAgc2VnbWVudER1cmF0aW9uID0ge1xuICAgICAgICAgIGlkOiAweDQ0ODksXG4gICAgICAgICAgLy8gRHVyYXRpb25cbiAgICAgICAgICBkYXRhOiBuZXcgRUJNTEZsb2F0NjQoMClcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHNlZWtIZWFkLFxuICAgICAgICAgICAgY3VlcyA9IFtdLFxuICAgICAgICAgICAgYmxvYkJ1ZmZlciA9IG5ldyBCbG9iQnVmZmVyKG9wdGlvbnMuZmlsZVdyaXRlciB8fCBvcHRpb25zLmZkKTtcblxuICAgICAgICBmdW5jdGlvbiBmaWxlT2Zmc2V0VG9TZWdtZW50UmVsYXRpdmUoZmlsZU9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBmaWxlT2Zmc2V0IC0gZWJtbFNlZ21lbnQuZGF0YU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgU2Vla0hlYWQgZWxlbWVudCB3aXRoIGRlc2NyaXB0b3JzIGZvciB0aGUgcG9pbnRzIGluIHRoZSBnbG9iYWwgc2Vla1BvaW50cyBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogNSBieXRlcyBvZiBwb3NpdGlvbiB2YWx1ZXMgYXJlIHJlc2VydmVkIGZvciBlYWNoIG5vZGUsIHdoaWNoIGxpZSBhdCB0aGUgb2Zmc2V0IHBvaW50LnBvc2l0aW9uRUJNTC5kYXRhT2Zmc2V0LFxuICAgICAgICAgKiB0byBiZSBvdmVyd3JpdHRlbiBsYXRlci5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVTZWVrSGVhZCgpIHtcbiAgICAgICAgICB2YXIgc2Vla1Bvc2l0aW9uRUJNTFRlbXBsYXRlID0ge1xuICAgICAgICAgICAgaWQ6IDB4NTNhYyxcbiAgICAgICAgICAgIC8vIFNlZWtQb3NpdGlvblxuICAgICAgICAgICAgc2l6ZTogNSxcbiAgICAgICAgICAgIC8vIEFsbG93cyBmb3IgMzJHQiB2aWRlbyBmaWxlc1xuICAgICAgICAgICAgZGF0YTogMCAvLyBXZSdsbCBvdmVyd3JpdGUgdGhpcyB3aGVuIHRoZSBmaWxlIGlzIGNvbXBsZXRlXG5cbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBpZDogMHgxMTRkOWI3NCxcbiAgICAgICAgICAgIC8vIFNlZWtIZWFkXG4gICAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHNlZWtQb2ludHMpIHtcbiAgICAgICAgICAgIHZhciBzZWVrUG9pbnQgPSBzZWVrUG9pbnRzW25hbWVdO1xuICAgICAgICAgICAgc2Vla1BvaW50LnBvc2l0aW9uRUJNTCA9IE9iamVjdC5jcmVhdGUoc2Vla1Bvc2l0aW9uRUJNTFRlbXBsYXRlKTtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhLnB1c2goe1xuICAgICAgICAgICAgICBpZDogMHg0ZGJiLFxuICAgICAgICAgICAgICAvLyBTZWVrXG4gICAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgICAgaWQ6IDB4NTNhYixcbiAgICAgICAgICAgICAgICAvLyBTZWVrSURcbiAgICAgICAgICAgICAgICBkYXRhOiBzZWVrUG9pbnQuaWRcbiAgICAgICAgICAgICAgfSwgc2Vla1BvaW50LnBvc2l0aW9uRUJNTF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlIHRoZSBXZWJNIGZpbGUgaGVhZGVyIHRvIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVIZWFkZXIoKSB7XG4gICAgICAgICAgc2Vla0hlYWQgPSBjcmVhdGVTZWVrSGVhZCgpO1xuICAgICAgICAgIHZhciBlYm1sSGVhZGVyID0ge1xuICAgICAgICAgICAgaWQ6IDB4MWE0NWRmYTMsXG4gICAgICAgICAgICAvLyBFQk1MXG4gICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICBpZDogMHg0Mjg2LFxuICAgICAgICAgICAgICAvLyBFQk1MVmVyc2lvblxuICAgICAgICAgICAgICBkYXRhOiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGlkOiAweDQyZjcsXG4gICAgICAgICAgICAgIC8vIEVCTUxSZWFkVmVyc2lvblxuICAgICAgICAgICAgICBkYXRhOiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGlkOiAweDQyZjIsXG4gICAgICAgICAgICAgIC8vIEVCTUxNYXhJRExlbmd0aFxuICAgICAgICAgICAgICBkYXRhOiA0XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGlkOiAweDQyZjMsXG4gICAgICAgICAgICAgIC8vIEVCTUxNYXhTaXplTGVuZ3RoXG4gICAgICAgICAgICAgIGRhdGE6IDhcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgaWQ6IDB4NDI4MixcbiAgICAgICAgICAgICAgLy8gRG9jVHlwZVxuICAgICAgICAgICAgICBkYXRhOiAnd2VibSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgaWQ6IDB4NDI4NyxcbiAgICAgICAgICAgICAgLy8gRG9jVHlwZVZlcnNpb25cbiAgICAgICAgICAgICAgZGF0YTogMlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBpZDogMHg0Mjg1LFxuICAgICAgICAgICAgICAvLyBEb2NUeXBlUmVhZFZlcnNpb25cbiAgICAgICAgICAgICAgZGF0YTogMlxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZWdtZW50SW5mbyA9IHtcbiAgICAgICAgICAgIGlkOiAweDE1NDlhOTY2LFxuICAgICAgICAgICAgLy8gSW5mb1xuICAgICAgICAgICAgZGF0YTogW3tcbiAgICAgICAgICAgICAgaWQ6IDB4MmFkN2IxLFxuICAgICAgICAgICAgICAvLyBUaW1lY29kZVNjYWxlXG4gICAgICAgICAgICAgIGRhdGE6IDFlNiAvLyBUaW1lcyB3aWxsIGJlIGluIG1pbGlzZWNvbmRzICgxZTYgbmFub3NlY29uZHMgcGVyIHN0ZXAgPSAxbXMpXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgaWQ6IDB4NGQ4MCxcbiAgICAgICAgICAgICAgLy8gTXV4aW5nQXBwXG4gICAgICAgICAgICAgIGRhdGE6ICd3ZWJtLXdyaXRlci1qcydcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgaWQ6IDB4NTc0MSxcbiAgICAgICAgICAgICAgLy8gV3JpdGluZ0FwcFxuICAgICAgICAgICAgICBkYXRhOiAnd2VibS13cml0ZXItanMnXG4gICAgICAgICAgICB9LCBzZWdtZW50RHVyYXRpb24gLy8gVG8gYmUgZmlsbGVkIGluIGxhdGVyXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdHJhY2tzID0ge1xuICAgICAgICAgICAgaWQ6IDB4MTY1NGFlNmIsXG4gICAgICAgICAgICAvLyBUcmFja3NcbiAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgIGlkOiAweGFlLFxuICAgICAgICAgICAgICAvLyBUcmFja0VudHJ5XG4gICAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgICAgaWQ6IDB4ZDcsXG4gICAgICAgICAgICAgICAgLy8gVHJhY2tOdW1iZXJcbiAgICAgICAgICAgICAgICBkYXRhOiBERUZBVUxUX1RSQUNLX05VTUJFUlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaWQ6IDB4NzNjNSxcbiAgICAgICAgICAgICAgICAvLyBUcmFja1VJRFxuICAgICAgICAgICAgICAgIGRhdGE6IERFRkFVTFRfVFJBQ0tfTlVNQkVSXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBpZDogMHg5YyxcbiAgICAgICAgICAgICAgICAvLyBGbGFnTGFjaW5nXG4gICAgICAgICAgICAgICAgZGF0YTogMFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaWQ6IDB4MjJiNTljLFxuICAgICAgICAgICAgICAgIC8vIExhbmd1YWdlXG4gICAgICAgICAgICAgICAgZGF0YTogJ3VuZCdcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGlkOiAweDg2LFxuICAgICAgICAgICAgICAgIC8vIENvZGVjSURcbiAgICAgICAgICAgICAgICBkYXRhOiAnVl9WUDgnXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBpZDogMHgyNTg2ODgsXG4gICAgICAgICAgICAgICAgLy8gQ29kZWNOYW1lXG4gICAgICAgICAgICAgICAgZGF0YTogJ1ZQOCdcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGlkOiAweDgzLFxuICAgICAgICAgICAgICAgIC8vIFRyYWNrVHlwZVxuICAgICAgICAgICAgICAgIGRhdGE6IDFcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGlkOiAweGUwLFxuICAgICAgICAgICAgICAgIC8vIFZpZGVvXG4gICAgICAgICAgICAgICAgZGF0YTogW3tcbiAgICAgICAgICAgICAgICAgIGlkOiAweGIwLFxuICAgICAgICAgICAgICAgICAgLy8gUGl4ZWxXaWR0aFxuICAgICAgICAgICAgICAgICAgZGF0YTogdmlkZW9XaWR0aFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIGlkOiAweGJhLFxuICAgICAgICAgICAgICAgICAgLy8gUGl4ZWxIZWlnaHRcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHZpZGVvSGVpZ2h0XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfTtcbiAgICAgICAgICBlYm1sU2VnbWVudCA9IHtcbiAgICAgICAgICAgIGlkOiAweDE4NTM4MDY3LFxuICAgICAgICAgICAgLy8gU2VnbWVudFxuICAgICAgICAgICAgc2l6ZTogLTEsXG4gICAgICAgICAgICAvLyBVbmJvdW5kZWQgc2l6ZVxuICAgICAgICAgICAgZGF0YTogW3NlZWtIZWFkLCBzZWdtZW50SW5mbywgdHJhY2tzXVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGJ1ZmZlclN0cmVhbSA9IG5ldyBBcnJheUJ1ZmZlckRhdGFTdHJlYW0oMjU2KTtcbiAgICAgICAgICB3cml0ZUVCTUwoYnVmZmVyU3RyZWFtLCBibG9iQnVmZmVyLnBvcywgW2VibWxIZWFkZXIsIGVibWxTZWdtZW50XSk7XG4gICAgICAgICAgYmxvYkJ1ZmZlci53cml0ZShidWZmZXJTdHJlYW0uZ2V0QXNEYXRhQXJyYXkoKSk7IC8vIE5vdyB3ZSBrbm93IHdoZXJlIHRoZXNlIHRvcC1sZXZlbCBlbGVtZW50cyBsaWUgaW4gdGhlIGZpbGU6XG5cbiAgICAgICAgICBzZWVrUG9pbnRzLlNlZ21lbnRJbmZvLnBvc2l0aW9uRUJNTC5kYXRhID0gZmlsZU9mZnNldFRvU2VnbWVudFJlbGF0aXZlKHNlZ21lbnRJbmZvLm9mZnNldCk7XG4gICAgICAgICAgc2Vla1BvaW50cy5UcmFja3MucG9zaXRpb25FQk1MLmRhdGEgPSBmaWxlT2Zmc2V0VG9TZWdtZW50UmVsYXRpdmUodHJhY2tzLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIFNpbXBsZUJsb2NrIGtleWZyYW1lIGhlYWRlciB1c2luZyB0aGVzZSBmaWVsZHM6XG4gICAgICAgICAqICAgICB0aW1lY29kZSAgICAtIFRpbWUgb2YgdGhpcyBrZXlmcmFtZVxuICAgICAgICAgKiAgICAgdHJhY2tOdW1iZXIgLSBUcmFjayBudW1iZXIgZnJvbSAxIHRvIDEyNiAoaW5jbHVzaXZlKVxuICAgICAgICAgKiAgICAgZnJhbWUgICAgICAgLSBSYXcgZnJhbWUgZGF0YSBwYXlsb2FkIHN0cmluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIEVCTUwgZWxlbWVudC5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVLZXlmcmFtZUJsb2NrKGtleWZyYW1lKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlclN0cmVhbSA9IG5ldyBBcnJheUJ1ZmZlckRhdGFTdHJlYW0oMSArIDIgKyAxKTtcblxuICAgICAgICAgIGlmICghKGtleWZyYW1lLnRyYWNrTnVtYmVyID4gMCAmJiBrZXlmcmFtZS50cmFja051bWJlciA8IDEyNykpIHtcbiAgICAgICAgICAgIHRocm93ICdUcmFja051bWJlciBtdXN0IGJlID4gMCBhbmQgPCAxMjcnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJ1ZmZlclN0cmVhbS53cml0ZUVCTUxWYXJJbnQoa2V5ZnJhbWUudHJhY2tOdW1iZXIpOyAvLyBBbHdheXMgMSBieXRlIHNpbmNlIHdlIGxpbWl0IHRoZSByYW5nZSBvZiB0cmFja051bWJlclxuXG4gICAgICAgICAgYnVmZmVyU3RyZWFtLndyaXRlVTE2QkUoa2V5ZnJhbWUudGltZWNvZGUpOyAvLyBGbGFncyBieXRlXG5cbiAgICAgICAgICBidWZmZXJTdHJlYW0ud3JpdGVCeXRlKDEgPDwgNyAvLyBLZXlmcmFtZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiAweGEzLFxuICAgICAgICAgICAgLy8gU2ltcGxlQmxvY2tcbiAgICAgICAgICAgIGRhdGE6IFtidWZmZXJTdHJlYW0uZ2V0QXNEYXRhQXJyYXkoKSwga2V5ZnJhbWUuZnJhbWVdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgQ2x1c3RlciBub2RlIHVzaW5nIHRoZXNlIGZpZWxkczpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgdGltZWNvZGUgICAgLSBTdGFydCB0aW1lIGZvciB0aGUgY2x1c3RlclxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIEVCTUwgZWxlbWVudC5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDbHVzdGVyKGNsdXN0ZXIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IDB4MWY0M2I2NzUsXG4gICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICBpZDogMHhlNyxcbiAgICAgICAgICAgICAgLy8gVGltZWNvZGVcbiAgICAgICAgICAgICAgZGF0YTogTWF0aC5yb3VuZChjbHVzdGVyLnRpbWVjb2RlKVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkQ3VlUG9pbnQodHJhY2tJbmRleCwgY2x1c3RlclRpbWUsIGNsdXN0ZXJGaWxlT2Zmc2V0KSB7XG4gICAgICAgICAgY3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiAweGJiLFxuICAgICAgICAgICAgLy8gQ3VlXG4gICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICBpZDogMHhiMyxcbiAgICAgICAgICAgICAgLy8gQ3VlVGltZVxuICAgICAgICAgICAgICBkYXRhOiBjbHVzdGVyVGltZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBpZDogMHhiNyxcbiAgICAgICAgICAgICAgLy8gQ3VlVHJhY2tQb3NpdGlvbnNcbiAgICAgICAgICAgICAgZGF0YTogW3tcbiAgICAgICAgICAgICAgICBpZDogMHhmNyxcbiAgICAgICAgICAgICAgICAvLyBDdWVUcmFja1xuICAgICAgICAgICAgICAgIGRhdGE6IHRyYWNrSW5kZXhcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGlkOiAweGYxLFxuICAgICAgICAgICAgICAgIC8vIEN1ZUNsdXN0ZXJQb3NpdGlvblxuICAgICAgICAgICAgICAgIGRhdGE6IGZpbGVPZmZzZXRUb1NlZ21lbnRSZWxhdGl2ZShjbHVzdGVyRmlsZU9mZnNldClcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlIGEgQ3VlcyBlbGVtZW50IHRvIHRoZSBibG9iU3RyZWFtIHVzaW5nIHRoZSBnbG9iYWwgYGN1ZXNgIGFycmF5IG9mIEN1ZVBvaW50cyAodXNlIGFkZEN1ZVBvaW50KCkpLlxuICAgICAgICAgKiBUaGUgc2VlayBlbnRyeSBmb3IgdGhlIEN1ZXMgaW4gdGhlIFNlZWtIZWFkIGlzIHVwZGF0ZWQuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDdWVzKCkge1xuICAgICAgICAgIHZhciBlYm1sID0ge1xuICAgICAgICAgICAgaWQ6IDB4MWM1M2JiNmIsXG4gICAgICAgICAgICBkYXRhOiBjdWVzXG4gICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY3Vlc0J1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlckRhdGFTdHJlYW0oMTYgKyBjdWVzLmxlbmd0aCAqIDMyKTsgLy8gUHJldHR5IGNydWRlIGVzdGltYXRlIG9mIHRoZSBidWZmZXIgc2l6ZSB3ZSdsbCBuZWVkXG5cbiAgICAgICAgICB3cml0ZUVCTUwoY3Vlc0J1ZmZlciwgYmxvYkJ1ZmZlci5wb3MsIGVibWwpO1xuICAgICAgICAgIGJsb2JCdWZmZXIud3JpdGUoY3Vlc0J1ZmZlci5nZXRBc0RhdGFBcnJheSgpKTsgLy8gTm93IHdlIGtub3cgd2hlcmUgdGhlIEN1ZXMgZWxlbWVudCBoYXMgZW5kZWQgdXAsIHdlIGNhbiB1cGRhdGUgdGhlIFNlZWtIZWFkXG5cbiAgICAgICAgICBzZWVrUG9pbnRzLkN1ZXMucG9zaXRpb25FQk1MLmRhdGEgPSBmaWxlT2Zmc2V0VG9TZWdtZW50UmVsYXRpdmUoZWJtbC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbHVzaCB0aGUgZnJhbWVzIGluIHRoZSBjdXJyZW50IGNsdXN0ZXJGcmFtZUJ1ZmZlciBvdXQgdG8gdGhlIHN0cmVhbSBhcyBhIENsdXN0ZXIuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgZnVuY3Rpb24gZmx1c2hDbHVzdGVyRnJhbWVCdWZmZXIoKSB7XG4gICAgICAgICAgaWYgKGNsdXN0ZXJGcmFtZUJ1ZmZlci5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gRmlyc3Qgd29yayBvdXQgaG93IGxhcmdlIG9mIGEgYnVmZmVyIHdlIG5lZWQgdG8gaG9sZCB0aGUgY2x1c3RlciBkYXRhXG5cblxuICAgICAgICAgIHZhciByYXdJbWFnZVNpemUgPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVyRnJhbWVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJhd0ltYWdlU2l6ZSArPSBjbHVzdGVyRnJhbWVCdWZmZXJbaV0uZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXJEYXRhU3RyZWFtKHJhd0ltYWdlU2l6ZSArIGNsdXN0ZXJGcmFtZUJ1ZmZlci5sZW5ndGggKiAzMiksXG4gICAgICAgICAgICAgIC8vIEVzdGltYXRlIDMyIGJ5dGVzIHBlciBTaW1wbGVCbG9jayBoZWFkZXJcbiAgICAgICAgICBjbHVzdGVyID0gY3JlYXRlQ2x1c3Rlcih7XG4gICAgICAgICAgICB0aW1lY29kZTogTWF0aC5yb3VuZChjbHVzdGVyU3RhcnRUaW1lKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVyRnJhbWVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNsdXN0ZXIuZGF0YS5wdXNoKGNyZWF0ZUtleWZyYW1lQmxvY2soY2x1c3RlckZyYW1lQnVmZmVyW2ldKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd3JpdGVFQk1MKGJ1ZmZlciwgYmxvYkJ1ZmZlci5wb3MsIGNsdXN0ZXIpO1xuICAgICAgICAgIGJsb2JCdWZmZXIud3JpdGUoYnVmZmVyLmdldEFzRGF0YUFycmF5KCkpO1xuICAgICAgICAgIGFkZEN1ZVBvaW50KERFRkFVTFRfVFJBQ0tfTlVNQkVSLCBNYXRoLnJvdW5kKGNsdXN0ZXJTdGFydFRpbWUpLCBjbHVzdGVyLm9mZnNldCk7XG4gICAgICAgICAgY2x1c3RlckZyYW1lQnVmZmVyID0gW107XG4gICAgICAgICAgY2x1c3RlclN0YXJ0VGltZSArPSBjbHVzdGVyRHVyYXRpb247XG4gICAgICAgICAgY2x1c3RlckR1cmF0aW9uID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucygpIHtcbiAgICAgICAgICAvLyBEZXJpdmUgZnJhbWVEdXJhdGlvbiBzZXR0aW5nIGlmIG5vdCBhbHJlYWR5IHN1cHBsaWVkXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmZyYW1lRHVyYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZyYW1lUmF0ZSkge1xuICAgICAgICAgICAgICBvcHRpb25zLmZyYW1lRHVyYXRpb24gPSAxMDAwIC8gb3B0aW9ucy5mcmFtZVJhdGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyAnTWlzc2luZyByZXF1aXJlZCBmcmFtZUR1cmF0aW9uIG9yIGZyYW1lUmF0ZSBzZXR0aW5nJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRGcmFtZVRvQ2x1c3RlcihmcmFtZSkge1xuICAgICAgICAgIGZyYW1lLnRyYWNrTnVtYmVyID0gREVGQVVMVF9UUkFDS19OVU1CRVI7IC8vIEZyYW1lIHRpbWVjb2RlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZWlyIGNsdXN0ZXI6XG5cbiAgICAgICAgICBmcmFtZS50aW1lY29kZSA9IE1hdGgucm91bmQoY2x1c3RlckR1cmF0aW9uKTtcbiAgICAgICAgICBjbHVzdGVyRnJhbWVCdWZmZXIucHVzaChmcmFtZSk7XG4gICAgICAgICAgY2x1c3RlckR1cmF0aW9uICs9IGZyYW1lLmR1cmF0aW9uO1xuXG4gICAgICAgICAgaWYgKGNsdXN0ZXJEdXJhdGlvbiA+PSBNQVhfQ0xVU1RFUl9EVVJBVElPTl9NU0VDKSB7XG4gICAgICAgICAgICBmbHVzaENsdXN0ZXJGcmFtZUJ1ZmZlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV3cml0ZXMgdGhlIFNlZWtIZWFkIGVsZW1lbnQgdGhhdCB3YXMgaW5pdGlhbGx5IHdyaXR0ZW4gdG8gdGhlIHN0cmVhbSB3aXRoIHRoZSBvZmZzZXRzIG9mIHRvcCBsZXZlbCBlbGVtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2FsbCBvbmNlIHdyaXRpbmcgaXMgY29tcGxldGUgKHNvIHRoZSBvZmZzZXQgb2YgYWxsIHRvcCBsZXZlbCBlbGVtZW50cyBpcyBrbm93bikuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgZnVuY3Rpb24gcmV3cml0ZVNlZWtIZWFkKCkge1xuICAgICAgICAgIHZhciBzZWVrSGVhZEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlckRhdGFTdHJlYW0oc2Vla0hlYWQuc2l6ZSksXG4gICAgICAgICAgICAgIG9sZFBvcyA9IGJsb2JCdWZmZXIucG9zOyAvLyBXcml0ZSB0aGUgcmV3cml0dGVuIFNlZWtIZWFkIGVsZW1lbnQncyBkYXRhIHBheWxvYWQgdG8gdGhlIHN0cmVhbSAoZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIGlkIG9yIHNpemUpXG5cbiAgICAgICAgICB3cml0ZUVCTUwoc2Vla0hlYWRCdWZmZXIsIHNlZWtIZWFkLmRhdGFPZmZzZXQsIHNlZWtIZWFkLmRhdGEpOyAvLyBBbmQgd3JpdGUgdGhhdCB0aHJvdWdoIHRvIHRoZSBmaWxlXG5cbiAgICAgICAgICBibG9iQnVmZmVyLnNlZWsoc2Vla0hlYWQuZGF0YU9mZnNldCk7XG4gICAgICAgICAgYmxvYkJ1ZmZlci53cml0ZShzZWVrSGVhZEJ1ZmZlci5nZXRBc0RhdGFBcnJheSgpKTtcbiAgICAgICAgICBibG9iQnVmZmVyLnNlZWsob2xkUG9zKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV3cml0ZSB0aGUgRHVyYXRpb24gZmllbGQgb2YgdGhlIFNlZ21lbnQgd2l0aCB0aGUgbmV3bHktZGlzY292ZXJlZCB2aWRlbyBkdXJhdGlvbi5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiByZXdyaXRlRHVyYXRpb24oKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlckRhdGFTdHJlYW0oOCksXG4gICAgICAgICAgICAgIG9sZFBvcyA9IGJsb2JCdWZmZXIucG9zOyAvLyBSZXdyaXRlIHRoZSBkYXRhIHBheWxvYWQgKGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSBpZCBvciBzaXplKVxuXG4gICAgICAgICAgYnVmZmVyLndyaXRlRG91YmxlQkUoY2x1c3RlclN0YXJ0VGltZSk7IC8vIEFuZCB3cml0ZSB0aGF0IHRocm91Z2ggdG8gdGhlIGZpbGVcblxuICAgICAgICAgIGJsb2JCdWZmZXIuc2VlayhzZWdtZW50RHVyYXRpb24uZGF0YU9mZnNldCk7XG4gICAgICAgICAgYmxvYkJ1ZmZlci53cml0ZShidWZmZXIuZ2V0QXNEYXRhQXJyYXkoKSk7XG4gICAgICAgICAgYmxvYkJ1ZmZlci5zZWVrKG9sZFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIGZyYW1lIHRvIHRoZSB2aWRlby4gQ3VycmVudGx5IHRoZSBmcmFtZSBtdXN0IGJlIGEgQ2FudmFzIGVsZW1lbnQuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgdGhpcy5hZGRGcmFtZSA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgICAgICBpZiAod3JpdHRlbkhlYWRlcikge1xuICAgICAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPSB2aWRlb1dpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT0gdmlkZW9IZWlnaHQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgJ0ZyYW1lIHNpemUgZGlmZmVycyBmcm9tIHByZXZpb3VzIGZyYW1lcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZGVvV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICB2aWRlb0hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICB3cml0ZUhlYWRlcigpO1xuICAgICAgICAgICAgd3JpdHRlbkhlYWRlciA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHdlYlAgPSByZW5kZXJBc1dlYlAoY2FudmFzLCB7XG4gICAgICAgICAgICBxdWFsaXR5OiBvcHRpb25zLnF1YWxpdHlcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghd2ViUCkge1xuICAgICAgICAgICAgdGhyb3cgXCJDb3VsZG4ndCBkZWNvZGUgV2ViUCBmcmFtZSwgZG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IFdlYlA/XCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkRnJhbWVUb0NsdXN0ZXIoe1xuICAgICAgICAgICAgZnJhbWU6IGV4dHJhY3RLZXlmcmFtZUZyb21XZWJQKHdlYlApLFxuICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZnJhbWVEdXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluaXNoIHdyaXRpbmcgdGhlIHZpZGVvIGFuZCByZXR1cm4gYSBQcm9taXNlIHRvIHNpZ25hbCBjb21wbGV0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgZGVzdGluYXRpb24gZGV2aWNlIHdhcyBtZW1vcnkgKGkuZS4gb3B0aW9ucy5maWxlV3JpdGVyIHdhcyBub3Qgc3VwcGxpZWQpLCB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoXG4gICAgICAgICAqIGEgQmxvYiB3aXRoIHRoZSBjb250ZW50cyBvZiB0aGUgZW50aXJlIHZpZGVvLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIHRoaXMuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZmx1c2hDbHVzdGVyRnJhbWVCdWZmZXIoKTtcbiAgICAgICAgICB3cml0ZUN1ZXMoKTtcbiAgICAgICAgICByZXdyaXRlU2Vla0hlYWQoKTtcbiAgICAgICAgICByZXdyaXRlRHVyYXRpb24oKTtcbiAgICAgICAgICByZXR1cm4gYmxvYkJ1ZmZlci5jb21wbGV0ZSgndmlkZW8vd2VibScpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0V3JpdHRlblNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGJsb2JCdWZmZXIubGVuZ3RoO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQob3B0aW9uRGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB2YWxpZGF0ZU9wdGlvbnMoKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGlmIChpc05vZGVFbnZpcm9tZW50KSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IFdlYk1Xcml0ZXIoQXJyYXlCdWZmZXJEYXRhU3RyZWFtLCBCbG9iQnVmZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LldlYk1Xcml0ZXIgPSBXZWJNV3JpdGVyKEFycmF5QnVmZmVyRGF0YVN0cmVhbSwgQmxvYkJ1ZmZlcik7XG4gICAgfVxuICB9KSgpO1xufSkod2VibVdyaXRlcjBfMl8wKTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgIWZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0ID0gdm9pZCAwICE9PSBtb2R1bGUuZXhwb3J0cyxcbiAgICAgICAgZSA9IHQgPyB0YXIuZXhwb3J0cyA6IHdpbmRvdy5UYXIsXG4gICAgICAgIE0gPSB0ID8gZG93bmxvYWQuZXhwb3J0cyA6IHdpbmRvdy5kb3dubG9hZCxcbiAgICAgICAgaSA9IHQgPyBnaWYuR0lGIDogd2luZG93LkdJRixcbiAgICAgICAgbiA9IHQgPyB3ZWJtV3JpdGVyMF8yXzAuZXhwb3J0cyA6IHdpbmRvdy5XZWJNV3JpdGVyLFxuICAgICAgICBvID0ge1xuICAgICAgZnVuY3Rpb246ICEwLFxuICAgICAgb2JqZWN0OiAhMFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByKHQpIHtcbiAgICAgIHJldHVybiB0ICYmIHQuT2JqZWN0ID09PSBPYmplY3QgPyB0IDogbnVsbDtcbiAgICB9XG4gICAgdmFyIGEgPSBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlID8gZXhwb3J0cyA6IHZvaWQgMCxcbiAgICAgICAgcyA9IG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlID8gbW9kdWxlIDogdm9pZCAwLFxuICAgICAgICBjID0gcyAmJiBzLmV4cG9ydHMgPT09IGEgPyBhIDogdm9pZCAwLFxuICAgICAgICBoID0gcihhICYmIHMgJiYgJ29iamVjdCcgPT0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsKSxcbiAgICAgICAgcCA9IHIob1t0eXBlb2Ygc2VsZl0gJiYgc2VsZiksXG4gICAgICAgIG0gPSByKG9bdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KSxcbiAgICAgICAgZCA9IHIob1t0eXBlb2YgdGhpc10gJiYgdGhpcyksXG4gICAgICAgIHUgPSBoIHx8IG0gIT09IChkICYmIGQud2luZG93KSAmJiBtIHx8IHAgfHwgZCB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gICAgZnVuY3Rpb24gbCh0KSB7XG4gICAgICByZXR1cm4gU3RyaW5nKCcwMDAwMDAwJyArIHQpLnNsaWNlKC03KTtcbiAgICB9XG5cbiAgICAnZ2MnIGluIHdpbmRvdyB8fCAod2luZG93LmdjID0gZnVuY3Rpb24gKCkge30pLCBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUudG9CbG9iIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUsICd0b0Jsb2InLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IGF0b2IodGhpcy50b0RhdGFVUkwoZSwgaSkuc3BsaXQoJywnKVsxXSksIG8gPSBuLmxlbmd0aCwgciA9IG5ldyBVaW50OEFycmF5KG8pLCBhID0gMDsgYSA8IG87IGErKykgclthXSA9IG4uY2hhckNvZGVBdChhKTtcblxuICAgICAgICB0KG5ldyBCbG9iKFtyXSwge1xuICAgICAgICAgIHR5cGU6IGUgfHwgJ2ltYWdlL3BuZydcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoJ3BlcmZvcm1hbmNlJyBpbiB3aW5kb3cgPT0gMCAmJiAod2luZG93LnBlcmZvcm1hbmNlID0ge30pLCBEYXRlLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgfSwgJ25vdycgaW4gd2luZG93LnBlcmZvcm1hbmNlID09IDApIHtcbiAgICAgICAgdmFyIHQgPSBEYXRlLm5vdygpO1xuICAgICAgICBwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCAmJiAodCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpLCB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KCk7XG4gICAgdmFyIFcgPSB3aW5kb3cuRGF0ZS5ub3coKTtcblxuICAgIGZ1bmN0aW9uIGYodCkge1xuICAgICAgdmFyIGkgPSB7fTtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSB0LCB0aGlzLm9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgaVt0XSA9IGU7XG4gICAgICB9LCB0aGlzLmVtaXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IGlbdF07XG4gICAgICAgIGUgJiYgZS5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgIH0sIHRoaXMuZmlsZW5hbWUgPSB0Lm5hbWUgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiB0KCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKDY1NTM2ICogKDEgKyBNYXRoLnJhbmRvbSgpKSkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0KCkgKyB0KCkgKyAnLScgKyB0KCkgKyAnLScgKyB0KCkgKyAnLScgKyB0KCkgKyAnLScgKyB0KCkgKyB0KCkgKyB0KCk7XG4gICAgICB9KCksIHRoaXMuZXh0ZW5zaW9uID0gJycsIHRoaXMubWltZVR5cGUgPSAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3KHQpIHtcbiAgICAgIGYuY2FsbCh0aGlzLCB0KSwgdGhpcy5leHRlbnNpb24gPSAnLnRhcicsIHRoaXMubWltZVR5cGUgPSAnYXBwbGljYXRpb24veC10YXInLCB0aGlzLmZpbGVFeHRlbnNpb24gPSAnJywgdGhpcy5iYXNlRmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lLCB0aGlzLnRhcGUgPSBudWxsLCB0aGlzLmNvdW50ID0gMCwgdGhpcy5wYXJ0ID0gMSwgdGhpcy5mcmFtZXMgPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHoodCkge1xuICAgICAgdy5jYWxsKHRoaXMsIHQpLCB0aGlzLnR5cGUgPSAnaW1hZ2UvcG5nJywgdGhpcy5maWxlRXh0ZW5zaW9uID0gJy5wbmcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFUodCkge1xuICAgICAgdy5jYWxsKHRoaXMsIHQpLCB0aGlzLnR5cGUgPSAnaW1hZ2UvanBlZycsIHRoaXMuZmlsZUV4dGVuc2lvbiA9ICcuanBnJywgdGhpcy5xdWFsaXR5ID0gdC5xdWFsaXR5IC8gMTAwIHx8IDAuODtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfKHQpIHtcbiAgICAgICdpbWFnZS93ZWJwJyAhPT0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykudG9EYXRhVVJMKCdpbWFnZS93ZWJwJykuc3Vic3RyKDUsIDEwKSAmJiBjb25zb2xlLmxvZygnV2ViUCBub3Qgc3VwcG9ydGVkIC0gdHJ5IGFub3RoZXIgZXhwb3J0IGZvcm1hdCcpLCBmLmNhbGwodGhpcywgdCksIHRoaXMucXVhbGl0eSA9IHQucXVhbGl0eSAvIDEwMCB8fCAwLjgsIHRoaXMuZXh0ZW5zaW9uID0gJy53ZWJtJywgdGhpcy5taW1lVHlwZSA9ICd2aWRlby93ZWJtJywgdGhpcy5iYXNlRmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lLCB0aGlzLmZyYW1lcmF0ZSA9IHQuZnJhbWVyYXRlLCB0aGlzLmZyYW1lcyA9IDAsIHRoaXMucGFydCA9IDEsIHRoaXMudmlkZW9Xcml0ZXIgPSBuZXcgbih7XG4gICAgICAgIHF1YWxpdHk6IHRoaXMucXVhbGl0eSxcbiAgICAgICAgZmlsZVdyaXRlcjogbnVsbCxcbiAgICAgICAgZmQ6IG51bGwsXG4gICAgICAgIGZyYW1lUmF0ZTogdGhpcy5mcmFtZXJhdGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEgodCkge1xuICAgICAgZi5jYWxsKHRoaXMsIHQpLCB0LnF1YWxpdHkgPSB0LnF1YWxpdHkgLyAxMDAgfHwgMC44LCB0aGlzLmVuY29kZXIgPSBuZXcgRkZNcGVnU2VydmVyLlZpZGVvKHQpLCB0aGlzLmVuY29kZXIub24oJ3Byb2Nlc3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncHJvY2VzcycpO1xuICAgICAgfS5iaW5kKHRoaXMpKSwgdGhpcy5lbmNvZGVyLm9uKCdmaW5pc2hlZCcsIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5jYWxsYmFjaztcbiAgICAgICAgaSAmJiAodGhpcy5jYWxsYmFjayA9IHZvaWQgMCwgaSh0LCBlKSk7XG4gICAgICB9LmJpbmQodGhpcykpLCB0aGlzLmVuY29kZXIub24oJ3Byb2dyZXNzJywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5vblByb2dyZXNzICYmIHRoaXMuc2V0dGluZ3Mub25Qcm9ncmVzcyh0KTtcbiAgICAgIH0uYmluZCh0aGlzKSksIHRoaXMuZW5jb2Rlci5vbignZXJyb3InLCBmdW5jdGlvbiAodCkge1xuICAgICAgICBhbGVydChKU09OLnN0cmluZ2lmeSh0LCBudWxsLCAyKSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFYodCkge1xuICAgICAgZi5jYWxsKHRoaXMsIHQpLCB0aGlzLmZyYW1lcmF0ZSA9IHRoaXMuc2V0dGluZ3MuZnJhbWVyYXRlLCB0aGlzLnR5cGUgPSAndmlkZW8vd2VibScsIHRoaXMuZXh0ZW5zaW9uID0gJy53ZWJtJywgdGhpcy5zdHJlYW0gPSBudWxsLCB0aGlzLm1lZGlhUmVjb3JkZXIgPSBudWxsLCB0aGlzLmNodW5rcyA9IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEcodCkge1xuICAgICAgZi5jYWxsKHRoaXMsIHQpLCB0LnF1YWxpdHkgPSAzMSAtICgzMCAqIHQucXVhbGl0eSAvIDEwMCB8fCAxMCksIHQud29ya2VycyA9IHQud29ya2VycyB8fCA0LCB0aGlzLmV4dGVuc2lvbiA9ICcuZ2lmJywgdGhpcy5taW1lVHlwZSA9ICdpbWFnZS9naWYnLCB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLCB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyksIHRoaXMuc2l6ZVNldCA9ICExLCB0aGlzLmVuY29kZXIgPSBuZXcgaSh7XG4gICAgICAgIHdvcmtlcnM6IHQud29ya2VycyxcbiAgICAgICAgcXVhbGl0eTogdC5xdWFsaXR5LFxuICAgICAgICB3b3JrZXJTY3JpcHQ6IHQud29ya2Vyc1BhdGggKyAnZ2lmLndvcmtlci5qcydcbiAgICAgIH0pLCB0aGlzLmVuY29kZXIub24oJ3Byb2dyZXNzJywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5vblByb2dyZXNzICYmIHRoaXMuc2V0dGluZ3Mub25Qcm9ncmVzcyh0KTtcbiAgICAgIH0uYmluZCh0aGlzKSksIHRoaXMuZW5jb2Rlci5vbignZmluaXNoZWQnLCBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY2FsbGJhY2s7XG4gICAgICAgIGUgJiYgKHRoaXMuY2FsbGJhY2sgPSB2b2lkIDAsIGUodCkpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB5KHQpIHtcbiAgICAgIHZhciBlLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgbyxcbiAgICAgICAgICByLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBzLFxuICAgICAgICAgIGMgPSB0IHx8IHt9LFxuICAgICAgICAgIGggPSAoW10pLFxuICAgICAgICAgIHAgPSBbXSxcbiAgICAgICAgICBtID0gMCxcbiAgICAgICAgICBkID0gMCxcbiAgICAgICAgICB1ID0gW10sXG4gICAgICAgICAgbCA9ICExLFxuICAgICAgICAgIGYgPSB7fTtcbiAgICAgIGMuZnJhbWVyYXRlID0gYy5mcmFtZXJhdGUgfHwgNjAsIGMubW90aW9uQmx1ckZyYW1lcyA9IDIgKiAoYy5tb3Rpb25CbHVyRnJhbWVzIHx8IDEpLCBlID0gYy52ZXJib3NlIHx8ICExLCBjLmRpc3BsYXksIGMuc3RlcCA9IDFlMyAvIGMuZnJhbWVyYXRlLCBjLnRpbWVMaW1pdCA9IGMudGltZUxpbWl0IHx8IDAsIGMuZnJhbWVMaW1pdCA9IGMuZnJhbWVMaW1pdCB8fCAwLCBjLnN0YXJ0VGltZSA9IGMuc3RhcnRUaW1lIHx8IDA7XG4gICAgICB2YXIgdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZScsIHcuc3R5bGUubGVmdCA9IHcuc3R5bGUudG9wID0gMCwgdy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnYmxhY2snLCB3LnN0eWxlLmZvbnRGYW1pbHkgPSAnbW9ub3NwYWNlJywgdy5zdHlsZS5mb250U2l6ZSA9ICcxMXB4Jywgdy5zdHlsZS5wYWRkaW5nID0gJzVweCcsIHcuc3R5bGUuY29sb3IgPSAncmVkJywgdy5zdHlsZS56SW5kZXggPSAxZTUsIGMuZGlzcGxheSAmJiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHcpO1xuICAgICAgdmFyIHksXG4gICAgICAgICAgZyxcbiAgICAgICAgICB2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXG4gICAgICAgICAgYiA9IHYuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIFAoJ1N0ZXAgaXMgc2V0IHRvICcgKyBjLnN0ZXAgKyAnbXMnKTtcbiAgICAgIHZhciBUID0ge1xuICAgICAgICBnaWY6IEcsXG4gICAgICAgIHdlYm06IF8sXG4gICAgICAgIGZmbXBlZ3NlcnZlcjogSCxcbiAgICAgICAgcG5nOiB6LFxuICAgICAgICBqcGc6IFUsXG4gICAgICAgICd3ZWJtLW1lZGlhcmVjb3JkZXInOiBWXG4gICAgICB9LFxuICAgICAgICAgIEYgPSBUW2MuZm9ybWF0XTtcbiAgICAgIGlmICghRikgdGhyb3cgJ0Vycm9yOiBJbmNvcnJlY3Qgb3IgbWlzc2luZyBmb3JtYXQ6IFZhbGlkIGZvcm1hdHMgYXJlICcgKyBPYmplY3Qua2V5cyhUKS5qb2luKCcsICcpO1xuXG4gICAgICBpZiAoKHMgPSBuZXcgRihjKSkuc3RlcCA9IGksIHMub24oJ3Byb2Nlc3MnLCBSKSwgcy5vbigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAhZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IGZbdF07XG4gICAgICAgICAgZSAmJiBlLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9KCdwcm9ncmVzcycsIHQpO1xuICAgICAgfSksICdwZXJmb3JtYW5jZScgaW4gd2luZG93ID09IDAgJiYgKHdpbmRvdy5wZXJmb3JtYW5jZSA9IHt9KSwgRGF0ZS5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIH0sICdub3cnIGluIHdpbmRvdy5wZXJmb3JtYW5jZSA9PSAwKSB7XG4gICAgICAgIHZhciB4ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgJiYgKHggPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KSwgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHg7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBrID0gd2luZG93LnNldFRpbWVvdXQsXG4gICAgICAgICAgUyA9IHdpbmRvdy5zZXRJbnRlcnZhbCxcbiAgICAgICAgICBEID0gd2luZG93LmNsZWFySW50ZXJ2YWwsXG4gICAgICAgICAgQyA9IHdpbmRvdy5jbGVhclRpbWVvdXQsXG4gICAgICAgICAgcSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgICAgICAgaiA9IHdpbmRvdy5EYXRlLm5vdyxcbiAgICAgICAgICBJID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdyxcbiAgICAgICAgICBPID0gd2luZG93LkRhdGUucHJvdG90eXBlLmdldFRpbWUsXG4gICAgICAgICAgQiA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBFKCkge1xuICAgICAgICBsID0gITEsIHMuc3RvcCgpLCBQKCdDYXB0dXJlciBzdG9wJyksIHdpbmRvdy5zZXRUaW1lb3V0ID0gaywgd2luZG93LnNldEludGVydmFsID0gUywgd2luZG93LmNsZWFySW50ZXJ2YWwgPSBELCB3aW5kb3cuY2xlYXJUaW1lb3V0ID0gQywgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHEsIHdpbmRvdy5EYXRlLnByb3RvdHlwZS5nZXRUaW1lID0gTywgd2luZG93LkRhdGUubm93ID0gaiwgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9IEk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEwodCwgZSkge1xuICAgICAgICBrKHQsIDAsIGUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgICBMKFIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBSKCkge1xuICAgICAgICB2YXIgdCA9IDFlMyAvIGMuZnJhbWVyYXRlLFxuICAgICAgICAgICAgZSA9IChtICsgZCAvIGMubW90aW9uQmx1ckZyYW1lcykgKiB0O1xuICAgICAgICBuID0gbyArIGUsIHIgPSBhICsgZSwgQi5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdC5faG9va2VkVGltZSA9IGUgLyAxZTM7XG4gICAgICAgIH0pLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSBtIC8gYy5mcmFtZXJhdGU7XG4gICAgICAgICAgKGMuZnJhbWVMaW1pdCAmJiBtID49IGMuZnJhbWVMaW1pdCB8fCBjLnRpbWVMaW1pdCAmJiB0ID49IGMudGltZUxpbWl0KSAmJiAoRSgpLCBBKCkpO1xuICAgICAgICAgIHZhciBlID0gbmV3IERhdGUobnVsbCk7XG4gICAgICAgICAgZS5zZXRTZWNvbmRzKHQpLCAyIDwgYy5tb3Rpb25CbHVyRnJhbWVzID8gdy50ZXh0Q29udGVudCA9ICdDQ2FwdHVyZSAnICsgYy5mb3JtYXQgKyAnIHwgJyArIG0gKyAnIGZyYW1lcyAoJyArIGQgKyAnIGludGVyKSB8ICcgKyBlLnRvSVNPU3RyaW5nKCkuc3Vic3RyKDExLCA4KSA6IHcudGV4dENvbnRlbnQgPSAnQ0NhcHR1cmUgJyArIGMuZm9ybWF0ICsgJyB8ICcgKyBtICsgJyBmcmFtZXMgfCAnICsgZS50b0lTT1N0cmluZygpLnN1YnN0cigxMSwgOCk7XG4gICAgICAgIH0oKSwgUCgnRnJhbWU6ICcgKyBtICsgJyAnICsgZCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoLmxlbmd0aDsgaSsrKSBuID49IGhbaV0udHJpZ2dlclRpbWUgJiYgKEwoaFtpXS5jYWxsYmFjayksIGguc3BsaWNlKGksIDEpKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykgbiA+PSBwW2ldLnRyaWdnZXJUaW1lICYmIChMKHBbaV0uY2FsbGJhY2spLCBwW2ldLnRyaWdnZXJUaW1lICs9IHBbaV0udGltZSk7XG5cbiAgICAgICAgdS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgTCh0LCBuIC0gVyk7XG4gICAgICAgIH0pLCB1ID0gW107XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEEodCkge1xuICAgICAgICB0IHx8ICh0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gTSh0LCBzLmZpbGVuYW1lICsgcy5leHRlbnNpb24sIHMubWltZVR5cGUpLCAhMTtcbiAgICAgICAgfSksIHMuc2F2ZSh0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUCh0KSB7XG4gICAgICAgIGUgJiYgY29uc29sZS5sb2codCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIWZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ob29rZWQgfHwgKHRoaXMuX2hvb2tlZCA9ICEwLCB0aGlzLl9ob29rZWRUaW1lID0gdGhpcy5jdXJyZW50VGltZSB8fCAwLCB0aGlzLnBhdXNlKCksIEIucHVzaCh0aGlzKSksIHRoaXMuX2hvb2tlZFRpbWUgKyBjLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUCgnQ2FwdHVyZXIgc3RhcnQnKSwgbyA9IHdpbmRvdy5EYXRlLm5vdygpLCBuID0gbyArIGMuc3RhcnRUaW1lLCBhID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpLCByID0gYSArIGMuc3RhcnRUaW1lLCB3aW5kb3cuRGF0ZS5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICB9LCB3aW5kb3cuRGF0ZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgfSwgd2luZG93LnNldFRpbWVvdXQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICBlID0gNTAwMDAwMDtcbiAgICAgICAgICAgICAgdmFyIGkgPSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IHQsXG4gICAgICAgICAgICAgICAgdGltZTogZSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVGltZTogbiArIGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIGgucHVzaChpKSwgUCgnVGltZW91dCBzZXQgdG8gJyArIGkudGltZSksIGk7XG4gICAgICAgICAgICB9LCB3aW5kb3cuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBoLmxlbmd0aDsgZSsrKSBoW2VdICE9IHQgfHwgKGguc3BsaWNlKGUsIDEpLCBQKCdUaW1lb3V0IGNsZWFyZWQnKSk7XG4gICAgICAgICAgICB9LCB3aW5kb3cuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICBlID0gNTAwMDAwMDtcbiAgICAgICAgICAgICAgdmFyIGkgPSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IHQsXG4gICAgICAgICAgICAgICAgdGltZTogZSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVGltZTogbiArIGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIHAucHVzaChpKSwgUCgnSW50ZXJ2YWwgc2V0IHRvICcgKyBpLnRpbWUpLCBpO1xuICAgICAgICAgICAgfSwgd2luZG93LmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gUCgnY2xlYXIgSW50ZXJ2YWwnKSwgbnVsbDtcbiAgICAgICAgICAgIH0sIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICB1LnB1c2godCk7XG4gICAgICAgICAgICB9LCB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MVmlkZW9FbGVtZW50LnByb3RvdHlwZSwgJ2N1cnJlbnRUaW1lJywge1xuICAgICAgICAgICAgICAgIGdldDogdFxuICAgICAgICAgICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxBdWRpb0VsZW1lbnQucHJvdG90eXBlLCAnY3VycmVudFRpbWUnLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiB0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICBQKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0oKSwgcy5zdGFydCgpLCBsID0gITA7XG4gICAgICAgIH0sXG4gICAgICAgIGNhcHR1cmU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgbCAmJiAoMiA8IGMubW90aW9uQmx1ckZyYW1lcyA/IChlID0gdCwgdi53aWR0aCA9PT0gZS53aWR0aCAmJiB2LmhlaWdodCA9PT0gZS5oZWlnaHQgfHwgKHYud2lkdGggPSBlLndpZHRoLCB2LmhlaWdodCA9IGUuaGVpZ2h0LCB5ID0gbmV3IFVpbnQxNkFycmF5KHYuaGVpZ2h0ICogdi53aWR0aCAqIDQpLCBiLmZpbGxTdHlsZSA9ICcjMCcsIGIuZmlsbFJlY3QoMCwgMCwgdi53aWR0aCwgdi5oZWlnaHQpKSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGIuZHJhd0ltYWdlKHQsIDAsIDApLCBnID0gYi5nZXRJbWFnZURhdGEoMCwgMCwgdi53aWR0aCwgdi5oZWlnaHQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHkubGVuZ3RoOyBlICs9IDQpIHlbZV0gKz0gZy5kYXRhW2VdLCB5W2UgKyAxXSArPSBnLmRhdGFbZSArIDFdLCB5W2UgKyAyXSArPSBnLmRhdGFbZSArIDJdO1xuXG4gICAgICAgICAgICBkKys7XG4gICAgICAgICAgfSh0KSwgZCA+PSAwLjUgKiBjLm1vdGlvbkJsdXJGcmFtZXMgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gZy5kYXRhLCBlID0gMDsgZSA8IHkubGVuZ3RoOyBlICs9IDQpIHRbZV0gPSAyICogeVtlXSAvIGMubW90aW9uQmx1ckZyYW1lcywgdFtlICsgMV0gPSAyICogeVtlICsgMV0gLyBjLm1vdGlvbkJsdXJGcmFtZXMsIHRbZSArIDJdID0gMiAqIHlbZSArIDJdIC8gYy5tb3Rpb25CbHVyRnJhbWVzO1xuXG4gICAgICAgICAgICBmb3IgKGIucHV0SW1hZ2VEYXRhKGcsIDAsIDApLCBzLmFkZCh2KSwgZCA9IDAsIFAoJ0Z1bGwgTUIgRnJhbWUhICcgKyArK20gKyAnICcgKyBuKSwgZSA9IDA7IGUgPCB5Lmxlbmd0aDsgZSArPSA0KSB5W2VdID0gMCwgeVtlICsgMV0gPSAwLCB5W2UgKyAyXSA9IDA7XG5cbiAgICAgICAgICAgIGdjKCk7XG4gICAgICAgICAgfSgpIDogaSgpKSA6IChzLmFkZCh0KSwgUCgnRnVsbCBGcmFtZSEgJyArICsrbSkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogRSxcbiAgICAgICAgc2F2ZTogQSxcbiAgICAgICAgb246IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgZlt0XSA9IGU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGYucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge30sIGYucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7fSwgZi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCkge30sIGYucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoKSB7fSwgZi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9LCBmLnByb3RvdHlwZS5zYWZlVG9Qcm9jZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIGYucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RlcCBub3Qgc2V0IScpO1xuICAgIH0sICh3LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZi5wcm90b3R5cGUpKS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH0sIHcucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50YXBlLmFwcGVuZChsKHRoaXMuY291bnQpICsgdGhpcy5maWxlRXh0ZW5zaW9uLCBuZXcgVWludDhBcnJheShlLnJlc3VsdCkpLCAwIDwgdGhpcy5zZXR0aW5ncy5hdXRvU2F2ZVRpbWUgJiYgdGhpcy5mcmFtZXMgLyB0aGlzLnNldHRpbmdzLmZyYW1lcmF0ZSA+PSB0aGlzLnNldHRpbmdzLmF1dG9TYXZlVGltZSA/IHRoaXMuc2F2ZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMuZmlsZW5hbWUgPSB0aGlzLmJhc2VGaWxlbmFtZSArICctcGFydC0nICsgbCh0aGlzLnBhcnQpLCBNKHQsIHRoaXMuZmlsZW5hbWUgKyB0aGlzLmV4dGVuc2lvbiwgdGhpcy5taW1lVHlwZSk7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmNvdW50O1xuICAgICAgICAgIHRoaXMuZGlzcG9zZSgpLCB0aGlzLmNvdW50ID0gZSArIDEsIHRoaXMucGFydCsrLCB0aGlzLmZpbGVuYW1lID0gdGhpcy5iYXNlRmlsZW5hbWUgKyAnLXBhcnQtJyArIGwodGhpcy5wYXJ0KSwgdGhpcy5mcmFtZXMgPSAwLCB0aGlzLnN0ZXAoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKSA6ICh0aGlzLmNvdW50KyssIHRoaXMuZnJhbWVzKyssIHRoaXMuc3RlcCgpKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgZS5yZWFkQXNBcnJheUJ1ZmZlcih0KTtcbiAgICB9LCB3LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy50YXBlLnNhdmUoKSk7XG4gICAgfSwgdy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudGFwZSA9IG5ldyBlKCksIHRoaXMuY291bnQgPSAwO1xuICAgIH0sICh6LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUody5wcm90b3R5cGUpKS5hZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdC50b0Jsb2IoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdy5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgdCk7XG4gICAgICB9LmJpbmQodGhpcyksIHRoaXMudHlwZSk7XG4gICAgfSwgKFUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh3LnByb3RvdHlwZSkpLmFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LnRvQmxvYihmdW5jdGlvbiAodCkge1xuICAgICAgICB3LnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCB0KTtcbiAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy50eXBlLCB0aGlzLnF1YWxpdHkpO1xuICAgIH0sIChfLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZi5wcm90b3R5cGUpKS5zdGFydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9LCBfLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy52aWRlb1dyaXRlci5hZGRGcmFtZSh0KSwgMCA8IHRoaXMuc2V0dGluZ3MuYXV0b1NhdmVUaW1lICYmIHRoaXMuZnJhbWVzIC8gdGhpcy5zZXR0aW5ncy5mcmFtZXJhdGUgPj0gdGhpcy5zZXR0aW5ncy5hdXRvU2F2ZVRpbWUgPyB0aGlzLnNhdmUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IHRoaXMuYmFzZUZpbGVuYW1lICsgJy1wYXJ0LScgKyBsKHRoaXMucGFydCksIE0odCwgdGhpcy5maWxlbmFtZSArIHRoaXMuZXh0ZW5zaW9uLCB0aGlzLm1pbWVUeXBlKSwgdGhpcy5kaXNwb3NlKCksIHRoaXMucGFydCsrLCB0aGlzLmZpbGVuYW1lID0gdGhpcy5iYXNlRmlsZW5hbWUgKyAnLXBhcnQtJyArIGwodGhpcy5wYXJ0KSwgdGhpcy5zdGVwKCk7XG4gICAgICB9LmJpbmQodGhpcykpIDogKHRoaXMuZnJhbWVzKyssIHRoaXMuc3RlcCgpKTtcbiAgICB9LCBfLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMudmlkZW9Xcml0ZXIuY29tcGxldGUoKS50aGVuKHQpO1xuICAgIH0sIF8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5mcmFtZXMgPSAwLCB0aGlzLnZpZGVvV3JpdGVyID0gbmV3IG4oe1xuICAgICAgICBxdWFsaXR5OiB0aGlzLnF1YWxpdHksXG4gICAgICAgIGZpbGVXcml0ZXI6IG51bGwsXG4gICAgICAgIGZkOiBudWxsLFxuICAgICAgICBmcmFtZVJhdGU6IHRoaXMuZnJhbWVyYXRlXG4gICAgICB9KTtcbiAgICB9LCAoSC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGYucHJvdG90eXBlKSkuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmVuY29kZXIuc3RhcnQodGhpcy5zZXR0aW5ncyk7XG4gICAgfSwgSC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuZW5jb2Rlci5hZGQodCk7XG4gICAgfSwgSC5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gdCwgdGhpcy5lbmNvZGVyLmVuZCgpO1xuICAgIH0sIEgucHJvdG90eXBlLnNhZmVUb1Byb2NlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGVyLnNhZmVUb1Byb2NlZWQoKTtcbiAgICB9LCAoVi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGYucHJvdG90eXBlKSkuYWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuc3RyZWFtIHx8ICh0aGlzLnN0cmVhbSA9IHQuY2FwdHVyZVN0cmVhbSh0aGlzLmZyYW1lcmF0ZSksIHRoaXMubWVkaWFSZWNvcmRlciA9IG5ldyBNZWRpYVJlY29yZGVyKHRoaXMuc3RyZWFtKSwgdGhpcy5tZWRpYVJlY29yZGVyLnN0YXJ0KCksIHRoaXMubWVkaWFSZWNvcmRlci5vbmRhdGFhdmFpbGFibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHQuZGF0YSk7XG4gICAgICB9LmJpbmQodGhpcykpLCB0aGlzLnN0ZXAoKTtcbiAgICB9LCBWLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHRoaXMubWVkaWFSZWNvcmRlci5vbnN0b3AgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IG5ldyBCbG9iKHRoaXMuY2h1bmtzLCB7XG4gICAgICAgICAgdHlwZTogJ3ZpZGVvL3dlYm0nXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdLCBpKGUpO1xuICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLm1lZGlhUmVjb3JkZXIuc3RvcCgpO1xuICAgIH0sIChHLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZi5wcm90b3R5cGUpKS5hZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5zaXplU2V0IHx8ICh0aGlzLmVuY29kZXIuc2V0T3B0aW9uKCd3aWR0aCcsIHQud2lkdGgpLCB0aGlzLmVuY29kZXIuc2V0T3B0aW9uKCdoZWlnaHQnLCB0LmhlaWdodCksIHRoaXMuc2l6ZVNldCA9ICEwKSwgdGhpcy5jYW52YXMud2lkdGggPSB0LndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0LmhlaWdodCwgdGhpcy5jdHguZHJhd0ltYWdlKHQsIDAsIDApLCB0aGlzLmVuY29kZXIuYWRkRnJhbWUodGhpcy5jdHgsIHtcbiAgICAgICAgY29weTogITAsXG4gICAgICAgIGRlbGF5OiB0aGlzLnNldHRpbmdzLnN0ZXBcbiAgICAgIH0pLCB0aGlzLnN0ZXAoKTtcbiAgICB9LCBHLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSB0LCB0aGlzLmVuY29kZXIucmVuZGVyKCk7XG4gICAgfSwgKG0gfHwgcCB8fCB7fSkuQ0NhcHR1cmUgPSB5LCBhICYmIHMgPyAoYyAmJiAoKHMuZXhwb3J0cyA9IHkpLkNDYXB0dXJlID0geSksIGEuQ0NhcHR1cmUgPSB5KSA6IHUuQ0NhcHR1cmUgPSB5O1xuICB9KCk7XG59KShDQ2FwdHVyZV9taW4kMiwgQ0NhcHR1cmVfbWluJDIuZXhwb3J0cyk7XG5cbnZhciBDQ2FwdHVyZV9taW4gPSBDQ2FwdHVyZV9taW4kMi5leHBvcnRzO1xuXG52YXIgQ0NhcHR1cmVfbWluJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSgvKiNfX1BVUkVfXyovT2JqZWN0LmFzc2lnbigvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKSwgQ0NhcHR1cmVfbWluJDIuZXhwb3J0cywge1xuICAnZGVmYXVsdCc6IENDYXB0dXJlX21pblxufSkpO1xuXG5leHBvcnQgeyBDQ2FwdHVyZV9taW4kMSBhcyBDIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DQ2FwdHVyZS5taW4tMjNmNDUwNGIuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../react-swift/dist/CCapture.min-23f4504b.js\n");

/***/ }),

/***/ "../../react-swift/dist/_commonjsHelpers-1c8beb5f.js":
/*!***********************************************************!*\
  !*** ../../react-swift/dist/_commonjsHelpers-1c8beb5f.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"c\": function() { return /* binding */ commonjsGlobal; }\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\n//# sourceMappingURL=_commonjsHelpers-1c8beb5f.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3JlYWN0LXN3aWZ0L2Rpc3QvX2NvbW1vbmpzSGVscGVycy0xYzhiZWI1Zi5qcz8yZDYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFK0I7QUFDL0IiLCJmaWxlIjoiLi4vLi4vcmVhY3Qtc3dpZnQvZGlzdC9fY29tbW9uanNIZWxwZXJzLTFjOGJlYjVmLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmV4cG9ydCB7IGNvbW1vbmpzR2xvYmFsIGFzIGMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9jb21tb25qc0hlbHBlcnMtMWM4YmViNWYuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../react-swift/dist/_commonjsHelpers-1c8beb5f.js\n");

/***/ })

}]);