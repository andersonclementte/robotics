/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["react-swift_dist_CCapture-d5b23ba0_js"],{

/***/ "../../react-swift/dist/CCapture-d5b23ba0.js":
/*!***************************************************!*\
  !*** ../../react-swift/dist/CCapture-d5b23ba0.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"C\": function() { return /* binding */ CCapture$1; }\n/* harmony export */ });\n/* harmony import */ var _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_commonjsHelpers-1c8beb5f.js */ \"../../react-swift/dist/_commonjsHelpers-1c8beb5f.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../react-swift/node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nvar CCapture$2 = {exports: {}};\n\nvar tar = {exports: {}};\n\n(function (module) {\n\n  (function () {\n\n    var lookup = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'];\n\n    function clean(length) {\n      var i,\n          buffer = new Uint8Array(length);\n\n      for (i = 0; i < length; i += 1) {\n        buffer[i] = 0;\n      }\n\n      return buffer;\n    }\n\n    function extend(orig, length, addLength, multipleOf) {\n      var newSize = length + addLength,\n          buffer = clean((parseInt(newSize / multipleOf) + 1) * multipleOf);\n      buffer.set(orig);\n      return buffer;\n    }\n\n    function pad(num, bytes, base) {\n      num = num.toString(base || 8);\n      return '000000000000'.substr(num.length + 12 - bytes) + num;\n    }\n\n    function stringToUint8(input, out, offset) {\n      var i, length;\n      out = out || clean(input.length);\n      offset = offset || 0;\n\n      for (i = 0, length = input.length; i < length; i += 1) {\n        out[offset] = input.charCodeAt(i);\n        offset += 1;\n      }\n\n      return out;\n    }\n\n    function uint8ToBase64(uint8) {\n      var i,\n          extraBytes = uint8.length % 3,\n          // if we have 1 byte left, pad 2 bytes\n      output = '',\n          temp,\n          length;\n\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3f] + lookup[num >> 12 & 0x3f] + lookup[num >> 6 & 0x3f] + lookup[num & 0x3f];\n      } // go through the array every three bytes, we'll deal with trailing stuff later\n\n\n      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n        output += tripletToBase64(temp);\n      } // this prevents an ERR_INVALID_URL in Chrome (Firefox okay)\n\n\n      switch (output.length % 4) {\n        case 1:\n          output += '=';\n          break;\n\n        case 2:\n          output += '==';\n          break;\n      }\n\n      return output;\n    }\n\n    window.utils = {};\n    window.utils.clean = clean;\n    window.utils.pad = pad;\n    window.utils.extend = extend;\n    window.utils.stringToUint8 = stringToUint8;\n    window.utils.uint8ToBase64 = uint8ToBase64;\n  })();\n\n  (function () {\n    /*\n    struct posix_header {             // byte offset\n    char name[100];               //   0\n    char mode[8];                 // 100\n    char uid[8];                  // 108\n    char gid[8];                  // 116\n    char size[12];                // 124\n    char mtime[12];               // 136\n    char chksum[8];               // 148\n    char typeflag;                // 156\n    char linkname[100];           // 157\n    char magic[6];                // 257\n    char version[2];              // 263\n    char uname[32];               // 265\n    char gname[32];               // 297\n    char devmajor[8];             // 329\n    char devminor[8];             // 337\n    char prefix[155];             // 345\n                                    // 500\n    };\n    */\n\n    var utils = window.utils,\n        headerFormat;\n    headerFormat = [{\n      field: 'fileName',\n      length: 100\n    }, {\n      field: 'fileMode',\n      length: 8\n    }, {\n      field: 'uid',\n      length: 8\n    }, {\n      field: 'gid',\n      length: 8\n    }, {\n      field: 'fileSize',\n      length: 12\n    }, {\n      field: 'mtime',\n      length: 12\n    }, {\n      field: 'checksum',\n      length: 8\n    }, {\n      field: 'type',\n      length: 1\n    }, {\n      field: 'linkName',\n      length: 100\n    }, {\n      field: 'ustar',\n      length: 8\n    }, {\n      field: 'owner',\n      length: 32\n    }, {\n      field: 'group',\n      length: 32\n    }, {\n      field: 'majorNumber',\n      length: 8\n    }, {\n      field: 'minorNumber',\n      length: 8\n    }, {\n      field: 'filenamePrefix',\n      length: 155\n    }, {\n      field: 'padding',\n      length: 12\n    }];\n\n    function formatHeader(data, cb) {\n      var buffer = utils.clean(512),\n          offset = 0;\n      headerFormat.forEach(function (value) {\n        var str = data[value.field] || '',\n            i,\n            length;\n\n        for (i = 0, length = str.length; i < length; i += 1) {\n          buffer[offset] = str.charCodeAt(i);\n          offset += 1;\n        }\n\n        offset += value.length - i; // space it out with nulls\n      });\n\n      if (typeof cb === 'function') {\n        return cb(buffer, offset);\n      }\n\n      return buffer;\n    }\n\n    window.header = {};\n    window.header.structure = headerFormat;\n    window.header.format = formatHeader;\n  })();\n\n  (function () {\n\n    var header = window.header,\n        utils = window.utils,\n        recordSize = 512,\n        blockSize;\n\n    function Tar(recordsPerBlock) {\n      this.written = 0;\n      blockSize = (recordsPerBlock || 20) * recordSize;\n      this.out = utils.clean(blockSize);\n      this.blocks = [];\n      this.length = 0;\n    }\n\n    Tar.prototype.append = function (filepath, input, opts, callback) {\n      var data, checksum, mode, mtime, uid, gid, headerArr;\n\n      if (typeof input === 'string') {\n        input = utils.stringToUint8(input);\n      } else if (input.constructor !== Uint8Array.prototype.constructor) {\n        throw 'Invalid input type. You gave me: ' + input.constructor.toString().match(/function\\s*([$A-Za-z_][0-9A-Za-z_]*)\\s*\\(/)[1];\n      }\n\n      if (typeof opts === 'function') {\n        opts = {};\n      }\n\n      opts = opts || {};\n      mode = opts.mode || parseInt('777', 8) & 0xfff;\n      mtime = opts.mtime || Math.floor(+new Date() / 1000);\n      uid = opts.uid || 0;\n      gid = opts.gid || 0;\n      data = {\n        fileName: filepath,\n        fileMode: utils.pad(mode, 7),\n        uid: utils.pad(uid, 7),\n        gid: utils.pad(gid, 7),\n        fileSize: utils.pad(input.length, 11),\n        mtime: utils.pad(mtime, 11),\n        checksum: '        ',\n        type: '0',\n        // just a file\n        ustar: 'ustar  ',\n        owner: opts.owner || '',\n        group: opts.group || ''\n      }; // calculate the checksum\n\n      checksum = 0;\n      Object.keys(data).forEach(function (key) {\n        var i,\n            value = data[key],\n            length;\n\n        for (i = 0, length = value.length; i < length; i += 1) {\n          checksum += value.charCodeAt(i);\n        }\n      });\n      data.checksum = utils.pad(checksum, 6) + '\\u0000 ';\n      headerArr = header.format(data);\n      var headerLength = Math.ceil(headerArr.length / recordSize) * recordSize;\n      var inputLength = Math.ceil(input.length / recordSize) * recordSize;\n      this.blocks.push({\n        header: headerArr,\n        input: input,\n        headerLength: headerLength,\n        inputLength: inputLength\n      });\n    };\n\n    Tar.prototype.save = function () {\n      var buffers = [];\n      var chunks = [];\n      var length = 0;\n      var max = Math.pow(2, 20);\n      var chunk = [];\n      this.blocks.forEach(function (b) {\n        if (length + b.headerLength + b.inputLength > max) {\n          chunks.push({\n            blocks: chunk,\n            length: length\n          });\n          chunk = [];\n          length = 0;\n        }\n\n        chunk.push(b);\n        length += b.headerLength + b.inputLength;\n      });\n      chunks.push({\n        blocks: chunk,\n        length: length\n      });\n      chunks.forEach(function (c) {\n        var buffer = new Uint8Array(c.length);\n        var written = 0;\n        c.blocks.forEach(function (b) {\n          buffer.set(b.header, written);\n          written += b.headerLength;\n          buffer.set(b.input, written);\n          written += b.inputLength;\n        });\n        buffers.push(buffer);\n      });\n      buffers.push(new Uint8Array(2 * recordSize));\n      return new Blob(buffers, {\n        type: 'octet/stream'\n      });\n    };\n\n    Tar.prototype.clear = function () {\n      this.written = 0;\n      this.out = utils.clean(blockSize);\n    };\n\n    {\n      module.exports = Tar;\n    }\n  })();\n})(tar);\n\nvar download = {exports: {}};\n\n(function (module, exports) {\n\n  (function (root, factory) {\n    {\n      // Node. Does not work with strict CommonJS, but\n      // only CommonJS-like environments that support module.exports,\n      // like Node.\n      module.exports = factory();\n    }\n  })(_commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c, function () {\n    return function download(data, strFileName, strMimeType) {\n      var self = window,\n          // this script is only for browsers anyway...\n      defaultMime = 'application/octet-stream',\n          // this default mime also triggers iframe downloads\n      mimeType = strMimeType || defaultMime,\n          payload = data,\n          url = !strFileName && !strMimeType && payload,\n          anchor = document.createElement('a'),\n          toString = function (a) {\n        return String(a);\n      },\n          myBlob = self.Blob || self.MozBlob || self.WebKitBlob || toString,\n          fileName = strFileName || 'download',\n          blob,\n          reader;\n\n      myBlob = myBlob.call ? myBlob.bind(self) : Blob;\n\n      if (String(this) === 'true') {\n        //reverse arguments, allowing download.bind(true, \"text/xml\", \"export.xml\") to act as a callback\n        payload = [payload, mimeType];\n        mimeType = payload[0];\n        payload = payload[1];\n      }\n\n      if (url && url.length < 2048) {\n        // if no filename and no mime, assume a url was passed as the only argument\n        fileName = url.split('/').pop().split('?')[0];\n        anchor.href = url; // assign href prop to temp anchor\n\n        if (anchor.href.indexOf(url) !== -1) {\n          // if the browser determines that it's a potentially valid url path:\n          var ajax = new XMLHttpRequest();\n          ajax.open('GET', url, true);\n          ajax.responseType = 'blob';\n\n          ajax.onload = function (e) {\n            download(e.target.response, fileName, defaultMime);\n          };\n\n          setTimeout(function () {\n            ajax.send();\n          }, 0); // allows setting custom ajax headers using the return:\n\n          return ajax;\n        } // end if valid url?\n\n      } // end if url?\n      //go ahead and download dataURLs right away\n\n\n      if (/^data:([\\w+-]+\\/[\\w+.-]+)?[,;]/.test(payload)) {\n        if (payload.length > 1024 * 1024 * 1.999 && myBlob !== toString) {\n          payload = dataUrlToBlob(payload);\n          mimeType = payload.type || defaultMime;\n        } else {\n          return navigator.msSaveBlob // IE10 can't do a[download], only Blobs:\n          ? navigator.msSaveBlob(dataUrlToBlob(payload), fileName) : saver(payload); // everyone else can save dataURLs un-processed\n        }\n      } else {\n        //not data url, is it a string with special needs?\n        if (/([\\x80-\\xff])/.test(payload)) {\n          var i = 0,\n              tempUiArr = new Uint8Array(payload.length),\n              mx = tempUiArr.length;\n\n          for (i; i < mx; ++i) tempUiArr[i] = payload.charCodeAt(i);\n\n          payload = new myBlob([tempUiArr], {\n            type: mimeType\n          });\n        }\n      }\n\n      blob = payload instanceof myBlob ? payload : new myBlob([payload], {\n        type: mimeType\n      });\n\n      function dataUrlToBlob(strUrl) {\n        var parts = strUrl.split(/[:;,]/),\n            type = parts[1],\n            indexDecoder = strUrl.indexOf('charset') > 0 ? 3 : 2,\n            decoder = parts[indexDecoder] == 'base64' ? atob : decodeURIComponent,\n            binData = decoder(parts.pop()),\n            mx = binData.length,\n            i = 0,\n            uiArr = new Uint8Array(mx);\n\n        for (i; i < mx; ++i) uiArr[i] = binData.charCodeAt(i);\n\n        return new myBlob([uiArr], {\n          type: type\n        });\n      }\n\n      function saver(url, winMode) {\n        if ('download' in anchor) {\n          //html5 A[download]\n          anchor.href = url;\n          anchor.setAttribute('download', fileName);\n          anchor.className = 'download-js-link';\n          anchor.innerHTML = 'downloading...';\n          anchor.style.display = 'none';\n          anchor.addEventListener('click', function (e) {\n            e.stopPropagation();\n            this.removeEventListener('click', arguments.callee);\n          });\n          document.body.appendChild(anchor);\n          setTimeout(function () {\n            anchor.click();\n            document.body.removeChild(anchor);\n\n            if (winMode === true) {\n              setTimeout(function () {\n                self.URL.revokeObjectURL(anchor.href);\n              }, 250);\n            }\n          }, 66);\n          return true;\n        } // handle non-a[download] safari as best we can:\n\n\n        if (/(Version)\\/(\\d+)\\.(\\d+)(?:\\.(\\d+))?.*Safari\\//.test(navigator.userAgent)) {\n          if (/^data:/.test(url)) url = 'data:' + url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n\n          if (!window.open(url)) {\n            // popup blocked, offer direct download:\n            if (confirm('Displaying New Document\\n\\nUse Save As... to download, then click back to return to this page.')) {\n              location.href = url;\n            }\n          }\n\n          return true;\n        } //do iframe dataURL download (old ch+FF):\n\n\n        var f = document.createElement('iframe');\n        document.body.appendChild(f);\n\n        if (!winMode && /^data:/.test(url)) {\n          // force a mime that will download:\n          url = 'data:' + url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n        }\n\n        f.src = url;\n        setTimeout(function () {\n          document.body.removeChild(f);\n        }, 333);\n      } //end saver\n\n\n      if (navigator.msSaveBlob) {\n        // IE10+ : (has Blob, but not a[download] or URL)\n        return navigator.msSaveBlob(blob, fileName);\n      }\n\n      if (self.URL) {\n        // simple fast and modern way using Blob and URL:\n        saver(self.URL.createObjectURL(blob), true);\n      } else {\n        // handle non-Blob()+non-URL browsers:\n        if (typeof blob === 'string' || blob.constructor === toString) {\n          try {\n            return saver('data:' + mimeType + ';base64,' + self.btoa(blob));\n          } catch (y) {\n            return saver('data:' + mimeType + ',' + encodeURIComponent(blob));\n          }\n        } // Blob but not URL support:\n\n\n        reader = new FileReader();\n\n        reader.onload = function (e) {\n          saver(this.result);\n        };\n\n        reader.readAsDataURL(blob);\n      }\n\n      return true;\n    };\n    /* end download() */\n  });\n})(download);\n\n(function (c) {\n  function a(b, d) {\n    if ({}.hasOwnProperty.call(a.cache, b)) return a.cache[b];\n    var e = a.resolve(b);\n    if (!e) throw new Error('Failed to resolve module ' + b);\n    var c = {\n      id: b,\n      require: a,\n      filename: b,\n      exports: {},\n      loaded: !1,\n      parent: d,\n      children: []\n    };\n    d && d.children.push(c);\n    var f = b.slice(0, b.lastIndexOf('/') + 1);\n    return a.cache[b] = c.exports, e.call(c.exports, c, c.exports, f, b), c.loaded = !0, a.cache[b] = c.exports;\n  }\n  a.modules = {}, a.cache = {}, a.resolve = function (b) {\n    return {}.hasOwnProperty.call(a.modules, b) ? a.modules[b] : void 0;\n  }, a.define = function (b, c) {\n    a.modules[b] = c;\n  };\n\n  var b = function (a) {\n    return a = '/', {\n      title: 'browser',\n      version: 'v0.10.26',\n      browser: !0,\n      env: {},\n      argv: [],\n      nextTick: c.setImmediate || function (a) {\n        setTimeout(a, 0);\n      },\n      cwd: function () {\n        return a;\n      },\n      chdir: function (b) {\n        a = b;\n      }\n    };\n  }();\n\n  a.define('/gif.coffee', function (d, m, l, k) {\n    function g(a, b) {\n      return {}.hasOwnProperty.call(a, b);\n    }\n\n    function j(d, b) {\n      for (var a = 0, c = b.length; a < c; ++a) if (a in b && b[a] === d) return !0;\n\n      return !1;\n    }\n\n    function i(a, b) {\n      function d() {\n        this.constructor = a;\n      }\n\n      for (var c in b) g(b, c) && (a[c] = b[c]);\n\n      return d.prototype = b.prototype, a.prototype = new d(), a.__super__ = b.prototype, a;\n    }\n\n    var h, c, f, b, e;\n    f = a('events', d).EventEmitter, h = a('/browser.coffee', d), e = function (d) {\n      function a(d) {\n        var a, b;\n        this.running = !1, this.options = {}, this.frames = [], this.freeWorkers = [], this.activeWorkers = [], this.setOptions(d);\n\n        for (a in c) b = c[a], null != this.options[a] ? this.options[a] : this.options[a] = b;\n      }\n\n      return i(a, d), c = {\n        workerScript: 'gif.worker.js',\n        workers: 2,\n        repeat: 0,\n        background: '#fff',\n        quality: 10,\n        width: null,\n        height: null,\n        transparent: null\n      }, b = {\n        delay: 500,\n        copy: !1\n      }, a.prototype.setOption = function (a, b) {\n        return this.options[a] = b, null != this._canvas && (a === 'width' || a === 'height') ? this._canvas[a] = b : void 0;\n      }, a.prototype.setOptions = function (b) {\n        var a, c;\n        return function (d) {\n          for (a in b) {\n            if (!g(b, a)) continue;\n            c = b[a], d.push(this.setOption(a, c));\n          }\n\n          return d;\n        }.call(this, []);\n      }, a.prototype.addFrame = function (a, d) {\n        var c, e;\n        null == d && (d = {}), c = {}, c.transparent = this.options.transparent;\n\n        for (e in b) c[e] = d[e] || b[e];\n\n        if (null != this.options.width || this.setOption('width', a.width), null != this.options.height || this.setOption('height', a.height), 'undefined' !== typeof ImageData && null != ImageData && a instanceof ImageData) c.data = a.data;else if ('undefined' !== typeof CanvasRenderingContext2D && null != CanvasRenderingContext2D && a instanceof CanvasRenderingContext2D || 'undefined' !== typeof WebGLRenderingContext && null != WebGLRenderingContext && a instanceof WebGLRenderingContext) d.copy ? c.data = this.getContextData(a) : c.context = a;else if (null != a.childNodes) d.copy ? c.data = this.getImageData(a) : c.image = a;else throw new Error('Invalid image');\n        return this.frames.push(c);\n      }, a.prototype.render = function () {\n        var a;\n        if (this.running) throw new Error('Already running');\n        if (!(null != this.options.width && null != this.options.height)) throw new Error('Width and height must be set prior to rendering');\n        this.running = !0, this.nextFrame = 0, this.finishedFrames = 0, this.imageParts = function (c) {\n          for (var b = function () {\n            var b;\n            b = [];\n\n            for (var a = 0; 0 <= this.frames.length ? a < this.frames.length : a > this.frames.length; 0 <= this.frames.length ? ++a : --a) b.push(a);\n\n            return b;\n          }.apply(this, arguments), a = 0, e = b.length; a < e; ++a) c.push(null);\n\n          return c;\n        }.call(this, []), a = this.spawnWorkers();\n\n        for (var c = function () {\n          var c;\n          c = [];\n\n          for (var b = 0; 0 <= a ? b < a : b > a; 0 <= a ? ++b : --b) c.push(b);\n\n          return c;\n        }.apply(this, arguments), b = 0, e = c.length; b < e; ++b) this.renderNextFrame();\n\n        return this.emit('start'), this.emit('progress', 0);\n      }, a.prototype.abort = function () {\n        var a;\n\n        while (!0) {\n          if (a = this.activeWorkers.shift(), !(null != a)) break;\n          console.log('killing active worker'), a.terminate();\n        }\n\n        return this.running = !1, this.emit('abort');\n      }, a.prototype.spawnWorkers = function () {\n        var a;\n        return a = Math.min(this.options.workers, this.frames.length), function () {\n          var c;\n          c = [];\n\n          for (var b = this.freeWorkers.length; this.freeWorkers.length <= a ? b < a : b > a; this.freeWorkers.length <= a ? ++b : --b) c.push(b);\n\n          return c;\n        }.apply(this, arguments).forEach(function (a) {\n          return function (c) {\n            var b;\n            return console.log('spawning worker ' + c), b = new Worker(a.options.workerScript), b.onmessage = function (a) {\n              return function (c) {\n                return a.activeWorkers.splice(a.activeWorkers.indexOf(b), 1), a.freeWorkers.push(b), a.frameFinished(c.data);\n              };\n            }(a), a.freeWorkers.push(b);\n          };\n        }(this)), a;\n      }, a.prototype.frameFinished = function (a) {\n        return console.log('frame ' + a.index + ' finished - ' + this.activeWorkers.length + ' active'), this.finishedFrames++, this.emit('progress', this.finishedFrames / this.frames.length), this.imageParts[a.index] = a, j(null, this.imageParts) ? this.renderNextFrame() : this.finishRendering();\n      }, a.prototype.finishRendering = function () {\n        var e, a, k, m, b, d, h;\n        b = 0;\n\n        for (var f = 0, j = this.imageParts.length; f < j; ++f) a = this.imageParts[f], b += (a.data.length - 1) * a.pageSize + a.cursor;\n\n        b += a.pageSize - a.cursor, console.log('rendering finished - filesize ' + Math.round(b / 1e3) + 'kb'), e = new Uint8Array(b), d = 0;\n\n        for (var g = 0, l = this.imageParts.length; g < l; ++g) {\n          a = this.imageParts[g];\n\n          for (var c = 0, i = a.data.length; c < i; ++c) h = a.data[c], k = c, e.set(h, d), k === a.data.length - 1 ? d += a.cursor : d += a.pageSize;\n        }\n\n        return m = new Blob([e], {\n          type: 'image/gif'\n        }), this.emit('finished', m, e);\n      }, a.prototype.renderNextFrame = function () {\n        var c, a, b;\n        if (this.freeWorkers.length === 0) throw new Error('No free workers');\n        return this.nextFrame >= this.frames.length ? void 0 : (c = this.frames[this.nextFrame++], b = this.freeWorkers.shift(), a = this.getTask(c), console.log('starting frame ' + (a.index + 1) + ' of ' + this.frames.length), this.activeWorkers.push(b), b.postMessage(a));\n      }, a.prototype.getContextData = function (a) {\n        return a.getImageData(0, 0, this.options.width, this.options.height).data;\n      }, a.prototype.getImageData = function (b) {\n        var a;\n        return null != this._canvas || (this._canvas = document.createElement('canvas'), this._canvas.width = this.options.width, this._canvas.height = this.options.height), a = this._canvas.getContext('2d'), a.setFill = this.options.background, a.fillRect(0, 0, this.options.width, this.options.height), a.drawImage(b, 0, 0), this.getContextData(a);\n      }, a.prototype.getTask = function (a) {\n        var c, b;\n        if (c = this.frames.indexOf(a), b = {\n          index: c,\n          last: c === this.frames.length - 1,\n          delay: a.delay,\n          transparent: a.transparent,\n          width: this.options.width,\n          height: this.options.height,\n          quality: this.options.quality,\n          repeat: this.options.repeat,\n          canTransfer: h.name === 'chrome'\n        }, null != a.data) b.data = a.data;else if (null != a.context) b.data = this.getContextData(a.context);else if (null != a.image) b.data = this.getImageData(a.image);else throw new Error('Invalid frame');\n        return b;\n      }, a;\n    }(f), d.exports = e;\n  }), a.define('/browser.coffee', function (f, g, h, i) {\n    var a, d, e, c, b;\n    c = navigator.userAgent.toLowerCase(), e = navigator.platform.toLowerCase(), b = c.match(/(opera|ie|firefox|chrome|version)[\\s\\/:]([\\w\\d\\.]+)?.*?(safari|version[\\s\\/:]([\\w\\d\\.]+)|$)/) || [null, 'unknown', 0], d = b[1] === 'ie' && document.documentMode, a = {\n      name: b[1] === 'version' ? b[3] : b[1],\n      version: d || parseFloat(b[1] === 'opera' && b[4] ? b[4] : b[2]),\n      platform: {\n        name: c.match(/ip(?:ad|od|hone)/) ? 'ios' : (c.match(/(?:webos|android)/) || e.match(/mac|win|linux/) || ['other'])[0]\n      }\n    }, a[a.name] = !0, a[a.name + parseInt(a.version, 10)] = !0, a.platform[a.platform.name] = !0, f.exports = a;\n  }), a.define('events', function (f, e, g, h) {\n    b.EventEmitter || (b.EventEmitter = function () {});\n    var a = e.EventEmitter = b.EventEmitter,\n        c = typeof Array.isArray === 'function' ? Array.isArray : function (a) {\n      return Object.prototype.toString.call(a) === '[object Array]';\n    },\n        d = 10;\n    a.prototype.setMaxListeners = function (a) {\n      this._events || (this._events = {}), this._events.maxListeners = a;\n    }, a.prototype.emit = function (f) {\n      if (f === 'error' && (!(this._events && this._events.error) || c(this._events.error) && !this._events.error.length)) throw arguments[1] instanceof Error ? arguments[1] : new Error(\"Uncaught, unspecified 'error' event.\");\n      if (!this._events) return !1;\n      var a = this._events[f];\n      if (!a) return !1;\n      if (!(typeof a == 'function')) if (c(a)) {\n        var b = Array.prototype.slice.call(arguments, 1),\n            e = a.slice();\n\n        for (var d = 0, g = e.length; d < g; d++) e[d].apply(this, b);\n\n        return !0;\n      } else return !1;\n\n      switch (arguments.length) {\n        case 1:\n          a.call(this);\n          break;\n\n        case 2:\n          a.call(this, arguments[1]);\n          break;\n\n        case 3:\n          a.call(this, arguments[1], arguments[2]);\n          break;\n\n        default:\n          var b = Array.prototype.slice.call(arguments, 1);\n          a.apply(this, b);\n      }\n\n      return !0;\n    }, a.prototype.addListener = function (a, b) {\n      if ('function' !== typeof b) throw new Error('addListener only takes instances of Function');\n      if (this._events || (this._events = {}), this.emit('newListener', a, b), !this._events[a]) this._events[a] = b;else if (c(this._events[a])) {\n        if (!this._events[a].warned) {\n          var e;\n          this._events.maxListeners !== undefined ? e = this._events.maxListeners : e = d, e && e > 0 && this._events[a].length > e && (this._events[a].warned = !0, console.error('(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.', this._events[a].length), console.trace());\n        }\n\n        this._events[a].push(b);\n      } else this._events[a] = [this._events[a], b];\n      return this;\n    }, a.prototype.on = a.prototype.addListener, a.prototype.once = function (b, c) {\n      var a = this;\n      return a.on(b, function d() {\n        a.removeListener(b, d), c.apply(this, arguments);\n      }), this;\n    }, a.prototype.removeListener = function (a, d) {\n      if ('function' !== typeof d) throw new Error('removeListener only takes instances of Function');\n      if (!(this._events && this._events[a])) return this;\n      var b = this._events[a];\n\n      if (c(b)) {\n        var e = b.indexOf(d);\n        if (e < 0) return this;\n        b.splice(e, 1), b.length == 0 && delete this._events[a];\n      } else this._events[a] === d && delete this._events[a];\n\n      return this;\n    }, a.prototype.removeAllListeners = function (a) {\n      return a && this._events && this._events[a] && (this._events[a] = null), this;\n    }, a.prototype.listeners = function (a) {\n      return this._events || (this._events = {}), this._events[a] || (this._events[a] = []), c(this._events[a]) || (this._events[a] = [this._events[a]]), this._events[a];\n    };\n  }), c.GIF = a('/gif.coffee');\n}).call(_commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c, _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c); // gif.js 0.1.6 - https://github.com/jnordberg/gif.js\n\nvar webmWriter0_2_0 = {exports: {}};\n\n/**\n * A tool for presenting an ArrayBuffer as a stream for writing some simple data types.\n *\n * By Nicholas Sherlock\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n(function (module) {\n\n  (function () {\n    var isNodeEnviroment = 'object' !== 'undefined';\n    var isNodeEnviroment = false;\n    /**\n     * Create an ArrayBuffer of the given length and present it as a writable stream with methods\n     * for writing data in different formats.\n     */\n\n    var ArrayBufferDataStream = function (length) {\n      this.data = new Uint8Array(length);\n      this.pos = 0;\n    };\n\n    ArrayBufferDataStream.prototype.seek = function (offset) {\n      this.pos = offset;\n    };\n\n    ArrayBufferDataStream.prototype.writeBytes = function (arr) {\n      for (var i = 0; i < arr.length; i++) {\n        this.data[this.pos++] = arr[i];\n      }\n    };\n\n    ArrayBufferDataStream.prototype.writeByte = function (b) {\n      this.data[this.pos++] = b;\n    }; //Synonym:\n\n\n    ArrayBufferDataStream.prototype.writeU8 = ArrayBufferDataStream.prototype.writeByte;\n\n    ArrayBufferDataStream.prototype.writeU16BE = function (u) {\n      this.data[this.pos++] = u >> 8;\n      this.data[this.pos++] = u;\n    };\n\n    ArrayBufferDataStream.prototype.writeDoubleBE = function (d) {\n      var bytes = new Uint8Array(new Float64Array([d]).buffer);\n\n      for (var i = bytes.length - 1; i >= 0; i--) {\n        this.writeByte(bytes[i]);\n      }\n    };\n\n    ArrayBufferDataStream.prototype.writeFloatBE = function (d) {\n      var bytes = new Uint8Array(new Float32Array([d]).buffer);\n\n      for (var i = bytes.length - 1; i >= 0; i--) {\n        this.writeByte(bytes[i]);\n      }\n    };\n    /**\n     * Write an ASCII string to the stream\n     */\n\n\n    ArrayBufferDataStream.prototype.writeString = function (s) {\n      for (var i = 0; i < s.length; i++) {\n        this.data[this.pos++] = s.charCodeAt(i);\n      }\n    };\n    /**\n     * Write the given 32-bit integer to the stream as an EBML variable-length integer using the given byte width\n     * (use measureEBMLVarInt).\n     *\n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     *\n     * @param i Integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n\n\n    ArrayBufferDataStream.prototype.writeEBMLVarIntWidth = function (i, width) {\n      switch (width) {\n        case 1:\n          this.writeU8(1 << 7 | i);\n          break;\n\n        case 2:\n          this.writeU8(1 << 6 | i >> 8);\n          this.writeU8(i);\n          break;\n\n        case 3:\n          this.writeU8(1 << 5 | i >> 16);\n          this.writeU8(i >> 8);\n          this.writeU8(i);\n          break;\n\n        case 4:\n          this.writeU8(1 << 4 | i >> 24);\n          this.writeU8(i >> 16);\n          this.writeU8(i >> 8);\n          this.writeU8(i);\n          break;\n\n        case 5:\n          /*\n           * JavaScript converts its doubles to 32-bit integers for bitwise operations, so we need to do a\n           * division by 2^32 instead of a right-shift of 32 to retain those top 3 bits\n           */\n          this.writeU8(1 << 3 | i / 4294967296 & 0x7);\n          this.writeU8(i >> 24);\n          this.writeU8(i >> 16);\n          this.writeU8(i >> 8);\n          this.writeU8(i);\n          break;\n\n        default:\n          throw new RuntimeException('Bad EBML VINT size ' + width);\n      }\n    };\n    /**\n     * Return the number of bytes needed to encode the given integer as an EBML VINT.\n     */\n\n\n    ArrayBufferDataStream.prototype.measureEBMLVarInt = function (val) {\n      if (val < (1 << 7) - 1) {\n        /* Top bit is set, leaving 7 bits to hold the integer, but we can't store 127 because\n         * \"all bits set to one\" is a reserved value. Same thing for the other cases below:\n         */\n        return 1;\n      } else if (val < (1 << 14) - 1) {\n        return 2;\n      } else if (val < (1 << 21) - 1) {\n        return 3;\n      } else if (val < (1 << 28) - 1) {\n        return 4;\n      } else if (val < 34359738367) {\n        // 2 ^ 35 - 1 (can address 32GB)\n        return 5;\n      } else {\n        throw new RuntimeException('EBML VINT size not supported ' + val);\n      }\n    };\n\n    ArrayBufferDataStream.prototype.writeEBMLVarInt = function (i) {\n      this.writeEBMLVarIntWidth(i, this.measureEBMLVarInt(i));\n    };\n    /**\n     * Write the given unsigned 32-bit integer to the stream in big-endian order using the given byte width.\n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     *\n     * Omit the width parameter to have it determined automatically for you.\n     *\n     * @param u Unsigned integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n\n\n    ArrayBufferDataStream.prototype.writeUnsignedIntBE = function (u, width) {\n      if (width === undefined) {\n        width = this.measureUnsignedInt(u);\n      } // Each case falls through:\n\n\n      switch (width) {\n        case 5:\n          this.writeU8(Math.floor(u / 4294967296));\n        // Need to use division to access >32 bits of floating point var\n\n        case 4:\n          this.writeU8(u >> 24);\n\n        case 3:\n          this.writeU8(u >> 16);\n\n        case 2:\n          this.writeU8(u >> 8);\n\n        case 1:\n          this.writeU8(u);\n          break;\n\n        default:\n          throw new RuntimeException('Bad UINT size ' + width);\n      }\n    };\n    /**\n     * Return the number of bytes needed to hold the non-zero bits of the given unsigned integer.\n     */\n\n\n    ArrayBufferDataStream.prototype.measureUnsignedInt = function (val) {\n      // Force to 32-bit unsigned integer\n      if (val < 1 << 8) {\n        return 1;\n      } else if (val < 1 << 16) {\n        return 2;\n      } else if (val < 1 << 24) {\n        return 3;\n      } else if (val < 4294967296) {\n        return 4;\n      } else {\n        return 5;\n      }\n    };\n    /**\n     * Return a view on the portion of the buffer from the beginning to the current seek position as a Uint8Array.\n     */\n\n\n    ArrayBufferDataStream.prototype.getAsDataArray = function () {\n      if (this.pos < this.data.byteLength) {\n        return this.data.subarray(0, this.pos);\n      } else if (this.pos == this.data.byteLength) {\n        return this.data;\n      } else {\n        throw \"ArrayBufferDataStream's pos lies beyond end of buffer\";\n      }\n    };\n\n    window.ArrayBufferDataStream = ArrayBufferDataStream;\n    /**\n     * Allows a series of Blob-convertible objects (ArrayBuffer, Blob, String, etc) to be added to a buffer. Seeking and\n     * overwriting of blobs is allowed.\n     *\n     * You can supply a FileWriter, in which case the BlobBuffer is just used as temporary storage before it writes it\n     * through to the disk.\n     *\n     * By Nicholas Sherlock\n     *\n     * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n     */\n\n    var BlobBuffer = function (fs) {\n      return function (destination) {\n        var buffer = [],\n            writePromise = Promise.resolve(),\n            fileWriter = null,\n            fd = null;\n\n        if (typeof FileWriter !== 'undefined' && destination instanceof FileWriter) {\n          fileWriter = destination;\n        } else if (fs && destination) {\n          fd = destination;\n        } // Current seek offset\n\n\n        this.pos = 0; // One more than the index of the highest byte ever written\n\n        this.length = 0; // Returns a promise that converts the blob to an ArrayBuffer\n\n        function readBlobAsBuffer(blob) {\n          return new Promise(function (resolve, reject) {\n            var reader = new FileReader();\n            reader.addEventListener('loadend', function () {\n              resolve(reader.result);\n            });\n            reader.readAsArrayBuffer(blob);\n          });\n        }\n\n        function convertToUint8Array(thing) {\n          return new Promise(function (resolve, reject) {\n            if (thing instanceof Uint8Array) {\n              resolve(thing);\n            } else if (thing instanceof ArrayBuffer || ArrayBuffer.isView(thing)) {\n              resolve(new Uint8Array(thing));\n            } else if (thing instanceof Blob) {\n              resolve(readBlobAsBuffer(thing).then(function (buffer) {\n                return new Uint8Array(buffer);\n              }));\n            } else {\n              //Assume that Blob will know how to read this thing\n              resolve(readBlobAsBuffer(new Blob([thing])).then(function (buffer) {\n                return new Uint8Array(buffer);\n              }));\n            }\n          });\n        }\n\n        function measureData(data) {\n          var result = data.byteLength || data.length || data.size;\n\n          if (!Number.isInteger(result)) {\n            throw 'Failed to determine size of element';\n          }\n\n          return result;\n        }\n        /**\n         * Seek to the given absolute offset.\n         *\n         * You may not seek beyond the end of the file (this would create a hole and/or allow blocks to be written in non-\n         * sequential order, which isn't currently supported by the memory buffer backend).\n         */\n\n\n        this.seek = function (offset) {\n          if (offset < 0) {\n            throw 'Offset may not be negative';\n          }\n\n          if (isNaN(offset)) {\n            throw 'Offset may not be NaN';\n          }\n\n          if (offset > this.length) {\n            throw 'Seeking beyond the end of file is not allowed';\n          }\n\n          this.pos = offset;\n        };\n        /**\n         * Write the Blob-convertible data to the buffer at the current seek position.\n         *\n         * Note: If overwriting existing data, the write must not cross preexisting block boundaries (written data must\n         * be fully contained by the extent of a previous write).\n         */\n\n\n        this.write = function (data) {\n          var newEntry = {\n            offset: this.pos,\n            data: data,\n            length: measureData(data)\n          },\n              isAppend = newEntry.offset >= this.length;\n          this.pos += newEntry.length;\n          this.length = Math.max(this.length, this.pos); // After previous writes complete, perform our write\n\n          writePromise = writePromise.then(function () {\n            if (fd) {\n              return new Promise(function (resolve, reject) {\n                convertToUint8Array(newEntry.data).then(function (dataArray) {\n                  var totalWritten = 0,\n                      buffer = Buffer.from(dataArray.buffer),\n                      handleWriteComplete = function (err, written, buffer) {\n                    totalWritten += written;\n\n                    if (totalWritten >= buffer.length) {\n                      resolve();\n                    } else {\n                      // We still have more to write...\n                      fs.write(fd, buffer, totalWritten, buffer.length - totalWritten, newEntry.offset + totalWritten, handleWriteComplete);\n                    }\n                  };\n\n                  fs.write(fd, buffer, 0, buffer.length, newEntry.offset, handleWriteComplete);\n                });\n              });\n            } else if (fileWriter) {\n              return new Promise(function (resolve, reject) {\n                fileWriter.onwriteend = resolve;\n                fileWriter.seek(newEntry.offset);\n                fileWriter.write(new Blob([newEntry.data]));\n              });\n            } else if (!isAppend) {\n              // We might be modifying a write that was already buffered in memory.\n              // Slow linear search to find a block we might be overwriting\n              for (var i = 0; i < buffer.length; i++) {\n                var entry = buffer[i]; // If our new entry overlaps the old one in any way...\n\n                if (!(newEntry.offset + newEntry.length <= entry.offset || newEntry.offset >= entry.offset + entry.length)) {\n                  if (newEntry.offset < entry.offset || newEntry.offset + newEntry.length > entry.offset + entry.length) {\n                    throw new Error('Overwrite crosses blob boundaries');\n                  }\n\n                  if (newEntry.offset == entry.offset && newEntry.length == entry.length) {\n                    // We overwrote the entire block\n                    entry.data = newEntry.data; // We're done\n\n                    return;\n                  } else {\n                    return convertToUint8Array(entry.data).then(function (entryArray) {\n                      entry.data = entryArray;\n                      return convertToUint8Array(newEntry.data);\n                    }).then(function (newEntryArray) {\n                      newEntry.data = newEntryArray;\n                      entry.data.set(newEntry.data, newEntry.offset - entry.offset);\n                    });\n                  }\n                }\n              } // Else fall through to do a simple append, as we didn't overwrite any pre-existing blocks\n\n            }\n\n            buffer.push(newEntry);\n          });\n        };\n        /**\n         * Finish all writes to the buffer, returning a promise that signals when that is complete.\n         *\n         * If a FileWriter was not provided, the promise is resolved with a Blob that represents the completed BlobBuffer\n         * contents. You can optionally pass in a mimeType to be used for this blob.\n         *\n         * If a FileWriter was provided, the promise is resolved with null as the first argument.\n         */\n\n\n        this.complete = function (mimeType) {\n          if (fd || fileWriter) {\n            writePromise = writePromise.then(function () {\n              return null;\n            });\n          } else {\n            // After writes complete we need to merge the buffer to give to the caller\n            writePromise = writePromise.then(function () {\n              var result = [];\n\n              for (var i = 0; i < buffer.length; i++) {\n                result.push(buffer[i].data);\n              }\n\n              return new Blob(result, {\n                mimeType: mimeType\n              });\n            });\n          }\n\n          return writePromise;\n        };\n      };\n    }(isNodeEnviroment ? null : null);\n\n    window.BlobBuffer = BlobBuffer;\n    /**\n     * WebM video encoder for Google Chrome. This implementation is suitable for creating very large video files, because\n     * it can stream Blobs directly to a FileWriter without buffering the entire video in memory.\n     *\n     * When FileWriter is not available or not desired, it can buffer the video in memory as a series of Blobs which are\n     * eventually returned as one composite Blob.\n     *\n     * By Nicholas Sherlock.\n     *\n     * Based on the ideas from Whammy: https://github.com/antimatter15/whammy\n     *\n     * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n     */\n\n    var WebMWriter = function (ArrayBufferDataStream, BlobBuffer) {\n      function extend(base, top) {\n        var target = {};\n        [base, top].forEach(function (obj) {\n          for (var prop in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n              target[prop] = obj[prop];\n            }\n          }\n        });\n        return target;\n      }\n      /**\n       * Decode a Base64 data URL into a binary string.\n       *\n       * Returns the binary string, or false if the URL could not be decoded.\n       */\n\n\n      function decodeBase64WebPDataURL(url) {\n        if (typeof url !== 'string' || !url.match(/^data:image\\/webp;base64,/i)) {\n          return false;\n        }\n\n        return window.atob(url.substring('data:image/webp;base64,'.length));\n      }\n      /**\n       * Convert the given canvas to a WebP encoded image and return the image data as a string.\n       */\n\n\n      function renderAsWebP(canvas, quality) {\n        var frame = canvas.toDataURL('image/webp', {\n          quality: quality\n        });\n        return decodeBase64WebPDataURL(frame);\n      }\n\n      function extractKeyframeFromWebP(webP) {\n        // Assume that Chrome will generate a Simple Lossy WebP which has this header:\n        var keyframeStartIndex = webP.indexOf('VP8 ');\n\n        if (keyframeStartIndex == -1) {\n          throw 'Failed to identify beginning of keyframe in WebP image';\n        } // Skip the header and the 4 bytes that encode the length of the VP8 chunk\n\n\n        keyframeStartIndex += 'VP8 '.length + 4;\n        return webP.substring(keyframeStartIndex);\n      } // Just a little utility so we can tag values as floats for the EBML encoder's benefit\n\n\n      function EBMLFloat32(value) {\n        this.value = value;\n      }\n\n      function EBMLFloat64(value) {\n        this.value = value;\n      }\n      /**\n       * Write the given EBML object to the provided ArrayBufferStream.\n       *\n       * The buffer's first byte is at bufferFileOffset inside the video file. This is used to complete offset and\n       * dataOffset fields in each EBML structure, indicating the file offset of the first byte of the EBML element and\n       * its data payload.\n       */\n\n\n      function writeEBML(buffer, bufferFileOffset, ebml) {\n        // Is the ebml an array of sibling elements?\n        if (Array.isArray(ebml)) {\n          for (var i = 0; i < ebml.length; i++) {\n            writeEBML(buffer, bufferFileOffset, ebml[i]);\n          } // Is this some sort of raw data that we want to write directly?\n\n        } else if (typeof ebml === 'string') {\n          buffer.writeString(ebml);\n        } else if (ebml instanceof Uint8Array) {\n          buffer.writeBytes(ebml);\n        } else if (ebml.id) {\n          // We're writing an EBML element\n          ebml.offset = buffer.pos + bufferFileOffset;\n          buffer.writeUnsignedIntBE(ebml.id); // ID field\n          // Now we need to write the size field, so we must know the payload size:\n\n          if (Array.isArray(ebml.data)) {\n            // Writing an array of child elements. We won't try to measure the size of the children up-front\n            var sizePos, dataBegin, dataEnd;\n\n            if (ebml.size === -1) {\n              // Write the reserved all-one-bits marker to note that the size of this element is unknown/unbounded\n              buffer.writeByte(0xff);\n            } else {\n              sizePos = buffer.pos;\n              /* Write a dummy size field to overwrite later. 4 bytes allows an element maximum size of 256MB,\n               * which should be plenty (we don't want to have to buffer that much data in memory at one time\n               * anyway!)\n               */\n\n              buffer.writeBytes([0, 0, 0, 0]);\n            }\n\n            dataBegin = buffer.pos;\n            ebml.dataOffset = dataBegin + bufferFileOffset;\n            writeEBML(buffer, bufferFileOffset, ebml.data);\n\n            if (ebml.size !== -1) {\n              dataEnd = buffer.pos;\n              ebml.size = dataEnd - dataBegin;\n              buffer.seek(sizePos);\n              buffer.writeEBMLVarIntWidth(ebml.size, 4); // Size field\n\n              buffer.seek(dataEnd);\n            }\n          } else if (typeof ebml.data === 'string') {\n            buffer.writeEBMLVarInt(ebml.data.length); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeString(ebml.data);\n          } else if (typeof ebml.data === 'number') {\n            // Allow the caller to explicitly choose the size if they wish by supplying a size field\n            if (!ebml.size) {\n              ebml.size = buffer.measureUnsignedInt(ebml.data);\n            }\n\n            buffer.writeEBMLVarInt(ebml.size); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeUnsignedIntBE(ebml.data, ebml.size);\n          } else if (ebml.data instanceof EBMLFloat64) {\n            buffer.writeEBMLVarInt(8); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeDoubleBE(ebml.data.value);\n          } else if (ebml.data instanceof EBMLFloat32) {\n            buffer.writeEBMLVarInt(4); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeFloatBE(ebml.data.value);\n          } else if (ebml.data instanceof Uint8Array) {\n            buffer.writeEBMLVarInt(ebml.data.byteLength); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeBytes(ebml.data);\n          } else {\n            throw 'Bad EBML datatype ' + typeof ebml.data;\n          }\n        } else {\n          throw 'Bad EBML datatype ' + typeof ebml.data;\n        }\n      }\n\n      return function (options) {\n        var MAX_CLUSTER_DURATION_MSEC = 5000,\n            DEFAULT_TRACK_NUMBER = 1,\n            writtenHeader = false,\n            videoWidth,\n            videoHeight,\n            clusterFrameBuffer = [],\n            clusterStartTime = 0,\n            clusterDuration = 0,\n            optionDefaults = {\n          quality: 0.95,\n          // WebM image quality from 0.0 (worst) to 1.0 (best)\n          fileWriter: null,\n          // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)\n          fd: null,\n          // Node.JS file descriptor to write to instead of buffering (optional)\n          // You must supply one of:\n          frameDuration: null,\n          // Duration of frames in milliseconds\n          frameRate: null // Number of frames per second\n\n        },\n            seekPoints = {\n          Cues: {\n            id: new Uint8Array([0x1c, 0x53, 0xbb, 0x6b]),\n            positionEBML: null\n          },\n          SegmentInfo: {\n            id: new Uint8Array([0x15, 0x49, 0xa9, 0x66]),\n            positionEBML: null\n          },\n          Tracks: {\n            id: new Uint8Array([0x16, 0x54, 0xae, 0x6b]),\n            positionEBML: null\n          }\n        },\n            ebmlSegment,\n            segmentDuration = {\n          id: 0x4489,\n          // Duration\n          data: new EBMLFloat64(0)\n        },\n            seekHead,\n            cues = [],\n            blobBuffer = new BlobBuffer(options.fileWriter || options.fd);\n\n        function fileOffsetToSegmentRelative(fileOffset) {\n          return fileOffset - ebmlSegment.dataOffset;\n        }\n        /**\n         * Create a SeekHead element with descriptors for the points in the global seekPoints array.\n         *\n         * 5 bytes of position values are reserved for each node, which lie at the offset point.positionEBML.dataOffset,\n         * to be overwritten later.\n         */\n\n\n        function createSeekHead() {\n          var seekPositionEBMLTemplate = {\n            id: 0x53ac,\n            // SeekPosition\n            size: 5,\n            // Allows for 32GB video files\n            data: 0 // We'll overwrite this when the file is complete\n\n          },\n              result = {\n            id: 0x114d9b74,\n            // SeekHead\n            data: []\n          };\n\n          for (var name in seekPoints) {\n            var seekPoint = seekPoints[name];\n            seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);\n            result.data.push({\n              id: 0x4dbb,\n              // Seek\n              data: [{\n                id: 0x53ab,\n                // SeekID\n                data: seekPoint.id\n              }, seekPoint.positionEBML]\n            });\n          }\n\n          return result;\n        }\n        /**\n         * Write the WebM file header to the stream.\n         */\n\n\n        function writeHeader() {\n          seekHead = createSeekHead();\n          var ebmlHeader = {\n            id: 0x1a45dfa3,\n            // EBML\n            data: [{\n              id: 0x4286,\n              // EBMLVersion\n              data: 1\n            }, {\n              id: 0x42f7,\n              // EBMLReadVersion\n              data: 1\n            }, {\n              id: 0x42f2,\n              // EBMLMaxIDLength\n              data: 4\n            }, {\n              id: 0x42f3,\n              // EBMLMaxSizeLength\n              data: 8\n            }, {\n              id: 0x4282,\n              // DocType\n              data: 'webm'\n            }, {\n              id: 0x4287,\n              // DocTypeVersion\n              data: 2\n            }, {\n              id: 0x4285,\n              // DocTypeReadVersion\n              data: 2\n            }]\n          },\n              segmentInfo = {\n            id: 0x1549a966,\n            // Info\n            data: [{\n              id: 0x2ad7b1,\n              // TimecodeScale\n              data: 1e6 // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)\n\n            }, {\n              id: 0x4d80,\n              // MuxingApp\n              data: 'webm-writer-js'\n            }, {\n              id: 0x5741,\n              // WritingApp\n              data: 'webm-writer-js'\n            }, segmentDuration // To be filled in later\n            ]\n          },\n              tracks = {\n            id: 0x1654ae6b,\n            // Tracks\n            data: [{\n              id: 0xae,\n              // TrackEntry\n              data: [{\n                id: 0xd7,\n                // TrackNumber\n                data: DEFAULT_TRACK_NUMBER\n              }, {\n                id: 0x73c5,\n                // TrackUID\n                data: DEFAULT_TRACK_NUMBER\n              }, {\n                id: 0x9c,\n                // FlagLacing\n                data: 0\n              }, {\n                id: 0x22b59c,\n                // Language\n                data: 'und'\n              }, {\n                id: 0x86,\n                // CodecID\n                data: 'V_VP8'\n              }, {\n                id: 0x258688,\n                // CodecName\n                data: 'VP8'\n              }, {\n                id: 0x83,\n                // TrackType\n                data: 1\n              }, {\n                id: 0xe0,\n                // Video\n                data: [{\n                  id: 0xb0,\n                  // PixelWidth\n                  data: videoWidth\n                }, {\n                  id: 0xba,\n                  // PixelHeight\n                  data: videoHeight\n                }]\n              }]\n            }]\n          };\n          ebmlSegment = {\n            id: 0x18538067,\n            // Segment\n            size: -1,\n            // Unbounded size\n            data: [seekHead, segmentInfo, tracks]\n          };\n          var bufferStream = new ArrayBufferDataStream(256);\n          writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);\n          blobBuffer.write(bufferStream.getAsDataArray()); // Now we know where these top-level elements lie in the file:\n\n          seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(segmentInfo.offset);\n          seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(tracks.offset);\n        }\n        /**\n         * Create a SimpleBlock keyframe header using these fields:\n         *     timecode    - Time of this keyframe\n         *     trackNumber - Track number from 1 to 126 (inclusive)\n         *     frame       - Raw frame data payload string\n         *\n         * Returns an EBML element.\n         */\n\n\n        function createKeyframeBlock(keyframe) {\n          var bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n\n          if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n            throw 'TrackNumber must be > 0 and < 127';\n          }\n\n          bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n\n          bufferStream.writeU16BE(keyframe.timecode); // Flags byte\n\n          bufferStream.writeByte(1 << 7 // Keyframe\n          );\n          return {\n            id: 0xa3,\n            // SimpleBlock\n            data: [bufferStream.getAsDataArray(), keyframe.frame]\n          };\n        }\n        /**\n         * Create a Cluster node using these fields:\n         *\n         *    timecode    - Start time for the cluster\n         *\n         * Returns an EBML element.\n         */\n\n\n        function createCluster(cluster) {\n          return {\n            id: 0x1f43b675,\n            data: [{\n              id: 0xe7,\n              // Timecode\n              data: Math.round(cluster.timecode)\n            }]\n          };\n        }\n\n        function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {\n          cues.push({\n            id: 0xbb,\n            // Cue\n            data: [{\n              id: 0xb3,\n              // CueTime\n              data: clusterTime\n            }, {\n              id: 0xb7,\n              // CueTrackPositions\n              data: [{\n                id: 0xf7,\n                // CueTrack\n                data: trackIndex\n              }, {\n                id: 0xf1,\n                // CueClusterPosition\n                data: fileOffsetToSegmentRelative(clusterFileOffset)\n              }]\n            }]\n          });\n        }\n        /**\n         * Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\n         * The seek entry for the Cues in the SeekHead is updated.\n         */\n\n\n        function writeCues() {\n          var ebml = {\n            id: 0x1c53bb6b,\n            data: cues\n          },\n              cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n\n          writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n          blobBuffer.write(cuesBuffer.getAsDataArray()); // Now we know where the Cues element has ended up, we can update the SeekHead\n\n          seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);\n        }\n        /**\n         * Flush the frames in the current clusterFrameBuffer out to the stream as a Cluster.\n         */\n\n\n        function flushClusterFrameBuffer() {\n          if (clusterFrameBuffer.length == 0) {\n            return;\n          } // First work out how large of a buffer we need to hold the cluster data\n\n\n          var rawImageSize = 0;\n\n          for (var i = 0; i < clusterFrameBuffer.length; i++) {\n            rawImageSize += clusterFrameBuffer[i].frame.length;\n          }\n\n          var buffer = new ArrayBufferDataStream(rawImageSize + clusterFrameBuffer.length * 32),\n              // Estimate 32 bytes per SimpleBlock header\n          cluster = createCluster({\n            timecode: Math.round(clusterStartTime)\n          });\n\n          for (var i = 0; i < clusterFrameBuffer.length; i++) {\n            cluster.data.push(createKeyframeBlock(clusterFrameBuffer[i]));\n          }\n\n          writeEBML(buffer, blobBuffer.pos, cluster);\n          blobBuffer.write(buffer.getAsDataArray());\n          addCuePoint(DEFAULT_TRACK_NUMBER, Math.round(clusterStartTime), cluster.offset);\n          clusterFrameBuffer = [];\n          clusterStartTime += clusterDuration;\n          clusterDuration = 0;\n        }\n\n        function validateOptions() {\n          // Derive frameDuration setting if not already supplied\n          if (!options.frameDuration) {\n            if (options.frameRate) {\n              options.frameDuration = 1000 / options.frameRate;\n            } else {\n              throw 'Missing required frameDuration or frameRate setting';\n            }\n          }\n        }\n\n        function addFrameToCluster(frame) {\n          frame.trackNumber = DEFAULT_TRACK_NUMBER; // Frame timecodes are relative to the start of their cluster:\n\n          frame.timecode = Math.round(clusterDuration);\n          clusterFrameBuffer.push(frame);\n          clusterDuration += frame.duration;\n\n          if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {\n            flushClusterFrameBuffer();\n          }\n        }\n        /**\n         * Rewrites the SeekHead element that was initially written to the stream with the offsets of top level elements.\n         *\n         * Call once writing is complete (so the offset of all top level elements is known).\n         */\n\n\n        function rewriteSeekHead() {\n          var seekHeadBuffer = new ArrayBufferDataStream(seekHead.size),\n              oldPos = blobBuffer.pos; // Write the rewritten SeekHead element's data payload to the stream (don't need to update the id or size)\n\n          writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data); // And write that through to the file\n\n          blobBuffer.seek(seekHead.dataOffset);\n          blobBuffer.write(seekHeadBuffer.getAsDataArray());\n          blobBuffer.seek(oldPos);\n        }\n        /**\n         * Rewrite the Duration field of the Segment with the newly-discovered video duration.\n         */\n\n\n        function rewriteDuration() {\n          var buffer = new ArrayBufferDataStream(8),\n              oldPos = blobBuffer.pos; // Rewrite the data payload (don't need to update the id or size)\n\n          buffer.writeDoubleBE(clusterStartTime); // And write that through to the file\n\n          blobBuffer.seek(segmentDuration.dataOffset);\n          blobBuffer.write(buffer.getAsDataArray());\n          blobBuffer.seek(oldPos);\n        }\n        /**\n         * Add a frame to the video. Currently the frame must be a Canvas element.\n         */\n\n\n        this.addFrame = function (canvas) {\n          if (writtenHeader) {\n            if (canvas.width != videoWidth || canvas.height != videoHeight) {\n              throw 'Frame size differs from previous frames';\n            }\n          } else {\n            videoWidth = canvas.width;\n            videoHeight = canvas.height;\n            writeHeader();\n            writtenHeader = true;\n          }\n\n          var webP = renderAsWebP(canvas, {\n            quality: options.quality\n          });\n\n          if (!webP) {\n            throw \"Couldn't decode WebP frame, does the browser support WebP?\";\n          }\n\n          addFrameToCluster({\n            frame: extractKeyframeFromWebP(webP),\n            duration: options.frameDuration\n          });\n        };\n        /**\n         * Finish writing the video and return a Promise to signal completion.\n         *\n         * If the destination device was memory (i.e. options.fileWriter was not supplied), the Promise is resolved with\n         * a Blob with the contents of the entire video.\n         */\n\n\n        this.complete = function () {\n          flushClusterFrameBuffer();\n          writeCues();\n          rewriteSeekHead();\n          rewriteDuration();\n          return blobBuffer.complete('video/webm');\n        };\n\n        this.getWrittenSize = function () {\n          return blobBuffer.length;\n        };\n\n        options = extend(optionDefaults, options || {});\n        validateOptions();\n      };\n    };\n\n    if (isNodeEnviroment) {\n      module.exports = WebMWriter(ArrayBufferDataStream, BlobBuffer);\n    } else {\n      window.WebMWriter = WebMWriter(ArrayBufferDataStream, BlobBuffer);\n    }\n  })();\n})(webmWriter0_2_0);\n\n(function (module, exports) {\n\n  (function () {\n    var Tar = window.Tar;\n    var download = window.download;\n    var GIF = window.GIF;\n    var WebMWriter = window.WebMWriter;\n    var objectTypes = {\n      function: true,\n      object: true\n    };\n\n    function checkGlobal(value) {\n      return value && value.Object === Object ? value : null;\n    }\n    /** Detect free variable `exports`. */\n\n    var freeExports = exports && !exports.nodeType ? exports : undefined;\n    /** Detect free variable `module`. */\n\n    var freeModule = module && !module.nodeType ? module : undefined;\n    /** Detect the popular CommonJS extension `module.exports`. */\n\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : undefined;\n    /** Detect free variable `global` from Node.js. */\n\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c == 'object' && _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c);\n    /** Detect free variable `self`. */\n\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    /** Detect free variable `window`. */\n\n    var freeWindow = checkGlobal(objectTypes[typeof window] && window);\n    /** Detect `this` as the global object. */\n\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    /**\n     * Used as a reference to the global object.\n     *\n     * The `this` value is used if it's the global object to avoid Greasemonkey's\n     * restricted `window` object, otherwise the `window` object is used.\n     */\n\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function('return this')();\n\n    if (!('gc' in window)) {\n      window.gc = function () {};\n    }\n\n    if (!HTMLCanvasElement.prototype.toBlob) {\n      Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n        value: function (callback, type, quality) {\n          var binStr = atob(this.toDataURL(type, quality).split(',')[1]),\n              len = binStr.length,\n              arr = new Uint8Array(len);\n\n          for (var i = 0; i < len; i++) {\n            arr[i] = binStr.charCodeAt(i);\n          }\n\n          callback(new Blob([arr], {\n            type: type || 'image/png'\n          }));\n        }\n      });\n    } // @license http://opensource.org/licenses/MIT\n\n    (function () {\n      if ('performance' in window == false) {\n        window.performance = {};\n      }\n\n      Date.now = Date.now || function () {\n        // thanks IE8\n        return new Date().getTime();\n      };\n\n      if ('now' in window.performance == false) {\n        var nowOffset = Date.now();\n\n        if (performance.timing && performance.timing.navigationStart) {\n          nowOffset = performance.timing.navigationStart;\n        }\n\n        window.performance.now = function now() {\n          return Date.now() - nowOffset;\n        };\n      }\n    })();\n\n    function pad(n) {\n      return String('0000000' + n).slice(-7);\n    } // https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Timers\n\n\n    var g_startTime = window.Date.now();\n\n    function guid() {\n      function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n      }\n\n      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n    }\n\n    function CCFrameEncoder(settings) {\n      var _handlers = {};\n      this.settings = settings;\n\n      this.on = function (event, handler) {\n        _handlers[event] = handler;\n      };\n\n      this.emit = function (event) {\n        var handler = _handlers[event];\n\n        if (handler) {\n          handler.apply(null, Array.prototype.slice.call(arguments, 1));\n        }\n      };\n\n      this.filename = settings.name || guid();\n      this.extension = '';\n      this.mimeType = '';\n    }\n\n    CCFrameEncoder.prototype.start = function () {};\n\n    CCFrameEncoder.prototype.stop = function () {};\n\n    CCFrameEncoder.prototype.add = function () {};\n\n    CCFrameEncoder.prototype.save = function () {};\n\n    CCFrameEncoder.prototype.dispose = function () {};\n\n    CCFrameEncoder.prototype.safeToProceed = function () {\n      return true;\n    };\n\n    CCFrameEncoder.prototype.step = function () {\n      console.log('Step not set!');\n    };\n\n    function CCTarEncoder(settings) {\n      CCFrameEncoder.call(this, settings);\n      this.extension = '.tar';\n      this.mimeType = 'application/x-tar';\n      this.fileExtension = '';\n      this.baseFilename = this.filename;\n      this.tape = null;\n      this.count = 0;\n      this.part = 1;\n      this.frames = 0;\n    }\n\n    CCTarEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n    CCTarEncoder.prototype.start = function () {\n      this.dispose();\n    };\n\n    CCTarEncoder.prototype.add = function (blob) {\n      var fileReader = new FileReader();\n\n      fileReader.onload = function () {\n        this.tape.append(pad(this.count) + this.fileExtension, new Uint8Array(fileReader.result));\n\n        if (this.settings.autoSaveTime > 0 && this.frames / this.settings.framerate >= this.settings.autoSaveTime) {\n          this.save(function (blob) {\n            this.filename = this.baseFilename + '-part-' + pad(this.part);\n            download(blob, this.filename + this.extension, this.mimeType);\n            var count = this.count;\n            this.dispose();\n            this.count = count + 1;\n            this.part++;\n            this.filename = this.baseFilename + '-part-' + pad(this.part);\n            this.frames = 0;\n            this.step();\n          }.bind(this));\n        } else {\n          this.count++;\n          this.frames++;\n          this.step();\n        }\n      }.bind(this);\n\n      fileReader.readAsArrayBuffer(blob);\n    };\n\n    CCTarEncoder.prototype.save = function (callback) {\n      callback(this.tape.save());\n    };\n\n    CCTarEncoder.prototype.dispose = function () {\n      this.tape = new Tar();\n      this.count = 0;\n    };\n\n    function CCPNGEncoder(settings) {\n      CCTarEncoder.call(this, settings);\n      this.type = 'image/png';\n      this.fileExtension = '.png';\n    }\n\n    CCPNGEncoder.prototype = Object.create(CCTarEncoder.prototype);\n\n    CCPNGEncoder.prototype.add = function (canvas) {\n      canvas.toBlob(function (blob) {\n        CCTarEncoder.prototype.add.call(this, blob);\n      }.bind(this), this.type);\n    };\n\n    function CCJPEGEncoder(settings) {\n      CCTarEncoder.call(this, settings);\n      this.type = 'image/jpeg';\n      this.fileExtension = '.jpg';\n      this.quality = settings.quality / 100 || 0.8;\n    }\n\n    CCJPEGEncoder.prototype = Object.create(CCTarEncoder.prototype);\n\n    CCJPEGEncoder.prototype.add = function (canvas) {\n      canvas.toBlob(function (blob) {\n        CCTarEncoder.prototype.add.call(this, blob);\n      }.bind(this), this.type, this.quality);\n    };\n    /*\n    WebM Encoder\n    */\n\n\n    function CCWebMEncoder(settings) {\n      var canvas = document.createElement('canvas');\n\n      if (canvas.toDataURL('image/webp').substr(5, 10) !== 'image/webp') {\n        console.log('WebP not supported - try another export format');\n      }\n\n      CCFrameEncoder.call(this, settings);\n      this.quality = settings.quality / 100 || 0.8;\n      this.extension = '.webm';\n      this.mimeType = 'video/webm';\n      this.baseFilename = this.filename;\n      this.framerate = settings.framerate;\n      this.frames = 0;\n      this.part = 1;\n      this.videoWriter = new WebMWriter({\n        quality: this.quality,\n        fileWriter: null,\n        fd: null,\n        frameRate: this.framerate\n      });\n    }\n\n    CCWebMEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n    CCWebMEncoder.prototype.start = function (canvas) {\n      this.dispose();\n    };\n\n    CCWebMEncoder.prototype.add = function (canvas) {\n      this.videoWriter.addFrame(canvas);\n\n      if (this.settings.autoSaveTime > 0 && this.frames / this.settings.framerate >= this.settings.autoSaveTime) {\n        this.save(function (blob) {\n          this.filename = this.baseFilename + '-part-' + pad(this.part);\n          download(blob, this.filename + this.extension, this.mimeType);\n          this.dispose();\n          this.part++;\n          this.filename = this.baseFilename + '-part-' + pad(this.part);\n          this.step();\n        }.bind(this));\n      } else {\n        this.frames++;\n        this.step();\n      }\n    };\n\n    CCWebMEncoder.prototype.save = function (callback) {\n      this.videoWriter.complete().then(callback);\n    };\n\n    CCWebMEncoder.prototype.dispose = function (canvas) {\n      this.frames = 0;\n      this.videoWriter = new WebMWriter({\n        quality: this.quality,\n        fileWriter: null,\n        fd: null,\n        frameRate: this.framerate\n      });\n    };\n\n    function CCFFMpegServerEncoder(settings) {\n      CCFrameEncoder.call(this, settings);\n      settings.quality = settings.quality / 100 || 0.8;\n      this.encoder = new FFMpegServer.Video(settings);\n      this.encoder.on('process', function () {\n        this.emit('process');\n      }.bind(this));\n      this.encoder.on('finished', function (url, size) {\n        var cb = this.callback;\n\n        if (cb) {\n          this.callback = undefined;\n          cb(url, size);\n        }\n      }.bind(this));\n      this.encoder.on('progress', function (progress) {\n        if (this.settings.onProgress) {\n          this.settings.onProgress(progress);\n        }\n      }.bind(this));\n      this.encoder.on('error', function (data) {\n        alert(JSON.stringify(data, null, 2));\n      }.bind(this));\n    }\n\n    CCFFMpegServerEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n    CCFFMpegServerEncoder.prototype.start = function () {\n      this.encoder.start(this.settings);\n    };\n\n    CCFFMpegServerEncoder.prototype.add = function (canvas) {\n      this.encoder.add(canvas);\n    };\n\n    CCFFMpegServerEncoder.prototype.save = function (callback) {\n      this.callback = callback;\n      this.encoder.end();\n    };\n\n    CCFFMpegServerEncoder.prototype.safeToProceed = function () {\n      return this.encoder.safeToProceed();\n    };\n    /*\n    HTMLCanvasElement.captureStream()\n    */\n\n\n    function CCStreamEncoder(settings) {\n      CCFrameEncoder.call(this, settings);\n      this.framerate = this.settings.framerate;\n      this.type = 'video/webm';\n      this.extension = '.webm';\n      this.stream = null;\n      this.mediaRecorder = null;\n      this.chunks = [];\n    }\n\n    CCStreamEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n    CCStreamEncoder.prototype.add = function (canvas) {\n      if (!this.stream) {\n        this.stream = canvas.captureStream(this.framerate);\n        this.mediaRecorder = new MediaRecorder(this.stream);\n        this.mediaRecorder.start();\n\n        this.mediaRecorder.ondataavailable = function (e) {\n          this.chunks.push(e.data);\n        }.bind(this);\n      }\n\n      this.step();\n    };\n\n    CCStreamEncoder.prototype.save = function (callback) {\n      this.mediaRecorder.onstop = function (e) {\n        var blob = new Blob(this.chunks, {\n          type: 'video/webm'\n        });\n        this.chunks = [];\n        callback(blob);\n      }.bind(this);\n\n      this.mediaRecorder.stop();\n    };\n    /*function CCGIFEncoder( settings ) {\n    CCFrameEncoder.call( this );\n    settings.quality = settings.quality || 6;\n    this.settings = settings;\n    this.encoder = new GIFEncoder();\n    this.encoder.setRepeat( 1 );\n    \tthis.encoder.setDelay( settings.step );\n    \tthis.encoder.setQuality( 6 );\n    \tthis.encoder.setTransparent( null );\n    \tthis.encoder.setSize( 150, 150 );\n     \tthis.canvas = document.createElement( 'canvas' );\n    \tthis.ctx = this.canvas.getContext( '2d' );\n    }\n    CCGIFEncoder.prototype = Object.create( CCFrameEncoder );\n    CCGIFEncoder.prototype.start = function() {\n    this.encoder.start();\n    }\n    CCGIFEncoder.prototype.add = function( canvas ) {\n    this.canvas.width = canvas.width;\n    this.canvas.height = canvas.height;\n    this.ctx.drawImage( canvas, 0, 0 );\n    this.encoder.addFrame( this.ctx );\n    this.encoder.setSize( canvas.width, canvas.height );\n    var readBuffer = new Uint8Array(canvas.width * canvas.height * 4);\n    var context = canvas.getContext( 'webgl' );\n    context.readPixels(0, 0, canvas.width, canvas.height, context.RGBA, context.UNSIGNED_BYTE, readBuffer);\n    this.encoder.addFrame( readBuffer, true );\n    }\n    CCGIFEncoder.prototype.stop = function() {\n    this.encoder.finish();\n    }\n    CCGIFEncoder.prototype.save = function( callback ) {\n    var binary_gif = this.encoder.stream().getData();\n    var data_url = 'data:image/gif;base64,'+encode64(binary_gif);\n    window.location = data_url;\n    return;\n    var blob = new Blob( [ binary_gif ], { type: \"octet/stream\" } );\n    var url = window.URL.createObjectURL( blob );\n    callback( url );\n    }*/\n\n\n    function CCGIFEncoder(settings) {\n      CCFrameEncoder.call(this, settings);\n      settings.quality = 31 - (settings.quality * 30 / 100 || 10);\n      settings.workers = settings.workers || 4;\n      this.extension = '.gif';\n      this.mimeType = 'image/gif';\n      this.canvas = document.createElement('canvas');\n      this.ctx = this.canvas.getContext('2d');\n      this.sizeSet = false;\n      this.encoder = new GIF({\n        workers: settings.workers,\n        quality: settings.quality,\n        workerScript: settings.workersPath + 'gif.worker.js'\n      });\n      this.encoder.on('progress', function (progress) {\n        if (this.settings.onProgress) {\n          this.settings.onProgress(progress);\n        }\n      }.bind(this));\n      this.encoder.on('finished', function (blob) {\n        var cb = this.callback;\n\n        if (cb) {\n          this.callback = undefined;\n          cb(blob);\n        }\n      }.bind(this));\n    }\n\n    CCGIFEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n    CCGIFEncoder.prototype.add = function (canvas) {\n      if (!this.sizeSet) {\n        this.encoder.setOption('width', canvas.width);\n        this.encoder.setOption('height', canvas.height);\n        this.sizeSet = true;\n      }\n\n      this.canvas.width = canvas.width;\n      this.canvas.height = canvas.height;\n      this.ctx.drawImage(canvas, 0, 0);\n      this.encoder.addFrame(this.ctx, {\n        copy: true,\n        delay: this.settings.step\n      });\n      this.step();\n      /*this.encoder.setSize( canvas.width, canvas.height );\n      var readBuffer = new Uint8Array(canvas.width * canvas.height * 4);\n      var context = canvas.getContext( 'webgl' );\n      context.readPixels(0, 0, canvas.width, canvas.height, context.RGBA, context.UNSIGNED_BYTE, readBuffer);\n      this.encoder.addFrame( readBuffer, true );*/\n    };\n\n    CCGIFEncoder.prototype.save = function (callback) {\n      this.callback = callback;\n      this.encoder.render();\n    };\n\n    function CCapture(settings) {\n      var _settings = settings || {},\n          _verbose,\n          _time,\n          _startTime,\n          _performanceTime,\n          _performanceStartTime,\n          _step,\n          _encoder,\n          _timeouts = [],\n          _intervals = [],\n          _frameCount = 0,\n          _intermediateFrameCount = 0,\n          _requestAnimationFrameCallbacks = [],\n          _capturing = false,\n          _handlers = {};\n\n      _settings.framerate = _settings.framerate || 60;\n      _settings.motionBlurFrames = 2 * (_settings.motionBlurFrames || 1);\n      _verbose = _settings.verbose || false;\n      _settings.display || false;\n      _settings.step = 1000.0 / _settings.framerate;\n      _settings.timeLimit = _settings.timeLimit || 0;\n      _settings.frameLimit = _settings.frameLimit || 0;\n      _settings.startTime = _settings.startTime || 0;\n\n      var _timeDisplay = document.createElement('div');\n\n      _timeDisplay.style.position = 'absolute';\n      _timeDisplay.style.left = _timeDisplay.style.top = 0;\n      _timeDisplay.style.backgroundColor = 'black';\n      _timeDisplay.style.fontFamily = 'monospace';\n      _timeDisplay.style.fontSize = '11px';\n      _timeDisplay.style.padding = '5px';\n      _timeDisplay.style.color = 'red';\n      _timeDisplay.style.zIndex = 100000;\n      if (_settings.display) document.body.appendChild(_timeDisplay);\n      var canvasMotionBlur = document.createElement('canvas');\n      var ctxMotionBlur = canvasMotionBlur.getContext('2d');\n      var bufferMotionBlur;\n      var imageData;\n\n      _log('Step is set to ' + _settings.step + 'ms');\n\n      var _encoders = {\n        gif: CCGIFEncoder,\n        webm: CCWebMEncoder,\n        ffmpegserver: CCFFMpegServerEncoder,\n        png: CCPNGEncoder,\n        jpg: CCJPEGEncoder,\n        'webm-mediarecorder': CCStreamEncoder\n      };\n      var ctor = _encoders[_settings.format];\n\n      if (!ctor) {\n        throw 'Error: Incorrect or missing format: Valid formats are ' + Object.keys(_encoders).join(', ');\n      }\n\n      _encoder = new ctor(_settings);\n      _encoder.step = _step;\n\n      _encoder.on('process', _process);\n\n      _encoder.on('progress', _progress);\n\n      if ('performance' in window == false) {\n        window.performance = {};\n      }\n\n      Date.now = Date.now || function () {\n        // thanks IE8\n        return new Date().getTime();\n      };\n\n      if ('now' in window.performance == false) {\n        var nowOffset = Date.now();\n\n        if (performance.timing && performance.timing.navigationStart) {\n          nowOffset = performance.timing.navigationStart;\n        }\n\n        window.performance.now = function now() {\n          return Date.now() - nowOffset;\n        };\n      }\n\n      var _oldSetTimeout = window.setTimeout,\n          _oldSetInterval = window.setInterval,\n          _oldClearInterval = window.clearInterval,\n          _oldClearTimeout = window.clearTimeout,\n          _oldRequestAnimationFrame = window.requestAnimationFrame,\n          _oldNow = window.Date.now,\n          _oldPerformanceNow = window.performance.now,\n          _oldGetTime = window.Date.prototype.getTime; // Date.prototype._oldGetTime = Date.prototype.getTime;\n\n      var media = [];\n\n      function _init() {\n        _log('Capturer start');\n\n        _startTime = window.Date.now();\n        _time = _startTime + _settings.startTime;\n        _performanceStartTime = window.performance.now();\n        _performanceTime = _performanceStartTime + _settings.startTime;\n\n        window.Date.prototype.getTime = function () {\n          return _time;\n        };\n\n        window.Date.now = function () {\n          return _time;\n        };\n\n        window.setTimeout = function (callback, time) {\n          time = 5000;\n          var t = {\n            callback: callback,\n            time: time,\n            triggerTime: _time + time\n          };\n\n          _timeouts.push(t);\n\n          _log('Timeout set to ' + t.time);\n\n          return t;\n        };\n\n        window.clearTimeout = function (id) {\n          for (var j = 0; j < _timeouts.length; j++) {\n            if (_timeouts[j] == id) {\n              _timeouts.splice(j, 1);\n\n              _log('Timeout cleared');\n\n              continue;\n            }\n          }\n        };\n\n        window.setInterval = function (callback, time) {\n          var t = {\n            callback: callback,\n            time: time,\n            triggerTime: _time + time\n          };\n\n          _intervals.push(t);\n\n          _log('Interval set to ' + t.time);\n\n          return t;\n        };\n\n        window.clearInterval = function (id) {\n          _log('clear Interval');\n\n          return null;\n        };\n\n        window.requestAnimationFrame = function (callback) {\n          _requestAnimationFrameCallbacks.push(callback);\n        };\n\n        window.performance.now = function () {\n          return _performanceTime;\n        };\n\n        function hookCurrentTime() {\n          if (!this._hooked) {\n            this._hooked = true;\n            this._hookedTime = this.currentTime || 0;\n            this.pause();\n            media.push(this);\n          }\n\n          return this._hookedTime + _settings.startTime;\n        }\n\n        try {\n          Object.defineProperty(HTMLVideoElement.prototype, 'currentTime', {\n            get: hookCurrentTime\n          });\n          Object.defineProperty(HTMLAudioElement.prototype, 'currentTime', {\n            get: hookCurrentTime\n          });\n        } catch (err) {\n          _log(err);\n        }\n      }\n\n      function _start() {\n        _init();\n\n        _encoder.start();\n\n        _capturing = true;\n      }\n\n      function _stop() {\n        _capturing = false;\n\n        _encoder.stop();\n\n        _destroy();\n      }\n\n      function _call(fn, p) {\n        _oldSetTimeout(fn, 0, p);\n      }\n\n      function _step() {\n        //_oldRequestAnimationFrame( _process );\n        _call(_process);\n      }\n\n      function _destroy() {\n        _log('Capturer stop');\n\n        window.setTimeout = _oldSetTimeout;\n        window.setInterval = _oldSetInterval;\n        window.clearInterval = _oldClearInterval;\n        window.clearTimeout = _oldClearTimeout;\n        window.requestAnimationFrame = _oldRequestAnimationFrame;\n        window.Date.prototype.getTime = _oldGetTime;\n        window.Date.now = _oldNow;\n        window.performance.now = _oldPerformanceNow;\n      }\n\n      function _updateTime() {\n        var seconds = _frameCount / _settings.framerate;\n\n        if (_settings.frameLimit && _frameCount >= _settings.frameLimit || _settings.timeLimit && seconds >= _settings.timeLimit) {\n          _stop();\n\n          _save();\n        }\n\n        var d = new Date(null);\n        d.setSeconds(seconds);\n\n        if (_settings.motionBlurFrames > 2) {\n          _timeDisplay.textContent = 'CCapture ' + _settings.format + ' | ' + _frameCount + ' frames (' + _intermediateFrameCount + ' inter) | ' + d.toISOString().substr(11, 8);\n        } else {\n          _timeDisplay.textContent = 'CCapture ' + _settings.format + ' | ' + _frameCount + ' frames | ' + d.toISOString().substr(11, 8);\n        }\n      }\n\n      function _checkFrame(canvas) {\n        if (canvasMotionBlur.width !== canvas.width || canvasMotionBlur.height !== canvas.height) {\n          canvasMotionBlur.width = canvas.width;\n          canvasMotionBlur.height = canvas.height;\n          bufferMotionBlur = new Uint16Array(canvasMotionBlur.height * canvasMotionBlur.width * 4);\n          ctxMotionBlur.fillStyle = '#0';\n          ctxMotionBlur.fillRect(0, 0, canvasMotionBlur.width, canvasMotionBlur.height);\n        }\n      }\n\n      function _blendFrame(canvas) {\n        //_log( 'Intermediate Frame: ' + _intermediateFrameCount );\n        ctxMotionBlur.drawImage(canvas, 0, 0);\n        imageData = ctxMotionBlur.getImageData(0, 0, canvasMotionBlur.width, canvasMotionBlur.height);\n\n        for (var j = 0; j < bufferMotionBlur.length; j += 4) {\n          bufferMotionBlur[j] += imageData.data[j];\n          bufferMotionBlur[j + 1] += imageData.data[j + 1];\n          bufferMotionBlur[j + 2] += imageData.data[j + 2];\n        }\n\n        _intermediateFrameCount++;\n      }\n\n      function _saveFrame() {\n        var data = imageData.data;\n\n        for (var j = 0; j < bufferMotionBlur.length; j += 4) {\n          data[j] = bufferMotionBlur[j] * 2 / _settings.motionBlurFrames;\n          data[j + 1] = bufferMotionBlur[j + 1] * 2 / _settings.motionBlurFrames;\n          data[j + 2] = bufferMotionBlur[j + 2] * 2 / _settings.motionBlurFrames;\n        }\n\n        ctxMotionBlur.putImageData(imageData, 0, 0);\n\n        _encoder.add(canvasMotionBlur);\n\n        _frameCount++;\n        _intermediateFrameCount = 0;\n\n        _log('Full MB Frame! ' + _frameCount + ' ' + _time);\n\n        for (var j = 0; j < bufferMotionBlur.length; j += 4) {\n          bufferMotionBlur[j] = 0;\n          bufferMotionBlur[j + 1] = 0;\n          bufferMotionBlur[j + 2] = 0;\n        }\n\n        gc();\n      }\n\n      function _capture(canvas) {\n        if (_capturing) {\n          if (_settings.motionBlurFrames > 2) {\n            _checkFrame(canvas);\n\n            _blendFrame(canvas);\n\n            if (_intermediateFrameCount >= 0.5 * _settings.motionBlurFrames) {\n              _saveFrame();\n            } else {\n              _step();\n            }\n          } else {\n            _encoder.add(canvas);\n\n            _frameCount++;\n\n            _log('Full Frame! ' + _frameCount);\n          }\n        }\n      }\n\n      function _process() {\n        var step = 1000 / _settings.framerate;\n        var dt = (_frameCount + _intermediateFrameCount / _settings.motionBlurFrames) * step;\n        _time = _startTime + dt;\n        _performanceTime = _performanceStartTime + dt;\n        media.forEach(function (v) {\n          v._hookedTime = dt / 1000;\n        });\n\n        _updateTime();\n\n        _log('Frame: ' + _frameCount + ' ' + _intermediateFrameCount);\n\n        for (var j = 0; j < _timeouts.length; j++) {\n          if (_time >= _timeouts[j].triggerTime) {\n            _call(_timeouts[j].callback); //console.log( 'timeout!' );\n\n\n            _timeouts.splice(j, 1);\n\n            continue;\n          }\n        }\n\n        for (var j = 0; j < _intervals.length; j++) {\n          if (_time >= _intervals[j].triggerTime) {\n            _call(_intervals[j].callback);\n\n            _intervals[j].triggerTime += _intervals[j].time; //console.log( 'interval!' );\n\n            continue;\n          }\n        }\n\n        _requestAnimationFrameCallbacks.forEach(function (cb) {\n          _call(cb, _time - g_startTime);\n        });\n\n        _requestAnimationFrameCallbacks = [];\n      }\n\n      function _save(callback) {\n        if (!callback) {\n          callback = function (blob) {\n            download(blob, _encoder.filename + _encoder.extension, _encoder.mimeType);\n            return false;\n          };\n        }\n\n        _encoder.save(callback);\n      }\n\n      function _log(message) {\n        if (_verbose) console.log(message);\n      }\n\n      function _on(event, handler) {\n        _handlers[event] = handler;\n      }\n\n      function _emit(event) {\n        var handler = _handlers[event];\n\n        if (handler) {\n          handler.apply(null, Array.prototype.slice.call(arguments, 1));\n        }\n      }\n\n      function _progress(progress) {\n        _emit('progress', progress);\n      }\n\n      return {\n        start: _start,\n        capture: _capture,\n        stop: _stop,\n        save: _save,\n        on: _on\n      };\n    }\n    (freeWindow || freeSelf || {}).CCapture = CCapture; // Some AMD build optimizers like r.js check for condition patterns like the following:\n\n    if (freeExports && freeModule) {\n        // Export for Node.js.\n        if (moduleExports) {\n          (freeModule.exports = CCapture).CCapture = CCapture;\n        } // Export for CommonJS support.\n\n\n        freeExports.CCapture = CCapture;\n      } else {\n        // Export to the global object.\n        root.CCapture = CCapture;\n      }\n  })();\n})(CCapture$2, CCapture$2.exports);\n\nvar CCapture = CCapture$2.exports;\n\nvar CCapture$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), CCapture$2.exports, {\n  'default': CCapture\n}));\n\n\n//# sourceMappingURL=CCapture-d5b23ba0.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3JlYWN0LXN3aWZ0L2Rpc3QvQ0NhcHR1cmUtZDViMjNiYTAuanM/YThmZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUU7O0FBRXJFLGtCQUFrQjs7QUFFbEIsV0FBVzs7QUFFWDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1AscURBQXFELFlBQVk7QUFDakU7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQyxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Es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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCO0FBQ2pFO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0EseUNBQXlDOzs7QUFHekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTs7QUFFQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNCQUFzQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFMEI7QUFDM0IiLCJmaWxlIjoiLi4vLi4vcmVhY3Qtc3dpZnQvZGlzdC9DQ2FwdHVyZS1kNWIyM2JhMC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGMgYXMgY29tbW9uanNHbG9iYWwgfSBmcm9tICcuL19jb21tb25qc0hlbHBlcnMtMWM4YmViNWYuanMnO1xuXG52YXIgQ0NhcHR1cmUkMiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciB0YXIgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gIChmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbG9va3VwID0gWydBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0JywgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnKycsICcvJ107XG5cbiAgICBmdW5jdGlvbiBjbGVhbihsZW5ndGgpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChvcmlnLCBsZW5ndGgsIGFkZExlbmd0aCwgbXVsdGlwbGVPZikge1xuICAgICAgdmFyIG5ld1NpemUgPSBsZW5ndGggKyBhZGRMZW5ndGgsXG4gICAgICAgICAgYnVmZmVyID0gY2xlYW4oKHBhcnNlSW50KG5ld1NpemUgLyBtdWx0aXBsZU9mKSArIDEpICogbXVsdGlwbGVPZik7XG4gICAgICBidWZmZXIuc2V0KG9yaWcpO1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWQobnVtLCBieXRlcywgYmFzZSkge1xuICAgICAgbnVtID0gbnVtLnRvU3RyaW5nKGJhc2UgfHwgOCk7XG4gICAgICByZXR1cm4gJzAwMDAwMDAwMDAwMCcuc3Vic3RyKG51bS5sZW5ndGggKyAxMiAtIGJ5dGVzKSArIG51bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdUb1VpbnQ4KGlucHV0LCBvdXQsIG9mZnNldCkge1xuICAgICAgdmFyIGksIGxlbmd0aDtcbiAgICAgIG91dCA9IG91dCB8fCBjbGVhbihpbnB1dC5sZW5ndGgpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIG91dFtvZmZzZXRdID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdWludDhUb0Jhc2U2NCh1aW50OCkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsXG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgICAgIG91dHB1dCA9ICcnLFxuICAgICAgICAgIHRlbXAsXG4gICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQobnVtKSB7XG4gICAgICAgIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzZl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzZl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNmXSArIGxvb2t1cFtudW0gJiAweDNmXTtcbiAgICAgIH0gLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyB1aW50OFtpICsgMl07XG4gICAgICAgIG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG4gICAgICB9IC8vIHRoaXMgcHJldmVudHMgYW4gRVJSX0lOVkFMSURfVVJMIGluIENocm9tZSAoRmlyZWZveCBva2F5KVxuXG5cbiAgICAgIHN3aXRjaCAob3V0cHV0Lmxlbmd0aCAlIDQpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG91dHB1dCArPSAnPSc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG91dHB1dCArPSAnPT0nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHdpbmRvdy51dGlscyA9IHt9O1xuICAgIHdpbmRvdy51dGlscy5jbGVhbiA9IGNsZWFuO1xuICAgIHdpbmRvdy51dGlscy5wYWQgPSBwYWQ7XG4gICAgd2luZG93LnV0aWxzLmV4dGVuZCA9IGV4dGVuZDtcbiAgICB3aW5kb3cudXRpbHMuc3RyaW5nVG9VaW50OCA9IHN0cmluZ1RvVWludDg7XG4gICAgd2luZG93LnV0aWxzLnVpbnQ4VG9CYXNlNjQgPSB1aW50OFRvQmFzZTY0O1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgLypcbiAgICBzdHJ1Y3QgcG9zaXhfaGVhZGVyIHsgICAgICAgICAgICAgLy8gYnl0ZSBvZmZzZXRcbiAgICBjaGFyIG5hbWVbMTAwXTsgICAgICAgICAgICAgICAvLyAgIDBcbiAgICBjaGFyIG1vZGVbOF07ICAgICAgICAgICAgICAgICAvLyAxMDBcbiAgICBjaGFyIHVpZFs4XTsgICAgICAgICAgICAgICAgICAvLyAxMDhcbiAgICBjaGFyIGdpZFs4XTsgICAgICAgICAgICAgICAgICAvLyAxMTZcbiAgICBjaGFyIHNpemVbMTJdOyAgICAgICAgICAgICAgICAvLyAxMjRcbiAgICBjaGFyIG10aW1lWzEyXTsgICAgICAgICAgICAgICAvLyAxMzZcbiAgICBjaGFyIGNoa3N1bVs4XTsgICAgICAgICAgICAgICAvLyAxNDhcbiAgICBjaGFyIHR5cGVmbGFnOyAgICAgICAgICAgICAgICAvLyAxNTZcbiAgICBjaGFyIGxpbmtuYW1lWzEwMF07ICAgICAgICAgICAvLyAxNTdcbiAgICBjaGFyIG1hZ2ljWzZdOyAgICAgICAgICAgICAgICAvLyAyNTdcbiAgICBjaGFyIHZlcnNpb25bMl07ICAgICAgICAgICAgICAvLyAyNjNcbiAgICBjaGFyIHVuYW1lWzMyXTsgICAgICAgICAgICAgICAvLyAyNjVcbiAgICBjaGFyIGduYW1lWzMyXTsgICAgICAgICAgICAgICAvLyAyOTdcbiAgICBjaGFyIGRldm1ham9yWzhdOyAgICAgICAgICAgICAvLyAzMjlcbiAgICBjaGFyIGRldm1pbm9yWzhdOyAgICAgICAgICAgICAvLyAzMzdcbiAgICBjaGFyIHByZWZpeFsxNTVdOyAgICAgICAgICAgICAvLyAzNDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDUwMFxuICAgIH07XG4gICAgKi9cblxuICAgIHZhciB1dGlscyA9IHdpbmRvdy51dGlscyxcbiAgICAgICAgaGVhZGVyRm9ybWF0O1xuICAgIGhlYWRlckZvcm1hdCA9IFt7XG4gICAgICBmaWVsZDogJ2ZpbGVOYW1lJyxcbiAgICAgIGxlbmd0aDogMTAwXG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdmaWxlTW9kZScsXG4gICAgICBsZW5ndGg6IDhcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ3VpZCcsXG4gICAgICBsZW5ndGg6IDhcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ2dpZCcsXG4gICAgICBsZW5ndGg6IDhcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ2ZpbGVTaXplJyxcbiAgICAgIGxlbmd0aDogMTJcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ210aW1lJyxcbiAgICAgIGxlbmd0aDogMTJcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ2NoZWNrc3VtJyxcbiAgICAgIGxlbmd0aDogOFxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAndHlwZScsXG4gICAgICBsZW5ndGg6IDFcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ2xpbmtOYW1lJyxcbiAgICAgIGxlbmd0aDogMTAwXG4gICAgfSwge1xuICAgICAgZmllbGQ6ICd1c3RhcicsXG4gICAgICBsZW5ndGg6IDhcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ293bmVyJyxcbiAgICAgIGxlbmd0aDogMzJcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ2dyb3VwJyxcbiAgICAgIGxlbmd0aDogMzJcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ21ham9yTnVtYmVyJyxcbiAgICAgIGxlbmd0aDogOFxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAnbWlub3JOdW1iZXInLFxuICAgICAgbGVuZ3RoOiA4XG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdmaWxlbmFtZVByZWZpeCcsXG4gICAgICBsZW5ndGg6IDE1NVxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAncGFkZGluZycsXG4gICAgICBsZW5ndGg6IDEyXG4gICAgfV07XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRIZWFkZXIoZGF0YSwgY2IpIHtcbiAgICAgIHZhciBidWZmZXIgPSB1dGlscy5jbGVhbig1MTIpLFxuICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICBoZWFkZXJGb3JtYXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHN0ciA9IGRhdGFbdmFsdWUuZmllbGRdIHx8ICcnLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzdHIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0ICs9IHZhbHVlLmxlbmd0aCAtIGk7IC8vIHNwYWNlIGl0IG91dCB3aXRoIG51bGxzXG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY2IoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cblxuICAgIHdpbmRvdy5oZWFkZXIgPSB7fTtcbiAgICB3aW5kb3cuaGVhZGVyLnN0cnVjdHVyZSA9IGhlYWRlckZvcm1hdDtcbiAgICB3aW5kb3cuaGVhZGVyLmZvcm1hdCA9IGZvcm1hdEhlYWRlcjtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGhlYWRlciA9IHdpbmRvdy5oZWFkZXIsXG4gICAgICAgIHV0aWxzID0gd2luZG93LnV0aWxzLFxuICAgICAgICByZWNvcmRTaXplID0gNTEyLFxuICAgICAgICBibG9ja1NpemU7XG5cbiAgICBmdW5jdGlvbiBUYXIocmVjb3Jkc1BlckJsb2NrKSB7XG4gICAgICB0aGlzLndyaXR0ZW4gPSAwO1xuICAgICAgYmxvY2tTaXplID0gKHJlY29yZHNQZXJCbG9jayB8fCAyMCkgKiByZWNvcmRTaXplO1xuICAgICAgdGhpcy5vdXQgPSB1dGlscy5jbGVhbihibG9ja1NpemUpO1xuICAgICAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBUYXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChmaWxlcGF0aCwgaW5wdXQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZGF0YSwgY2hlY2tzdW0sIG1vZGUsIG10aW1lLCB1aWQsIGdpZCwgaGVhZGVyQXJyO1xuXG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbnB1dCA9IHV0aWxzLnN0cmluZ1RvVWludDgoaW5wdXQpO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dC5jb25zdHJ1Y3RvciAhPT0gVWludDhBcnJheS5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhyb3cgJ0ludmFsaWQgaW5wdXQgdHlwZS4gWW91IGdhdmUgbWU6ICcgKyBpbnB1dC5jb25zdHJ1Y3Rvci50b1N0cmluZygpLm1hdGNoKC9mdW5jdGlvblxccyooWyRBLVphLXpfXVswLTlBLVphLXpfXSopXFxzKlxcKC8pWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgIG1vZGUgPSBvcHRzLm1vZGUgfHwgcGFyc2VJbnQoJzc3NycsIDgpICYgMHhmZmY7XG4gICAgICBtdGltZSA9IG9wdHMubXRpbWUgfHwgTWF0aC5mbG9vcigrbmV3IERhdGUoKSAvIDEwMDApO1xuICAgICAgdWlkID0gb3B0cy51aWQgfHwgMDtcbiAgICAgIGdpZCA9IG9wdHMuZ2lkIHx8IDA7XG4gICAgICBkYXRhID0ge1xuICAgICAgICBmaWxlTmFtZTogZmlsZXBhdGgsXG4gICAgICAgIGZpbGVNb2RlOiB1dGlscy5wYWQobW9kZSwgNyksXG4gICAgICAgIHVpZDogdXRpbHMucGFkKHVpZCwgNyksXG4gICAgICAgIGdpZDogdXRpbHMucGFkKGdpZCwgNyksXG4gICAgICAgIGZpbGVTaXplOiB1dGlscy5wYWQoaW5wdXQubGVuZ3RoLCAxMSksXG4gICAgICAgIG10aW1lOiB1dGlscy5wYWQobXRpbWUsIDExKSxcbiAgICAgICAgY2hlY2tzdW06ICcgICAgICAgICcsXG4gICAgICAgIHR5cGU6ICcwJyxcbiAgICAgICAgLy8ganVzdCBhIGZpbGVcbiAgICAgICAgdXN0YXI6ICd1c3RhciAgJyxcbiAgICAgICAgb3duZXI6IG9wdHMub3duZXIgfHwgJycsXG4gICAgICAgIGdyb3VwOiBvcHRzLmdyb3VwIHx8ICcnXG4gICAgICB9OyAvLyBjYWxjdWxhdGUgdGhlIGNoZWNrc3VtXG5cbiAgICAgIGNoZWNrc3VtID0gMDtcbiAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHZhbHVlID0gZGF0YVtrZXldLFxuICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgY2hlY2tzdW0gKz0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBkYXRhLmNoZWNrc3VtID0gdXRpbHMucGFkKGNoZWNrc3VtLCA2KSArICdcXHUwMDAwICc7XG4gICAgICBoZWFkZXJBcnIgPSBoZWFkZXIuZm9ybWF0KGRhdGEpO1xuICAgICAgdmFyIGhlYWRlckxlbmd0aCA9IE1hdGguY2VpbChoZWFkZXJBcnIubGVuZ3RoIC8gcmVjb3JkU2l6ZSkgKiByZWNvcmRTaXplO1xuICAgICAgdmFyIGlucHV0TGVuZ3RoID0gTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIHJlY29yZFNpemUpICogcmVjb3JkU2l6ZTtcbiAgICAgIHRoaXMuYmxvY2tzLnB1c2goe1xuICAgICAgICBoZWFkZXI6IGhlYWRlckFycixcbiAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICBoZWFkZXJMZW5ndGg6IGhlYWRlckxlbmd0aCxcbiAgICAgICAgaW5wdXRMZW5ndGg6IGlucHV0TGVuZ3RoXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVGFyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgICAgIHZhciBjaHVua3MgPSBbXTtcbiAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgdmFyIG1heCA9IE1hdGgucG93KDIsIDIwKTtcbiAgICAgIHZhciBjaHVuayA9IFtdO1xuICAgICAgdGhpcy5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAobGVuZ3RoICsgYi5oZWFkZXJMZW5ndGggKyBiLmlucHV0TGVuZ3RoID4gbWF4KSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2goe1xuICAgICAgICAgICAgYmxvY2tzOiBjaHVuayxcbiAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2h1bmsgPSBbXTtcbiAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY2h1bmsucHVzaChiKTtcbiAgICAgICAgbGVuZ3RoICs9IGIuaGVhZGVyTGVuZ3RoICsgYi5pbnB1dExlbmd0aDtcbiAgICAgIH0pO1xuICAgICAgY2h1bmtzLnB1c2goe1xuICAgICAgICBibG9ja3M6IGNodW5rLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgfSk7XG4gICAgICBjaHVua3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYy5sZW5ndGgpO1xuICAgICAgICB2YXIgd3JpdHRlbiA9IDA7XG4gICAgICAgIGMuYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBidWZmZXIuc2V0KGIuaGVhZGVyLCB3cml0dGVuKTtcbiAgICAgICAgICB3cml0dGVuICs9IGIuaGVhZGVyTGVuZ3RoO1xuICAgICAgICAgIGJ1ZmZlci5zZXQoYi5pbnB1dCwgd3JpdHRlbik7XG4gICAgICAgICAgd3JpdHRlbiArPSBiLmlucHV0TGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgICAgYnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgICB9KTtcbiAgICAgIGJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheSgyICogcmVjb3JkU2l6ZSkpO1xuICAgICAgcmV0dXJuIG5ldyBCbG9iKGJ1ZmZlcnMsIHtcbiAgICAgICAgdHlwZTogJ29jdGV0L3N0cmVhbSdcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUYXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy53cml0dGVuID0gMDtcbiAgICAgIHRoaXMub3V0ID0gdXRpbHMuY2xlYW4oYmxvY2tTaXplKTtcbiAgICB9O1xuXG4gICAge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBUYXI7XG4gICAgfVxuICB9KSgpO1xufSkodGFyKTtcblxudmFyIGRvd25sb2FkID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICB7XG4gICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgLy8gbGlrZSBOb2RlLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfVxuICB9KShjb21tb25qc0dsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkb3dubG9hZChkYXRhLCBzdHJGaWxlTmFtZSwgc3RyTWltZVR5cGUpIHtcbiAgICAgIHZhciBzZWxmID0gd2luZG93LFxuICAgICAgICAgIC8vIHRoaXMgc2NyaXB0IGlzIG9ubHkgZm9yIGJyb3dzZXJzIGFueXdheS4uLlxuICAgICAgZGVmYXVsdE1pbWUgPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAvLyB0aGlzIGRlZmF1bHQgbWltZSBhbHNvIHRyaWdnZXJzIGlmcmFtZSBkb3dubG9hZHNcbiAgICAgIG1pbWVUeXBlID0gc3RyTWltZVR5cGUgfHwgZGVmYXVsdE1pbWUsXG4gICAgICAgICAgcGF5bG9hZCA9IGRhdGEsXG4gICAgICAgICAgdXJsID0gIXN0ckZpbGVOYW1lICYmICFzdHJNaW1lVHlwZSAmJiBwYXlsb2FkLFxuICAgICAgICAgIGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSxcbiAgICAgICAgICB0b1N0cmluZyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYSk7XG4gICAgICB9LFxuICAgICAgICAgIG15QmxvYiA9IHNlbGYuQmxvYiB8fCBzZWxmLk1vekJsb2IgfHwgc2VsZi5XZWJLaXRCbG9iIHx8IHRvU3RyaW5nLFxuICAgICAgICAgIGZpbGVOYW1lID0gc3RyRmlsZU5hbWUgfHwgJ2Rvd25sb2FkJyxcbiAgICAgICAgICBibG9iLFxuICAgICAgICAgIHJlYWRlcjtcblxuICAgICAgbXlCbG9iID0gbXlCbG9iLmNhbGwgPyBteUJsb2IuYmluZChzZWxmKSA6IEJsb2I7XG5cbiAgICAgIGlmIChTdHJpbmcodGhpcykgPT09ICd0cnVlJykge1xuICAgICAgICAvL3JldmVyc2UgYXJndW1lbnRzLCBhbGxvd2luZyBkb3dubG9hZC5iaW5kKHRydWUsIFwidGV4dC94bWxcIiwgXCJleHBvcnQueG1sXCIpIHRvIGFjdCBhcyBhIGNhbGxiYWNrXG4gICAgICAgIHBheWxvYWQgPSBbcGF5bG9hZCwgbWltZVR5cGVdO1xuICAgICAgICBtaW1lVHlwZSA9IHBheWxvYWRbMF07XG4gICAgICAgIHBheWxvYWQgPSBwYXlsb2FkWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAodXJsICYmIHVybC5sZW5ndGggPCAyMDQ4KSB7XG4gICAgICAgIC8vIGlmIG5vIGZpbGVuYW1lIGFuZCBubyBtaW1lLCBhc3N1bWUgYSB1cmwgd2FzIHBhc3NlZCBhcyB0aGUgb25seSBhcmd1bWVudFxuICAgICAgICBmaWxlTmFtZSA9IHVybC5zcGxpdCgnLycpLnBvcCgpLnNwbGl0KCc/JylbMF07XG4gICAgICAgIGFuY2hvci5ocmVmID0gdXJsOyAvLyBhc3NpZ24gaHJlZiBwcm9wIHRvIHRlbXAgYW5jaG9yXG5cbiAgICAgICAgaWYgKGFuY2hvci5ocmVmLmluZGV4T2YodXJsKSAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgYnJvd3NlciBkZXRlcm1pbmVzIHRoYXQgaXQncyBhIHBvdGVudGlhbGx5IHZhbGlkIHVybCBwYXRoOlxuICAgICAgICAgIHZhciBhamF4ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgYWpheC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgIGFqYXgucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuXG4gICAgICAgICAgYWpheC5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZG93bmxvYWQoZS50YXJnZXQucmVzcG9uc2UsIGZpbGVOYW1lLCBkZWZhdWx0TWltZSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWpheC5zZW5kKCk7XG4gICAgICAgICAgfSwgMCk7IC8vIGFsbG93cyBzZXR0aW5nIGN1c3RvbSBhamF4IGhlYWRlcnMgdXNpbmcgdGhlIHJldHVybjpcblxuICAgICAgICAgIHJldHVybiBhamF4O1xuICAgICAgICB9IC8vIGVuZCBpZiB2YWxpZCB1cmw/XG5cbiAgICAgIH0gLy8gZW5kIGlmIHVybD9cbiAgICAgIC8vZ28gYWhlYWQgYW5kIGRvd25sb2FkIGRhdGFVUkxzIHJpZ2h0IGF3YXlcblxuXG4gICAgICBpZiAoL15kYXRhOihbXFx3Ky1dK1xcL1tcXHcrLi1dKyk/Wyw7XS8udGVzdChwYXlsb2FkKSkge1xuICAgICAgICBpZiAocGF5bG9hZC5sZW5ndGggPiAxMDI0ICogMTAyNCAqIDEuOTk5ICYmIG15QmxvYiAhPT0gdG9TdHJpbmcpIHtcbiAgICAgICAgICBwYXlsb2FkID0gZGF0YVVybFRvQmxvYihwYXlsb2FkKTtcbiAgICAgICAgICBtaW1lVHlwZSA9IHBheWxvYWQudHlwZSB8fCBkZWZhdWx0TWltZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1zU2F2ZUJsb2IgLy8gSUUxMCBjYW4ndCBkbyBhW2Rvd25sb2FkXSwgb25seSBCbG9iczpcbiAgICAgICAgICA/IG5hdmlnYXRvci5tc1NhdmVCbG9iKGRhdGFVcmxUb0Jsb2IocGF5bG9hZCksIGZpbGVOYW1lKSA6IHNhdmVyKHBheWxvYWQpOyAvLyBldmVyeW9uZSBlbHNlIGNhbiBzYXZlIGRhdGFVUkxzIHVuLXByb2Nlc3NlZFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL25vdCBkYXRhIHVybCwgaXMgaXQgYSBzdHJpbmcgd2l0aCBzcGVjaWFsIG5lZWRzP1xuICAgICAgICBpZiAoLyhbXFx4ODAtXFx4ZmZdKS8udGVzdChwYXlsb2FkKSkge1xuICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgdGVtcFVpQXJyID0gbmV3IFVpbnQ4QXJyYXkocGF5bG9hZC5sZW5ndGgpLFxuICAgICAgICAgICAgICBteCA9IHRlbXBVaUFyci5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGk7IGkgPCBteDsgKytpKSB0ZW1wVWlBcnJbaV0gPSBwYXlsb2FkLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgICBwYXlsb2FkID0gbmV3IG15QmxvYihbdGVtcFVpQXJyXSwge1xuICAgICAgICAgICAgdHlwZTogbWltZVR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBibG9iID0gcGF5bG9hZCBpbnN0YW5jZW9mIG15QmxvYiA/IHBheWxvYWQgOiBuZXcgbXlCbG9iKFtwYXlsb2FkXSwge1xuICAgICAgICB0eXBlOiBtaW1lVHlwZVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGRhdGFVcmxUb0Jsb2Ioc3RyVXJsKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHN0clVybC5zcGxpdCgvWzo7LF0vKSxcbiAgICAgICAgICAgIHR5cGUgPSBwYXJ0c1sxXSxcbiAgICAgICAgICAgIGluZGV4RGVjb2RlciA9IHN0clVybC5pbmRleE9mKCdjaGFyc2V0JykgPiAwID8gMyA6IDIsXG4gICAgICAgICAgICBkZWNvZGVyID0gcGFydHNbaW5kZXhEZWNvZGVyXSA9PSAnYmFzZTY0JyA/IGF0b2IgOiBkZWNvZGVVUklDb21wb25lbnQsXG4gICAgICAgICAgICBiaW5EYXRhID0gZGVjb2RlcihwYXJ0cy5wb3AoKSksXG4gICAgICAgICAgICBteCA9IGJpbkRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICB1aUFyciA9IG5ldyBVaW50OEFycmF5KG14KTtcblxuICAgICAgICBmb3IgKGk7IGkgPCBteDsgKytpKSB1aUFycltpXSA9IGJpbkRhdGEuY2hhckNvZGVBdChpKTtcblxuICAgICAgICByZXR1cm4gbmV3IG15QmxvYihbdWlBcnJdLCB7XG4gICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2F2ZXIodXJsLCB3aW5Nb2RlKSB7XG4gICAgICAgIGlmICgnZG93bmxvYWQnIGluIGFuY2hvcikge1xuICAgICAgICAgIC8vaHRtbDUgQVtkb3dubG9hZF1cbiAgICAgICAgICBhbmNob3IuaHJlZiA9IHVybDtcbiAgICAgICAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIGZpbGVOYW1lKTtcbiAgICAgICAgICBhbmNob3IuY2xhc3NOYW1lID0gJ2Rvd25sb2FkLWpzLWxpbmsnO1xuICAgICAgICAgIGFuY2hvci5pbm5lckhUTUwgPSAnZG93bmxvYWRpbmcuLi4nO1xuICAgICAgICAgIGFuY2hvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIGFuY2hvci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYW5jaG9yKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFuY2hvci5jbGljaygpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhbmNob3IpO1xuXG4gICAgICAgICAgICBpZiAod2luTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwoYW5jaG9yLmhyZWYpO1xuICAgICAgICAgICAgICB9LCAyNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDY2KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBoYW5kbGUgbm9uLWFbZG93bmxvYWRdIHNhZmFyaSBhcyBiZXN0IHdlIGNhbjpcblxuXG4gICAgICAgIGlmICgvKFZlcnNpb24pXFwvKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8uKlNhZmFyaVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgIGlmICgvXmRhdGE6Ly50ZXN0KHVybCkpIHVybCA9ICdkYXRhOicgKyB1cmwucmVwbGFjZSgvXmRhdGE6KFtcXHdcXC9cXC1cXCtdKykvLCBkZWZhdWx0TWltZSk7XG5cbiAgICAgICAgICBpZiAoIXdpbmRvdy5vcGVuKHVybCkpIHtcbiAgICAgICAgICAgIC8vIHBvcHVwIGJsb2NrZWQsIG9mZmVyIGRpcmVjdCBkb3dubG9hZDpcbiAgICAgICAgICAgIGlmIChjb25maXJtKCdEaXNwbGF5aW5nIE5ldyBEb2N1bWVudFxcblxcblVzZSBTYXZlIEFzLi4uIHRvIGRvd25sb2FkLCB0aGVuIGNsaWNrIGJhY2sgdG8gcmV0dXJuIHRvIHRoaXMgcGFnZS4nKSkge1xuICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vZG8gaWZyYW1lIGRhdGFVUkwgZG93bmxvYWQgKG9sZCBjaCtGRik6XG5cblxuICAgICAgICB2YXIgZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGYpO1xuXG4gICAgICAgIGlmICghd2luTW9kZSAmJiAvXmRhdGE6Ly50ZXN0KHVybCkpIHtcbiAgICAgICAgICAvLyBmb3JjZSBhIG1pbWUgdGhhdCB3aWxsIGRvd25sb2FkOlxuICAgICAgICAgIHVybCA9ICdkYXRhOicgKyB1cmwucmVwbGFjZSgvXmRhdGE6KFtcXHdcXC9cXC1cXCtdKykvLCBkZWZhdWx0TWltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmLnNyYyA9IHVybDtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChmKTtcbiAgICAgICAgfSwgMzMzKTtcbiAgICAgIH0gLy9lbmQgc2F2ZXJcblxuXG4gICAgICBpZiAobmF2aWdhdG9yLm1zU2F2ZUJsb2IpIHtcbiAgICAgICAgLy8gSUUxMCsgOiAoaGFzIEJsb2IsIGJ1dCBub3QgYVtkb3dubG9hZF0gb3IgVVJMKVxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1zU2F2ZUJsb2IoYmxvYiwgZmlsZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5VUkwpIHtcbiAgICAgICAgLy8gc2ltcGxlIGZhc3QgYW5kIG1vZGVybiB3YXkgdXNpbmcgQmxvYiBhbmQgVVJMOlxuICAgICAgICBzYXZlcihzZWxmLlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYiksIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaGFuZGxlIG5vbi1CbG9iKCkrbm9uLVVSTCBicm93c2VyczpcbiAgICAgICAgaWYgKHR5cGVvZiBibG9iID09PSAnc3RyaW5nJyB8fCBibG9iLmNvbnN0cnVjdG9yID09PSB0b1N0cmluZykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc2F2ZXIoJ2RhdGE6JyArIG1pbWVUeXBlICsgJztiYXNlNjQsJyArIHNlbGYuYnRvYShibG9iKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeSkge1xuICAgICAgICAgICAgcmV0dXJuIHNhdmVyKCdkYXRhOicgKyBtaW1lVHlwZSArICcsJyArIGVuY29kZVVSSUNvbXBvbmVudChibG9iKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEJsb2IgYnV0IG5vdCBVUkwgc3VwcG9ydDpcblxuXG4gICAgICAgIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgc2F2ZXIodGhpcy5yZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qIGVuZCBkb3dubG9hZCgpICovXG4gIH0pO1xufSkoZG93bmxvYWQpO1xuXG4oZnVuY3Rpb24gKGMpIHtcbiAgZnVuY3Rpb24gYShiLCBkKSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYS5jYWNoZSwgYikpIHJldHVybiBhLmNhY2hlW2JdO1xuICAgIHZhciBlID0gYS5yZXNvbHZlKGIpO1xuICAgIGlmICghZSkgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBtb2R1bGUgJyArIGIpO1xuICAgIHZhciBjID0ge1xuICAgICAgaWQ6IGIsXG4gICAgICByZXF1aXJlOiBhLFxuICAgICAgZmlsZW5hbWU6IGIsXG4gICAgICBleHBvcnRzOiB7fSxcbiAgICAgIGxvYWRlZDogITEsXG4gICAgICBwYXJlbnQ6IGQsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICAgIGQgJiYgZC5jaGlsZHJlbi5wdXNoKGMpO1xuICAgIHZhciBmID0gYi5zbGljZSgwLCBiLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICByZXR1cm4gYS5jYWNoZVtiXSA9IGMuZXhwb3J0cywgZS5jYWxsKGMuZXhwb3J0cywgYywgYy5leHBvcnRzLCBmLCBiKSwgYy5sb2FkZWQgPSAhMCwgYS5jYWNoZVtiXSA9IGMuZXhwb3J0cztcbiAgfVxuICBhLm1vZHVsZXMgPSB7fSwgYS5jYWNoZSA9IHt9LCBhLnJlc29sdmUgPSBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEubW9kdWxlcywgYikgPyBhLm1vZHVsZXNbYl0gOiB2b2lkIDA7XG4gIH0sIGEuZGVmaW5lID0gZnVuY3Rpb24gKGIsIGMpIHtcbiAgICBhLm1vZHVsZXNbYl0gPSBjO1xuICB9O1xuXG4gIHZhciBiID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYSA9ICcvJywge1xuICAgICAgdGl0bGU6ICdicm93c2VyJyxcbiAgICAgIHZlcnNpb246ICd2MC4xMC4yNicsXG4gICAgICBicm93c2VyOiAhMCxcbiAgICAgIGVudjoge30sXG4gICAgICBhcmd2OiBbXSxcbiAgICAgIG5leHRUaWNrOiBjLnNldEltbWVkaWF0ZSB8fCBmdW5jdGlvbiAoYSkge1xuICAgICAgICBzZXRUaW1lb3V0KGEsIDApO1xuICAgICAgfSxcbiAgICAgIGN3ZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICBjaGRpcjogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpO1xuXG4gIGEuZGVmaW5lKCcvZ2lmLmNvZmZlZScsIGZ1bmN0aW9uIChkLCBtLCBsLCBrKSB7XG4gICAgZnVuY3Rpb24gZyhhLCBiKSB7XG4gICAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIGEgPSAwLCBjID0gYi5sZW5ndGg7IGEgPCBjOyArK2EpIGlmIChhIGluIGIgJiYgYlthXSA9PT0gZCkgcmV0dXJuICEwO1xuXG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaShhLCBiKSB7XG4gICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gYTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgYyBpbiBiKSBnKGIsIGMpICYmIChhW2NdID0gYltjXSk7XG5cbiAgICAgIHJldHVybiBkLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBhLnByb3RvdHlwZSA9IG5ldyBkKCksIGEuX19zdXBlcl9fID0gYi5wcm90b3R5cGUsIGE7XG4gICAgfVxuXG4gICAgdmFyIGgsIGMsIGYsIGIsIGU7XG4gICAgZiA9IGEoJ2V2ZW50cycsIGQpLkV2ZW50RW1pdHRlciwgaCA9IGEoJy9icm93c2VyLmNvZmZlZScsIGQpLCBlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGZ1bmN0aW9uIGEoZCkge1xuICAgICAgICB2YXIgYSwgYjtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gITEsIHRoaXMub3B0aW9ucyA9IHt9LCB0aGlzLmZyYW1lcyA9IFtdLCB0aGlzLmZyZWVXb3JrZXJzID0gW10sIHRoaXMuYWN0aXZlV29ya2VycyA9IFtdLCB0aGlzLnNldE9wdGlvbnMoZCk7XG5cbiAgICAgICAgZm9yIChhIGluIGMpIGIgPSBjW2FdLCBudWxsICE9IHRoaXMub3B0aW9uc1thXSA/IHRoaXMub3B0aW9uc1thXSA6IHRoaXMub3B0aW9uc1thXSA9IGI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpKGEsIGQpLCBjID0ge1xuICAgICAgICB3b3JrZXJTY3JpcHQ6ICdnaWYud29ya2VyLmpzJyxcbiAgICAgICAgd29ya2VyczogMixcbiAgICAgICAgcmVwZWF0OiAwLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgICAgIHF1YWxpdHk6IDEwLFxuICAgICAgICB3aWR0aDogbnVsbCxcbiAgICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgICB0cmFuc3BhcmVudDogbnVsbFxuICAgICAgfSwgYiA9IHtcbiAgICAgICAgZGVsYXk6IDUwMCxcbiAgICAgICAgY29weTogITFcbiAgICAgIH0sIGEucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbYV0gPSBiLCBudWxsICE9IHRoaXMuX2NhbnZhcyAmJiAoYSA9PT0gJ3dpZHRoJyB8fCBhID09PSAnaGVpZ2h0JykgPyB0aGlzLl9jYW52YXNbYV0gPSBiIDogdm9pZCAwO1xuICAgICAgfSwgYS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhLCBjO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBmb3IgKGEgaW4gYikge1xuICAgICAgICAgICAgaWYgKCFnKGIsIGEpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGMgPSBiW2FdLCBkLnB1c2godGhpcy5zZXRPcHRpb24oYSwgYykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9LmNhbGwodGhpcywgW10pO1xuICAgICAgfSwgYS5wcm90b3R5cGUuYWRkRnJhbWUgPSBmdW5jdGlvbiAoYSwgZCkge1xuICAgICAgICB2YXIgYywgZTtcbiAgICAgICAgbnVsbCA9PSBkICYmIChkID0ge30pLCBjID0ge30sIGMudHJhbnNwYXJlbnQgPSB0aGlzLm9wdGlvbnMudHJhbnNwYXJlbnQ7XG5cbiAgICAgICAgZm9yIChlIGluIGIpIGNbZV0gPSBkW2VdIHx8IGJbZV07XG5cbiAgICAgICAgaWYgKG51bGwgIT0gdGhpcy5vcHRpb25zLndpZHRoIHx8IHRoaXMuc2V0T3B0aW9uKCd3aWR0aCcsIGEud2lkdGgpLCBudWxsICE9IHRoaXMub3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5zZXRPcHRpb24oJ2hlaWdodCcsIGEuaGVpZ2h0KSwgJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBJbWFnZURhdGEgJiYgbnVsbCAhPSBJbWFnZURhdGEgJiYgYSBpbnN0YW5jZW9mIEltYWdlRGF0YSkgYy5kYXRhID0gYS5kYXRhO2Vsc2UgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICYmIG51bGwgIT0gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICYmIGEgaW5zdGFuY2VvZiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfHwgJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgJiYgbnVsbCAhPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgJiYgYSBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkgZC5jb3B5ID8gYy5kYXRhID0gdGhpcy5nZXRDb250ZXh0RGF0YShhKSA6IGMuY29udGV4dCA9IGE7ZWxzZSBpZiAobnVsbCAhPSBhLmNoaWxkTm9kZXMpIGQuY29weSA/IGMuZGF0YSA9IHRoaXMuZ2V0SW1hZ2VEYXRhKGEpIDogYy5pbWFnZSA9IGE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW1hZ2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzLnB1c2goYyk7XG4gICAgICB9LCBhLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhO1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0FscmVhZHkgcnVubmluZycpO1xuICAgICAgICBpZiAoIShudWxsICE9IHRoaXMub3B0aW9ucy53aWR0aCAmJiBudWxsICE9IHRoaXMub3B0aW9ucy5oZWlnaHQpKSB0aHJvdyBuZXcgRXJyb3IoJ1dpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBzZXQgcHJpb3IgdG8gcmVuZGVyaW5nJyk7XG4gICAgICAgIHRoaXMucnVubmluZyA9ICEwLCB0aGlzLm5leHRGcmFtZSA9IDAsIHRoaXMuZmluaXNoZWRGcmFtZXMgPSAwLCB0aGlzLmltYWdlUGFydHMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGZvciAodmFyIGIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYjtcbiAgICAgICAgICAgIGIgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IDAgPD0gdGhpcy5mcmFtZXMubGVuZ3RoID8gYSA8IHRoaXMuZnJhbWVzLmxlbmd0aCA6IGEgPiB0aGlzLmZyYW1lcy5sZW5ndGg7IDAgPD0gdGhpcy5mcmFtZXMubGVuZ3RoID8gKythIDogLS1hKSBiLnB1c2goYSk7XG5cbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgIH0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgYSA9IDAsIGUgPSBiLmxlbmd0aDsgYSA8IGU7ICsrYSkgYy5wdXNoKG51bGwpO1xuXG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0uY2FsbCh0aGlzLCBbXSksIGEgPSB0aGlzLnNwYXduV29ya2VycygpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGM7XG4gICAgICAgICAgYyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgYiA9IDA7IDAgPD0gYSA/IGIgPCBhIDogYiA+IGE7IDAgPD0gYSA/ICsrYiA6IC0tYikgYy5wdXNoKGIpO1xuXG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgYiA9IDAsIGUgPSBjLmxlbmd0aDsgYiA8IGU7ICsrYikgdGhpcy5yZW5kZXJOZXh0RnJhbWUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdzdGFydCcpLCB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgMCk7XG4gICAgICB9LCBhLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGE7XG5cbiAgICAgICAgd2hpbGUgKCEwKSB7XG4gICAgICAgICAgaWYgKGEgPSB0aGlzLmFjdGl2ZVdvcmtlcnMuc2hpZnQoKSwgIShudWxsICE9IGEpKSBicmVhaztcbiAgICAgICAgICBjb25zb2xlLmxvZygna2lsbGluZyBhY3RpdmUgd29ya2VyJyksIGEudGVybWluYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nID0gITEsIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLnNwYXduV29ya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIHJldHVybiBhID0gTWF0aC5taW4odGhpcy5vcHRpb25zLndvcmtlcnMsIHRoaXMuZnJhbWVzLmxlbmd0aCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYztcbiAgICAgICAgICBjID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBiID0gdGhpcy5mcmVlV29ya2Vycy5sZW5ndGg7IHRoaXMuZnJlZVdvcmtlcnMubGVuZ3RoIDw9IGEgPyBiIDwgYSA6IGIgPiBhOyB0aGlzLmZyZWVXb3JrZXJzLmxlbmd0aCA8PSBhID8gKytiIDogLS1iKSBjLnB1c2goYik7XG5cbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHZhciBiO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKCdzcGF3bmluZyB3b3JrZXIgJyArIGMpLCBiID0gbmV3IFdvcmtlcihhLm9wdGlvbnMud29ya2VyU2NyaXB0KSwgYi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5hY3RpdmVXb3JrZXJzLnNwbGljZShhLmFjdGl2ZVdvcmtlcnMuaW5kZXhPZihiKSwgMSksIGEuZnJlZVdvcmtlcnMucHVzaChiKSwgYS5mcmFtZUZpbmlzaGVkKGMuZGF0YSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGEpLCBhLmZyZWVXb3JrZXJzLnB1c2goYik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSh0aGlzKSksIGE7XG4gICAgICB9LCBhLnByb3RvdHlwZS5mcmFtZUZpbmlzaGVkID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKCdmcmFtZSAnICsgYS5pbmRleCArICcgZmluaXNoZWQgLSAnICsgdGhpcy5hY3RpdmVXb3JrZXJzLmxlbmd0aCArICcgYWN0aXZlJyksIHRoaXMuZmluaXNoZWRGcmFtZXMrKywgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHRoaXMuZmluaXNoZWRGcmFtZXMgLyB0aGlzLmZyYW1lcy5sZW5ndGgpLCB0aGlzLmltYWdlUGFydHNbYS5pbmRleF0gPSBhLCBqKG51bGwsIHRoaXMuaW1hZ2VQYXJ0cykgPyB0aGlzLnJlbmRlck5leHRGcmFtZSgpIDogdGhpcy5maW5pc2hSZW5kZXJpbmcoKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLmZpbmlzaFJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUsIGEsIGssIG0sIGIsIGQsIGg7XG4gICAgICAgIGIgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGYgPSAwLCBqID0gdGhpcy5pbWFnZVBhcnRzLmxlbmd0aDsgZiA8IGo7ICsrZikgYSA9IHRoaXMuaW1hZ2VQYXJ0c1tmXSwgYiArPSAoYS5kYXRhLmxlbmd0aCAtIDEpICogYS5wYWdlU2l6ZSArIGEuY3Vyc29yO1xuXG4gICAgICAgIGIgKz0gYS5wYWdlU2l6ZSAtIGEuY3Vyc29yLCBjb25zb2xlLmxvZygncmVuZGVyaW5nIGZpbmlzaGVkIC0gZmlsZXNpemUgJyArIE1hdGgucm91bmQoYiAvIDFlMykgKyAna2InKSwgZSA9IG5ldyBVaW50OEFycmF5KGIpLCBkID0gMDtcblxuICAgICAgICBmb3IgKHZhciBnID0gMCwgbCA9IHRoaXMuaW1hZ2VQYXJ0cy5sZW5ndGg7IGcgPCBsOyArK2cpIHtcbiAgICAgICAgICBhID0gdGhpcy5pbWFnZVBhcnRzW2ddO1xuXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGkgPSBhLmRhdGEubGVuZ3RoOyBjIDwgaTsgKytjKSBoID0gYS5kYXRhW2NdLCBrID0gYywgZS5zZXQoaCwgZCksIGsgPT09IGEuZGF0YS5sZW5ndGggLSAxID8gZCArPSBhLmN1cnNvciA6IGQgKz0gYS5wYWdlU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtID0gbmV3IEJsb2IoW2VdLCB7XG4gICAgICAgICAgdHlwZTogJ2ltYWdlL2dpZidcbiAgICAgICAgfSksIHRoaXMuZW1pdCgnZmluaXNoZWQnLCBtLCBlKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLnJlbmRlck5leHRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMsIGEsIGI7XG4gICAgICAgIGlmICh0aGlzLmZyZWVXb3JrZXJzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdObyBmcmVlIHdvcmtlcnMnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEZyYW1lID49IHRoaXMuZnJhbWVzLmxlbmd0aCA/IHZvaWQgMCA6IChjID0gdGhpcy5mcmFtZXNbdGhpcy5uZXh0RnJhbWUrK10sIGIgPSB0aGlzLmZyZWVXb3JrZXJzLnNoaWZ0KCksIGEgPSB0aGlzLmdldFRhc2soYyksIGNvbnNvbGUubG9nKCdzdGFydGluZyBmcmFtZSAnICsgKGEuaW5kZXggKyAxKSArICcgb2YgJyArIHRoaXMuZnJhbWVzLmxlbmd0aCksIHRoaXMuYWN0aXZlV29ya2Vycy5wdXNoKGIpLCBiLnBvc3RNZXNzYWdlKGEpKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLmdldENvbnRleHREYXRhID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMub3B0aW9ucy53aWR0aCwgdGhpcy5vcHRpb25zLmhlaWdodCkuZGF0YTtcbiAgICAgIH0sIGEucHJvdG90eXBlLmdldEltYWdlRGF0YSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhO1xuICAgICAgICByZXR1cm4gbnVsbCAhPSB0aGlzLl9jYW52YXMgfHwgKHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLCB0aGlzLl9jYW52YXMud2lkdGggPSB0aGlzLm9wdGlvbnMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSB0aGlzLm9wdGlvbnMuaGVpZ2h0KSwgYSA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpLCBhLnNldEZpbGwgPSB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZCwgYS5maWxsUmVjdCgwLCAwLCB0aGlzLm9wdGlvbnMud2lkdGgsIHRoaXMub3B0aW9ucy5oZWlnaHQpLCBhLmRyYXdJbWFnZShiLCAwLCAwKSwgdGhpcy5nZXRDb250ZXh0RGF0YShhKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLmdldFRhc2sgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYywgYjtcbiAgICAgICAgaWYgKGMgPSB0aGlzLmZyYW1lcy5pbmRleE9mKGEpLCBiID0ge1xuICAgICAgICAgIGluZGV4OiBjLFxuICAgICAgICAgIGxhc3Q6IGMgPT09IHRoaXMuZnJhbWVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgZGVsYXk6IGEuZGVsYXksXG4gICAgICAgICAgdHJhbnNwYXJlbnQ6IGEudHJhbnNwYXJlbnQsXG4gICAgICAgICAgd2lkdGg6IHRoaXMub3B0aW9ucy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMub3B0aW9ucy5oZWlnaHQsXG4gICAgICAgICAgcXVhbGl0eTogdGhpcy5vcHRpb25zLnF1YWxpdHksXG4gICAgICAgICAgcmVwZWF0OiB0aGlzLm9wdGlvbnMucmVwZWF0LFxuICAgICAgICAgIGNhblRyYW5zZmVyOiBoLm5hbWUgPT09ICdjaHJvbWUnXG4gICAgICAgIH0sIG51bGwgIT0gYS5kYXRhKSBiLmRhdGEgPSBhLmRhdGE7ZWxzZSBpZiAobnVsbCAhPSBhLmNvbnRleHQpIGIuZGF0YSA9IHRoaXMuZ2V0Q29udGV4dERhdGEoYS5jb250ZXh0KTtlbHNlIGlmIChudWxsICE9IGEuaW1hZ2UpIGIuZGF0YSA9IHRoaXMuZ2V0SW1hZ2VEYXRhKGEuaW1hZ2UpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZyYW1lJyk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSwgYTtcbiAgICB9KGYpLCBkLmV4cG9ydHMgPSBlO1xuICB9KSwgYS5kZWZpbmUoJy9icm93c2VyLmNvZmZlZScsIGZ1bmN0aW9uIChmLCBnLCBoLCBpKSB7XG4gICAgdmFyIGEsIGQsIGUsIGMsIGI7XG4gICAgYyA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSwgZSA9IG5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpLCBiID0gYy5tYXRjaCgvKG9wZXJhfGllfGZpcmVmb3h8Y2hyb21lfHZlcnNpb24pW1xcc1xcLzpdKFtcXHdcXGRcXC5dKyk/Lio/KHNhZmFyaXx2ZXJzaW9uW1xcc1xcLzpdKFtcXHdcXGRcXC5dKyl8JCkvKSB8fCBbbnVsbCwgJ3Vua25vd24nLCAwXSwgZCA9IGJbMV0gPT09ICdpZScgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlLCBhID0ge1xuICAgICAgbmFtZTogYlsxXSA9PT0gJ3ZlcnNpb24nID8gYlszXSA6IGJbMV0sXG4gICAgICB2ZXJzaW9uOiBkIHx8IHBhcnNlRmxvYXQoYlsxXSA9PT0gJ29wZXJhJyAmJiBiWzRdID8gYls0XSA6IGJbMl0pLFxuICAgICAgcGxhdGZvcm06IHtcbiAgICAgICAgbmFtZTogYy5tYXRjaCgvaXAoPzphZHxvZHxob25lKS8pID8gJ2lvcycgOiAoYy5tYXRjaCgvKD86d2Vib3N8YW5kcm9pZCkvKSB8fCBlLm1hdGNoKC9tYWN8d2lufGxpbnV4LykgfHwgWydvdGhlciddKVswXVxuICAgICAgfVxuICAgIH0sIGFbYS5uYW1lXSA9ICEwLCBhW2EubmFtZSArIHBhcnNlSW50KGEudmVyc2lvbiwgMTApXSA9ICEwLCBhLnBsYXRmb3JtW2EucGxhdGZvcm0ubmFtZV0gPSAhMCwgZi5leHBvcnRzID0gYTtcbiAgfSksIGEuZGVmaW5lKCdldmVudHMnLCBmdW5jdGlvbiAoZiwgZSwgZywgaCkge1xuICAgIGIuRXZlbnRFbWl0dGVyIHx8IChiLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9KTtcbiAgICB2YXIgYSA9IGUuRXZlbnRFbWl0dGVyID0gYi5FdmVudEVtaXR0ZXIsXG4gICAgICAgIGMgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJyA/IEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9LFxuICAgICAgICBkID0gMTA7XG4gICAgYS5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pLCB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID0gYTtcbiAgICB9LCBhLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgIGlmIChmID09PSAnZXJyb3InICYmICghKHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHMuZXJyb3IpIHx8IGModGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHRocm93IGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yID8gYXJndW1lbnRzWzFdIDogbmV3IEVycm9yKFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiAhMTtcbiAgICAgIHZhciBhID0gdGhpcy5fZXZlbnRzW2ZdO1xuICAgICAgaWYgKCFhKSByZXR1cm4gITE7XG4gICAgICBpZiAoISh0eXBlb2YgYSA9PSAnZnVuY3Rpb24nKSkgaWYgKGMoYSkpIHtcbiAgICAgICAgdmFyIGIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgZSA9IGEuc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBkID0gMCwgZyA9IGUubGVuZ3RoOyBkIDwgZzsgZCsrKSBlW2RdLmFwcGx5KHRoaXMsIGIpO1xuXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0gZWxzZSByZXR1cm4gITE7XG5cbiAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBhLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgYS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhciBiID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICBhLmFwcGx5KHRoaXMsIGIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgYS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBiKSB0aHJvdyBuZXcgRXJyb3IoJ2FkZExpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgICBpZiAodGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSksIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCBhLCBiKSwgIXRoaXMuX2V2ZW50c1thXSkgdGhpcy5fZXZlbnRzW2FdID0gYjtlbHNlIGlmIChjKHRoaXMuX2V2ZW50c1thXSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHNbYV0ud2FybmVkKSB7XG4gICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkID8gZSA9IHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgOiBlID0gZCwgZSAmJiBlID4gMCAmJiB0aGlzLl9ldmVudHNbYV0ubGVuZ3RoID4gZSAmJiAodGhpcy5fZXZlbnRzW2FdLndhcm5lZCA9ICEwLCBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsIHRoaXMuX2V2ZW50c1thXS5sZW5ndGgpLCBjb25zb2xlLnRyYWNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzW2FdLnB1c2goYik7XG4gICAgICB9IGVsc2UgdGhpcy5fZXZlbnRzW2FdID0gW3RoaXMuX2V2ZW50c1thXSwgYl07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBhLnByb3RvdHlwZS5vbiA9IGEucHJvdG90eXBlLmFkZExpc3RlbmVyLCBhLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgIHZhciBhID0gdGhpcztcbiAgICAgIHJldHVybiBhLm9uKGIsIGZ1bmN0aW9uIGQoKSB7XG4gICAgICAgIGEucmVtb3ZlTGlzdGVuZXIoYiwgZCksIGMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pLCB0aGlzO1xuICAgIH0sIGEucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGEsIGQpIHtcbiAgICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgZCkgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgICAgaWYgKCEodGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1thXSkpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGIgPSB0aGlzLl9ldmVudHNbYV07XG5cbiAgICAgIGlmIChjKGIpKSB7XG4gICAgICAgIHZhciBlID0gYi5pbmRleE9mKGQpO1xuICAgICAgICBpZiAoZSA8IDApIHJldHVybiB0aGlzO1xuICAgICAgICBiLnNwbGljZShlLCAxKSwgYi5sZW5ndGggPT0gMCAmJiBkZWxldGUgdGhpcy5fZXZlbnRzW2FdO1xuICAgICAgfSBlbHNlIHRoaXMuX2V2ZW50c1thXSA9PT0gZCAmJiBkZWxldGUgdGhpcy5fZXZlbnRzW2FdO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBhLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGEgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1thXSAmJiAodGhpcy5fZXZlbnRzW2FdID0gbnVsbCksIHRoaXM7XG4gICAgfSwgYS5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KSwgdGhpcy5fZXZlbnRzW2FdIHx8ICh0aGlzLl9ldmVudHNbYV0gPSBbXSksIGModGhpcy5fZXZlbnRzW2FdKSB8fCAodGhpcy5fZXZlbnRzW2FdID0gW3RoaXMuX2V2ZW50c1thXV0pLCB0aGlzLl9ldmVudHNbYV07XG4gICAgfTtcbiAgfSksIGMuR0lGID0gYSgnL2dpZi5jb2ZmZWUnKTtcbn0pLmNhbGwoY29tbW9uanNHbG9iYWwsIGNvbW1vbmpzR2xvYmFsKTsgLy8gZ2lmLmpzIDAuMS42IC0gaHR0cHM6Ly9naXRodWIuY29tL2pub3JkYmVyZy9naWYuanNcblxudmFyIHdlYm1Xcml0ZXIwXzJfMCA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogQSB0b29sIGZvciBwcmVzZW50aW5nIGFuIEFycmF5QnVmZmVyIGFzIGEgc3RyZWFtIGZvciB3cml0aW5nIHNvbWUgc2ltcGxlIGRhdGEgdHlwZXMuXG4gKlxuICogQnkgTmljaG9sYXMgU2hlcmxvY2tcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgV1RGUEx2MiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XVEZQTFxuICovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNOb2RlRW52aXJvbWVudCA9ICdvYmplY3QnICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgaXNOb2RlRW52aXJvbWVudCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBBcnJheUJ1ZmZlciBvZiB0aGUgZ2l2ZW4gbGVuZ3RoIGFuZCBwcmVzZW50IGl0IGFzIGEgd3JpdGFibGUgc3RyZWFtIHdpdGggbWV0aG9kc1xuICAgICAqIGZvciB3cml0aW5nIGRhdGEgaW4gZGlmZmVyZW50IGZvcm1hdHMuXG4gICAgICovXG5cbiAgICB2YXIgQXJyYXlCdWZmZXJEYXRhU3RyZWFtID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9O1xuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgdGhpcy5wb3MgPSBvZmZzZXQ7XG4gICAgfTtcblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVCeXRlcyA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IGFycltpXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgdGhpcy5kYXRhW3RoaXMucG9zKytdID0gYjtcbiAgICB9OyAvL1N5bm9ueW06XG5cblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVVOCA9IEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVCeXRlO1xuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZVUxNkJFID0gZnVuY3Rpb24gKHUpIHtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IHUgPj4gODtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IHU7XG4gICAgfTtcblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShuZXcgRmxvYXQ2NEFycmF5KFtkXSkuYnVmZmVyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IGJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud3JpdGVCeXRlKGJ5dGVzW2ldKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobmV3IEZsb2F0MzJBcnJheShbZF0pLmJ1ZmZlcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSBieXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndyaXRlQnl0ZShieXRlc1tpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSBhbiBBU0NJSSBzdHJpbmcgdG8gdGhlIHN0cmVhbVxuICAgICAqL1xuXG5cbiAgICBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgZ2l2ZW4gMzItYml0IGludGVnZXIgdG8gdGhlIHN0cmVhbSBhcyBhbiBFQk1MIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIHVzaW5nIHRoZSBnaXZlbiBieXRlIHdpZHRoXG4gICAgICogKHVzZSBtZWFzdXJlRUJNTFZhckludCkuXG4gICAgICpcbiAgICAgKiBObyBlcnJvciBjaGVja2luZyBpcyBwZXJmb3JtZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHN1cHBsaWVkIHdpZHRoIGlzIGNvcnJlY3QgZm9yIHRoZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGkgSW50ZWdlciB0byBiZSB3cml0dGVuXG4gICAgICogQHBhcmFtIHdpZHRoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZSB0byB0aGUgc3RyZWFtXG4gICAgICovXG5cblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVFQk1MVmFySW50V2lkdGggPSBmdW5jdGlvbiAoaSwgd2lkdGgpIHtcbiAgICAgIHN3aXRjaCAod2lkdGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMud3JpdGVVOCgxIDw8IDcgfCBpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDEgPDwgNiB8IGkgPj4gOCk7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMSA8PCA1IHwgaSA+PiAxNik7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkgPj4gOCk7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMSA8PCA0IHwgaSA+PiAyNCk7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkgPj4gMTYpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChpID4+IDgpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBKYXZhU2NyaXB0IGNvbnZlcnRzIGl0cyBkb3VibGVzIHRvIDMyLWJpdCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zLCBzbyB3ZSBuZWVkIHRvIGRvIGFcbiAgICAgICAgICAgKiBkaXZpc2lvbiBieSAyXjMyIGluc3RlYWQgb2YgYSByaWdodC1zaGlmdCBvZiAzMiB0byByZXRhaW4gdGhvc2UgdG9wIDMgYml0c1xuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMud3JpdGVVOCgxIDw8IDMgfCBpIC8gNDI5NDk2NzI5NiAmIDB4Nyk7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkgPj4gMjQpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChpID4+IDE2KTtcbiAgICAgICAgICB0aGlzLndyaXRlVTgoaSA+PiA4KTtcbiAgICAgICAgICB0aGlzLndyaXRlVTgoaSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignQmFkIEVCTUwgVklOVCBzaXplICcgKyB3aWR0aCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyBuZWVkZWQgdG8gZW5jb2RlIHRoZSBnaXZlbiBpbnRlZ2VyIGFzIGFuIEVCTUwgVklOVC5cbiAgICAgKi9cblxuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS5tZWFzdXJlRUJNTFZhckludCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGlmICh2YWwgPCAoMSA8PCA3KSAtIDEpIHtcbiAgICAgICAgLyogVG9wIGJpdCBpcyBzZXQsIGxlYXZpbmcgNyBiaXRzIHRvIGhvbGQgdGhlIGludGVnZXIsIGJ1dCB3ZSBjYW4ndCBzdG9yZSAxMjcgYmVjYXVzZVxuICAgICAgICAgKiBcImFsbCBiaXRzIHNldCB0byBvbmVcIiBpcyBhIHJlc2VydmVkIHZhbHVlLiBTYW1lIHRoaW5nIGZvciB0aGUgb3RoZXIgY2FzZXMgYmVsb3c6XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgKDEgPDwgMTQpIC0gMSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgKDEgPDwgMjEpIC0gMSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgKDEgPDwgMjgpIC0gMSkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgMzQzNTk3MzgzNjcpIHtcbiAgICAgICAgLy8gMiBeIDM1IC0gMSAoY2FuIGFkZHJlc3MgMzJHQilcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignRUJNTCBWSU5UIHNpemUgbm90IHN1cHBvcnRlZCAnICsgdmFsKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUVCTUxWYXJJbnQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgdGhpcy53cml0ZUVCTUxWYXJJbnRXaWR0aChpLCB0aGlzLm1lYXN1cmVFQk1MVmFySW50KGkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyaXRlIHRoZSBnaXZlbiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciB0byB0aGUgc3RyZWFtIGluIGJpZy1lbmRpYW4gb3JkZXIgdXNpbmcgdGhlIGdpdmVuIGJ5dGUgd2lkdGguXG4gICAgICogTm8gZXJyb3IgY2hlY2tpbmcgaXMgcGVyZm9ybWVkIHRvIGVuc3VyZSB0aGF0IHRoZSBzdXBwbGllZCB3aWR0aCBpcyBjb3JyZWN0IGZvciB0aGUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqIE9taXQgdGhlIHdpZHRoIHBhcmFtZXRlciB0byBoYXZlIGl0IGRldGVybWluZWQgYXV0b21hdGljYWxseSBmb3IgeW91LlxuICAgICAqXG4gICAgICogQHBhcmFtIHUgVW5zaWduZWQgaW50ZWdlciB0byBiZSB3cml0dGVuXG4gICAgICogQHBhcmFtIHdpZHRoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZSB0byB0aGUgc3RyZWFtXG4gICAgICovXG5cblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVVbnNpZ25lZEludEJFID0gZnVuY3Rpb24gKHUsIHdpZHRoKSB7XG4gICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3aWR0aCA9IHRoaXMubWVhc3VyZVVuc2lnbmVkSW50KHUpO1xuICAgICAgfSAvLyBFYWNoIGNhc2UgZmFsbHMgdGhyb3VnaDpcblxuXG4gICAgICBzd2l0Y2ggKHdpZHRoKSB7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICB0aGlzLndyaXRlVTgoTWF0aC5mbG9vcih1IC8gNDI5NDk2NzI5NikpO1xuICAgICAgICAvLyBOZWVkIHRvIHVzZSBkaXZpc2lvbiB0byBhY2Nlc3MgPjMyIGJpdHMgb2YgZmxvYXRpbmcgcG9pbnQgdmFyXG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHRoaXMud3JpdGVVOCh1ID4+IDI0KTtcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdGhpcy53cml0ZVU4KHUgPj4gMTYpO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aGlzLndyaXRlVTgodSA+PiA4KTtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhpcy53cml0ZVU4KHUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oJ0JhZCBVSU5UIHNpemUgJyArIHdpZHRoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCB0byBob2xkIHRoZSBub24temVybyBiaXRzIG9mIHRoZSBnaXZlbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAqL1xuXG5cbiAgICBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLm1lYXN1cmVVbnNpZ25lZEludCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIC8vIEZvcmNlIHRvIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyXG4gICAgICBpZiAodmFsIDwgMSA8PCA4KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPCAxIDw8IDE2KSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPCAxIDw8IDI0KSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB2aWV3IG9uIHRoZSBwb3J0aW9uIG9mIHRoZSBidWZmZXIgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIHRoZSBjdXJyZW50IHNlZWsgcG9zaXRpb24gYXMgYSBVaW50OEFycmF5LlxuICAgICAqL1xuXG5cbiAgICBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLmdldEFzRGF0YUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5kYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zdWJhcnJheSgwLCB0aGlzLnBvcyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucG9zID09IHRoaXMuZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIkFycmF5QnVmZmVyRGF0YVN0cmVhbSdzIHBvcyBsaWVzIGJleW9uZCBlbmQgb2YgYnVmZmVyXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5BcnJheUJ1ZmZlckRhdGFTdHJlYW0gPSBBcnJheUJ1ZmZlckRhdGFTdHJlYW07XG4gICAgLyoqXG4gICAgICogQWxsb3dzIGEgc2VyaWVzIG9mIEJsb2ItY29udmVydGlibGUgb2JqZWN0cyAoQXJyYXlCdWZmZXIsIEJsb2IsIFN0cmluZywgZXRjKSB0byBiZSBhZGRlZCB0byBhIGJ1ZmZlci4gU2Vla2luZyBhbmRcbiAgICAgKiBvdmVyd3JpdGluZyBvZiBibG9icyBpcyBhbGxvd2VkLlxuICAgICAqXG4gICAgICogWW91IGNhbiBzdXBwbHkgYSBGaWxlV3JpdGVyLCBpbiB3aGljaCBjYXNlIHRoZSBCbG9iQnVmZmVyIGlzIGp1c3QgdXNlZCBhcyB0ZW1wb3Jhcnkgc3RvcmFnZSBiZWZvcmUgaXQgd3JpdGVzIGl0XG4gICAgICogdGhyb3VnaCB0byB0aGUgZGlzay5cbiAgICAgKlxuICAgICAqIEJ5IE5pY2hvbGFzIFNoZXJsb2NrXG4gICAgICpcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgV1RGUEx2MiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XVEZQTFxuICAgICAqL1xuXG4gICAgdmFyIEJsb2JCdWZmZXIgPSBmdW5jdGlvbiAoZnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IFtdLFxuICAgICAgICAgICAgd3JpdGVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICAgICAgICBmaWxlV3JpdGVyID0gbnVsbCxcbiAgICAgICAgICAgIGZkID0gbnVsbDtcblxuICAgICAgICBpZiAodHlwZW9mIEZpbGVXcml0ZXIgIT09ICd1bmRlZmluZWQnICYmIGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgRmlsZVdyaXRlcikge1xuICAgICAgICAgIGZpbGVXcml0ZXIgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChmcyAmJiBkZXN0aW5hdGlvbikge1xuICAgICAgICAgIGZkID0gZGVzdGluYXRpb247XG4gICAgICAgIH0gLy8gQ3VycmVudCBzZWVrIG9mZnNldFxuXG5cbiAgICAgICAgdGhpcy5wb3MgPSAwOyAvLyBPbmUgbW9yZSB0aGFuIHRoZSBpbmRleCBvZiB0aGUgaGlnaGVzdCBieXRlIGV2ZXIgd3JpdHRlblxuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDsgLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBjb252ZXJ0cyB0aGUgYmxvYiB0byBhbiBBcnJheUJ1ZmZlclxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRCbG9iQXNCdWZmZXIoYmxvYikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb252ZXJ0VG9VaW50OEFycmF5KHRoaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGluZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHRoaW5nKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KHRoaW5nKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaW5nIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlYWRCbG9iQXNCdWZmZXIodGhpbmcpLnRoZW4oZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvL0Fzc3VtZSB0aGF0IEJsb2Igd2lsbCBrbm93IGhvdyB0byByZWFkIHRoaXMgdGhpbmdcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZWFkQmxvYkFzQnVmZmVyKG5ldyBCbG9iKFt0aGluZ10pKS50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVhc3VyZURhdGEoZGF0YSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5sZW5ndGggfHwgZGF0YS5zaXplO1xuXG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93ICdGYWlsZWQgdG8gZGV0ZXJtaW5lIHNpemUgb2YgZWxlbWVudCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlayB0byB0aGUgZ2l2ZW4gYWJzb2x1dGUgb2Zmc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgbWF5IG5vdCBzZWVrIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBmaWxlICh0aGlzIHdvdWxkIGNyZWF0ZSBhIGhvbGUgYW5kL29yIGFsbG93IGJsb2NrcyB0byBiZSB3cml0dGVuIGluIG5vbi1cbiAgICAgICAgICogc2VxdWVudGlhbCBvcmRlciwgd2hpY2ggaXNuJ3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgbWVtb3J5IGJ1ZmZlciBiYWNrZW5kKS5cbiAgICAgICAgICovXG5cblxuICAgICAgICB0aGlzLnNlZWsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHRocm93ICdPZmZzZXQgbWF5IG5vdCBiZSBuZWdhdGl2ZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93ICdPZmZzZXQgbWF5IG5vdCBiZSBOYU4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgJ1NlZWtpbmcgYmV5b25kIHRoZSBlbmQgb2YgZmlsZSBpcyBub3QgYWxsb3dlZCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wb3MgPSBvZmZzZXQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZSB0aGUgQmxvYi1jb252ZXJ0aWJsZSBkYXRhIHRvIHRoZSBidWZmZXIgYXQgdGhlIGN1cnJlbnQgc2VlayBwb3NpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogSWYgb3ZlcndyaXRpbmcgZXhpc3RpbmcgZGF0YSwgdGhlIHdyaXRlIG11c3Qgbm90IGNyb3NzIHByZWV4aXN0aW5nIGJsb2NrIGJvdW5kYXJpZXMgKHdyaXR0ZW4gZGF0YSBtdXN0XG4gICAgICAgICAqIGJlIGZ1bGx5IGNvbnRhaW5lZCBieSB0aGUgZXh0ZW50IG9mIGEgcHJldmlvdXMgd3JpdGUpLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIHRoaXMud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHZhciBuZXdFbnRyeSA9IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5wb3MsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbGVuZ3RoOiBtZWFzdXJlRGF0YShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGlzQXBwZW5kID0gbmV3RW50cnkub2Zmc2V0ID49IHRoaXMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMucG9zICs9IG5ld0VudHJ5Lmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCB0aGlzLnBvcyk7IC8vIEFmdGVyIHByZXZpb3VzIHdyaXRlcyBjb21wbGV0ZSwgcGVyZm9ybSBvdXIgd3JpdGVcblxuICAgICAgICAgIHdyaXRlUHJvbWlzZSA9IHdyaXRlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRUb1VpbnQ4QXJyYXkobmV3RW50cnkuZGF0YSkudGhlbihmdW5jdGlvbiAoZGF0YUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdG90YWxXcml0dGVuID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhQXJyYXkuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVXcml0ZUNvbXBsZXRlID0gZnVuY3Rpb24gKGVyciwgd3JpdHRlbiwgYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsV3JpdHRlbiArPSB3cml0dGVuO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbFdyaXR0ZW4gPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzdGlsbCBoYXZlIG1vcmUgdG8gd3JpdGUuLi5cbiAgICAgICAgICAgICAgICAgICAgICBmcy53cml0ZShmZCwgYnVmZmVyLCB0b3RhbFdyaXR0ZW4sIGJ1ZmZlci5sZW5ndGggLSB0b3RhbFdyaXR0ZW4sIG5ld0VudHJ5Lm9mZnNldCArIHRvdGFsV3JpdHRlbiwgaGFuZGxlV3JpdGVDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIGZzLndyaXRlKGZkLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgsIG5ld0VudHJ5Lm9mZnNldCwgaGFuZGxlV3JpdGVDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlV3JpdGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgZmlsZVdyaXRlci5vbndyaXRlZW5kID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLnNlZWsobmV3RW50cnkub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLndyaXRlKG5ldyBCbG9iKFtuZXdFbnRyeS5kYXRhXSkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzQXBwZW5kKSB7XG4gICAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIG1vZGlmeWluZyBhIHdyaXRlIHRoYXQgd2FzIGFscmVhZHkgYnVmZmVyZWQgaW4gbWVtb3J5LlxuICAgICAgICAgICAgICAvLyBTbG93IGxpbmVhciBzZWFyY2ggdG8gZmluZCBhIGJsb2NrIHdlIG1pZ2h0IGJlIG92ZXJ3cml0aW5nXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gYnVmZmVyW2ldOyAvLyBJZiBvdXIgbmV3IGVudHJ5IG92ZXJsYXBzIHRoZSBvbGQgb25lIGluIGFueSB3YXkuLi5cblxuICAgICAgICAgICAgICAgIGlmICghKG5ld0VudHJ5Lm9mZnNldCArIG5ld0VudHJ5Lmxlbmd0aCA8PSBlbnRyeS5vZmZzZXQgfHwgbmV3RW50cnkub2Zmc2V0ID49IGVudHJ5Lm9mZnNldCArIGVudHJ5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdFbnRyeS5vZmZzZXQgPCBlbnRyeS5vZmZzZXQgfHwgbmV3RW50cnkub2Zmc2V0ICsgbmV3RW50cnkubGVuZ3RoID4gZW50cnkub2Zmc2V0ICsgZW50cnkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3ZlcndyaXRlIGNyb3NzZXMgYmxvYiBib3VuZGFyaWVzJyk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChuZXdFbnRyeS5vZmZzZXQgPT0gZW50cnkub2Zmc2V0ICYmIG5ld0VudHJ5Lmxlbmd0aCA9PSBlbnRyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb3Zlcndyb3RlIHRoZSBlbnRpcmUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuZGF0YSA9IG5ld0VudHJ5LmRhdGE7IC8vIFdlJ3JlIGRvbmVcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydFRvVWludDhBcnJheShlbnRyeS5kYXRhKS50aGVuKGZ1bmN0aW9uIChlbnRyeUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZW50cnkuZGF0YSA9IGVudHJ5QXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1VpbnQ4QXJyYXkobmV3RW50cnkuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKG5ld0VudHJ5QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXdFbnRyeS5kYXRhID0gbmV3RW50cnlBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5kYXRhLnNldChuZXdFbnRyeS5kYXRhLCBuZXdFbnRyeS5vZmZzZXQgLSBlbnRyeS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gRWxzZSBmYWxsIHRocm91Z2ggdG8gZG8gYSBzaW1wbGUgYXBwZW5kLCBhcyB3ZSBkaWRuJ3Qgb3ZlcndyaXRlIGFueSBwcmUtZXhpc3RpbmcgYmxvY2tzXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZmVyLnB1c2gobmV3RW50cnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluaXNoIGFsbCB3cml0ZXMgdG8gdGhlIGJ1ZmZlciwgcmV0dXJuaW5nIGEgcHJvbWlzZSB0aGF0IHNpZ25hbHMgd2hlbiB0aGF0IGlzIGNvbXBsZXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIEZpbGVXcml0ZXIgd2FzIG5vdCBwcm92aWRlZCwgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBhIEJsb2IgdGhhdCByZXByZXNlbnRzIHRoZSBjb21wbGV0ZWQgQmxvYkJ1ZmZlclxuICAgICAgICAgKiBjb250ZW50cy4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgaW4gYSBtaW1lVHlwZSB0byBiZSB1c2VkIGZvciB0aGlzIGJsb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgRmlsZVdyaXRlciB3YXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggbnVsbCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGZ1bmN0aW9uIChtaW1lVHlwZSkge1xuICAgICAgICAgIGlmIChmZCB8fCBmaWxlV3JpdGVyKSB7XG4gICAgICAgICAgICB3cml0ZVByb21pc2UgPSB3cml0ZVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFmdGVyIHdyaXRlcyBjb21wbGV0ZSB3ZSBuZWVkIHRvIG1lcmdlIHRoZSBidWZmZXIgdG8gZ2l2ZSB0byB0aGUgY2FsbGVyXG4gICAgICAgICAgICB3cml0ZVByb21pc2UgPSB3cml0ZVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJ1ZmZlcltpXS5kYXRhKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihyZXN1bHQsIHtcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd3JpdGVQcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9KGlzTm9kZUVudmlyb21lbnQgPyBudWxsIDogbnVsbCk7XG5cbiAgICB3aW5kb3cuQmxvYkJ1ZmZlciA9IEJsb2JCdWZmZXI7XG4gICAgLyoqXG4gICAgICogV2ViTSB2aWRlbyBlbmNvZGVyIGZvciBHb29nbGUgQ2hyb21lLiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHN1aXRhYmxlIGZvciBjcmVhdGluZyB2ZXJ5IGxhcmdlIHZpZGVvIGZpbGVzLCBiZWNhdXNlXG4gICAgICogaXQgY2FuIHN0cmVhbSBCbG9icyBkaXJlY3RseSB0byBhIEZpbGVXcml0ZXIgd2l0aG91dCBidWZmZXJpbmcgdGhlIGVudGlyZSB2aWRlbyBpbiBtZW1vcnkuXG4gICAgICpcbiAgICAgKiBXaGVuIEZpbGVXcml0ZXIgaXMgbm90IGF2YWlsYWJsZSBvciBub3QgZGVzaXJlZCwgaXQgY2FuIGJ1ZmZlciB0aGUgdmlkZW8gaW4gbWVtb3J5IGFzIGEgc2VyaWVzIG9mIEJsb2JzIHdoaWNoIGFyZVxuICAgICAqIGV2ZW50dWFsbHkgcmV0dXJuZWQgYXMgb25lIGNvbXBvc2l0ZSBCbG9iLlxuICAgICAqXG4gICAgICogQnkgTmljaG9sYXMgU2hlcmxvY2suXG4gICAgICpcbiAgICAgKiBCYXNlZCBvbiB0aGUgaWRlYXMgZnJvbSBXaGFtbXk6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRpbWF0dGVyMTUvd2hhbW15XG4gICAgICpcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgV1RGUEx2MiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XVEZQTFxuICAgICAqL1xuXG4gICAgdmFyIFdlYk1Xcml0ZXIgPSBmdW5jdGlvbiAoQXJyYXlCdWZmZXJEYXRhU3RyZWFtLCBCbG9iQnVmZmVyKSB7XG4gICAgICBmdW5jdGlvbiBleHRlbmQoYmFzZSwgdG9wKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgICAgW2Jhc2UsIHRvcF0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlIGEgQmFzZTY0IGRhdGEgVVJMIGludG8gYSBiaW5hcnkgc3RyaW5nLlxuICAgICAgICpcbiAgICAgICAqIFJldHVybnMgdGhlIGJpbmFyeSBzdHJpbmcsIG9yIGZhbHNlIGlmIHRoZSBVUkwgY291bGQgbm90IGJlIGRlY29kZWQuXG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiBkZWNvZGVCYXNlNjRXZWJQRGF0YVVSTCh1cmwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8ICF1cmwubWF0Y2goL15kYXRhOmltYWdlXFwvd2VicDtiYXNlNjQsL2kpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5hdG9iKHVybC5zdWJzdHJpbmcoJ2RhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsJy5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydCB0aGUgZ2l2ZW4gY2FudmFzIHRvIGEgV2ViUCBlbmNvZGVkIGltYWdlIGFuZCByZXR1cm4gdGhlIGltYWdlIGRhdGEgYXMgYSBzdHJpbmcuXG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiByZW5kZXJBc1dlYlAoY2FudmFzLCBxdWFsaXR5KSB7XG4gICAgICAgIHZhciBmcmFtZSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3dlYnAnLCB7XG4gICAgICAgICAgcXVhbGl0eTogcXVhbGl0eVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlY29kZUJhc2U2NFdlYlBEYXRhVVJMKGZyYW1lKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXh0cmFjdEtleWZyYW1lRnJvbVdlYlAod2ViUCkge1xuICAgICAgICAvLyBBc3N1bWUgdGhhdCBDaHJvbWUgd2lsbCBnZW5lcmF0ZSBhIFNpbXBsZSBMb3NzeSBXZWJQIHdoaWNoIGhhcyB0aGlzIGhlYWRlcjpcbiAgICAgICAgdmFyIGtleWZyYW1lU3RhcnRJbmRleCA9IHdlYlAuaW5kZXhPZignVlA4ICcpO1xuXG4gICAgICAgIGlmIChrZXlmcmFtZVN0YXJ0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyAnRmFpbGVkIHRvIGlkZW50aWZ5IGJlZ2lubmluZyBvZiBrZXlmcmFtZSBpbiBXZWJQIGltYWdlJztcbiAgICAgICAgfSAvLyBTa2lwIHRoZSBoZWFkZXIgYW5kIHRoZSA0IGJ5dGVzIHRoYXQgZW5jb2RlIHRoZSBsZW5ndGggb2YgdGhlIFZQOCBjaHVua1xuXG5cbiAgICAgICAga2V5ZnJhbWVTdGFydEluZGV4ICs9ICdWUDggJy5sZW5ndGggKyA0O1xuICAgICAgICByZXR1cm4gd2ViUC5zdWJzdHJpbmcoa2V5ZnJhbWVTdGFydEluZGV4KTtcbiAgICAgIH0gLy8gSnVzdCBhIGxpdHRsZSB1dGlsaXR5IHNvIHdlIGNhbiB0YWcgdmFsdWVzIGFzIGZsb2F0cyBmb3IgdGhlIEVCTUwgZW5jb2RlcidzIGJlbmVmaXRcblxuXG4gICAgICBmdW5jdGlvbiBFQk1MRmxvYXQzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEVCTUxGbG9hdDY0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogV3JpdGUgdGhlIGdpdmVuIEVCTUwgb2JqZWN0IHRvIHRoZSBwcm92aWRlZCBBcnJheUJ1ZmZlclN0cmVhbS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYnVmZmVyJ3MgZmlyc3QgYnl0ZSBpcyBhdCBidWZmZXJGaWxlT2Zmc2V0IGluc2lkZSB0aGUgdmlkZW8gZmlsZS4gVGhpcyBpcyB1c2VkIHRvIGNvbXBsZXRlIG9mZnNldCBhbmRcbiAgICAgICAqIGRhdGFPZmZzZXQgZmllbGRzIGluIGVhY2ggRUJNTCBzdHJ1Y3R1cmUsIGluZGljYXRpbmcgdGhlIGZpbGUgb2Zmc2V0IG9mIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBFQk1MIGVsZW1lbnQgYW5kXG4gICAgICAgKiBpdHMgZGF0YSBwYXlsb2FkLlxuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gd3JpdGVFQk1MKGJ1ZmZlciwgYnVmZmVyRmlsZU9mZnNldCwgZWJtbCkge1xuICAgICAgICAvLyBJcyB0aGUgZWJtbCBhbiBhcnJheSBvZiBzaWJsaW5nIGVsZW1lbnRzP1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlYm1sKSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWJtbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVFQk1MKGJ1ZmZlciwgYnVmZmVyRmlsZU9mZnNldCwgZWJtbFtpXSk7XG4gICAgICAgICAgfSAvLyBJcyB0aGlzIHNvbWUgc29ydCBvZiByYXcgZGF0YSB0aGF0IHdlIHdhbnQgdG8gd3JpdGUgZGlyZWN0bHk/XG5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZWJtbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBidWZmZXIud3JpdGVTdHJpbmcoZWJtbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWJtbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICBidWZmZXIud3JpdGVCeXRlcyhlYm1sKTtcbiAgICAgICAgfSBlbHNlIGlmIChlYm1sLmlkKSB7XG4gICAgICAgICAgLy8gV2UncmUgd3JpdGluZyBhbiBFQk1MIGVsZW1lbnRcbiAgICAgICAgICBlYm1sLm9mZnNldCA9IGJ1ZmZlci5wb3MgKyBidWZmZXJGaWxlT2Zmc2V0O1xuICAgICAgICAgIGJ1ZmZlci53cml0ZVVuc2lnbmVkSW50QkUoZWJtbC5pZCk7IC8vIElEIGZpZWxkXG4gICAgICAgICAgLy8gTm93IHdlIG5lZWQgdG8gd3JpdGUgdGhlIHNpemUgZmllbGQsIHNvIHdlIG11c3Qga25vdyB0aGUgcGF5bG9hZCBzaXplOlxuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWJtbC5kYXRhKSkge1xuICAgICAgICAgICAgLy8gV3JpdGluZyBhbiBhcnJheSBvZiBjaGlsZCBlbGVtZW50cy4gV2Ugd29uJ3QgdHJ5IHRvIG1lYXN1cmUgdGhlIHNpemUgb2YgdGhlIGNoaWxkcmVuIHVwLWZyb250XG4gICAgICAgICAgICB2YXIgc2l6ZVBvcywgZGF0YUJlZ2luLCBkYXRhRW5kO1xuXG4gICAgICAgICAgICBpZiAoZWJtbC5zaXplID09PSAtMSkge1xuICAgICAgICAgICAgICAvLyBXcml0ZSB0aGUgcmVzZXJ2ZWQgYWxsLW9uZS1iaXRzIG1hcmtlciB0byBub3RlIHRoYXQgdGhlIHNpemUgb2YgdGhpcyBlbGVtZW50IGlzIHVua25vd24vdW5ib3VuZGVkXG4gICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUJ5dGUoMHhmZik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzaXplUG9zID0gYnVmZmVyLnBvcztcbiAgICAgICAgICAgICAgLyogV3JpdGUgYSBkdW1teSBzaXplIGZpZWxkIHRvIG92ZXJ3cml0ZSBsYXRlci4gNCBieXRlcyBhbGxvd3MgYW4gZWxlbWVudCBtYXhpbXVtIHNpemUgb2YgMjU2TUIsXG4gICAgICAgICAgICAgICAqIHdoaWNoIHNob3VsZCBiZSBwbGVudHkgKHdlIGRvbid0IHdhbnQgdG8gaGF2ZSB0byBidWZmZXIgdGhhdCBtdWNoIGRhdGEgaW4gbWVtb3J5IGF0IG9uZSB0aW1lXG4gICAgICAgICAgICAgICAqIGFueXdheSEpXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUJ5dGVzKFswLCAwLCAwLCAwXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGFCZWdpbiA9IGJ1ZmZlci5wb3M7XG4gICAgICAgICAgICBlYm1sLmRhdGFPZmZzZXQgPSBkYXRhQmVnaW4gKyBidWZmZXJGaWxlT2Zmc2V0O1xuICAgICAgICAgICAgd3JpdGVFQk1MKGJ1ZmZlciwgYnVmZmVyRmlsZU9mZnNldCwgZWJtbC5kYXRhKTtcblxuICAgICAgICAgICAgaWYgKGVibWwuc2l6ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZGF0YUVuZCA9IGJ1ZmZlci5wb3M7XG4gICAgICAgICAgICAgIGVibWwuc2l6ZSA9IGRhdGFFbmQgLSBkYXRhQmVnaW47XG4gICAgICAgICAgICAgIGJ1ZmZlci5zZWVrKHNpemVQb3MpO1xuICAgICAgICAgICAgICBidWZmZXIud3JpdGVFQk1MVmFySW50V2lkdGgoZWJtbC5zaXplLCA0KTsgLy8gU2l6ZSBmaWVsZFxuXG4gICAgICAgICAgICAgIGJ1ZmZlci5zZWVrKGRhdGFFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVibWwuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUVCTUxWYXJJbnQoZWJtbC5kYXRhLmxlbmd0aCk7IC8vIFNpemUgZmllbGRcblxuICAgICAgICAgICAgZWJtbC5kYXRhT2Zmc2V0ID0gYnVmZmVyLnBvcyArIGJ1ZmZlckZpbGVPZmZzZXQ7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVTdHJpbmcoZWJtbC5kYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlYm1sLmRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgY2FsbGVyIHRvIGV4cGxpY2l0bHkgY2hvb3NlIHRoZSBzaXplIGlmIHRoZXkgd2lzaCBieSBzdXBwbHlpbmcgYSBzaXplIGZpZWxkXG4gICAgICAgICAgICBpZiAoIWVibWwuc2l6ZSkge1xuICAgICAgICAgICAgICBlYm1sLnNpemUgPSBidWZmZXIubWVhc3VyZVVuc2lnbmVkSW50KGVibWwuZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUVCTUxWYXJJbnQoZWJtbC5zaXplKTsgLy8gU2l6ZSBmaWVsZFxuXG4gICAgICAgICAgICBlYm1sLmRhdGFPZmZzZXQgPSBidWZmZXIucG9zICsgYnVmZmVyRmlsZU9mZnNldDtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVuc2lnbmVkSW50QkUoZWJtbC5kYXRhLCBlYm1sLnNpemUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWJtbC5kYXRhIGluc3RhbmNlb2YgRUJNTEZsb2F0NjQpIHtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUVCTUxWYXJJbnQoOCk7IC8vIFNpemUgZmllbGRcblxuICAgICAgICAgICAgZWJtbC5kYXRhT2Zmc2V0ID0gYnVmZmVyLnBvcyArIGJ1ZmZlckZpbGVPZmZzZXQ7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVEb3VibGVCRShlYm1sLmRhdGEudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWJtbC5kYXRhIGluc3RhbmNlb2YgRUJNTEZsb2F0MzIpIHtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUVCTUxWYXJJbnQoNCk7IC8vIFNpemUgZmllbGRcblxuICAgICAgICAgICAgZWJtbC5kYXRhT2Zmc2V0ID0gYnVmZmVyLnBvcyArIGJ1ZmZlckZpbGVPZmZzZXQ7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVGbG9hdEJFKGVibWwuZGF0YS52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlYm1sLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVFQk1MVmFySW50KGVibWwuZGF0YS5ieXRlTGVuZ3RoKTsgLy8gU2l6ZSBmaWVsZFxuXG4gICAgICAgICAgICBlYm1sLmRhdGFPZmZzZXQgPSBidWZmZXIucG9zICsgYnVmZmVyRmlsZU9mZnNldDtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUJ5dGVzKGVibWwuZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdCYWQgRUJNTCBkYXRhdHlwZSAnICsgdHlwZW9mIGVibWwuZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgJ0JhZCBFQk1MIGRhdGF0eXBlICcgKyB0eXBlb2YgZWJtbC5kYXRhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgTUFYX0NMVVNURVJfRFVSQVRJT05fTVNFQyA9IDUwMDAsXG4gICAgICAgICAgICBERUZBVUxUX1RSQUNLX05VTUJFUiA9IDEsXG4gICAgICAgICAgICB3cml0dGVuSGVhZGVyID0gZmFsc2UsXG4gICAgICAgICAgICB2aWRlb1dpZHRoLFxuICAgICAgICAgICAgdmlkZW9IZWlnaHQsXG4gICAgICAgICAgICBjbHVzdGVyRnJhbWVCdWZmZXIgPSBbXSxcbiAgICAgICAgICAgIGNsdXN0ZXJTdGFydFRpbWUgPSAwLFxuICAgICAgICAgICAgY2x1c3RlckR1cmF0aW9uID0gMCxcbiAgICAgICAgICAgIG9wdGlvbkRlZmF1bHRzID0ge1xuICAgICAgICAgIHF1YWxpdHk6IDAuOTUsXG4gICAgICAgICAgLy8gV2ViTSBpbWFnZSBxdWFsaXR5IGZyb20gMC4wICh3b3JzdCkgdG8gMS4wIChiZXN0KVxuICAgICAgICAgIGZpbGVXcml0ZXI6IG51bGwsXG4gICAgICAgICAgLy8gQ2hyb21lIEZpbGVXcml0ZXIgaW4gb3JkZXIgdG8gc3RyZWFtIHRvIGEgZmlsZSBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyB0byBtZW1vcnkgKG9wdGlvbmFsKVxuICAgICAgICAgIGZkOiBudWxsLFxuICAgICAgICAgIC8vIE5vZGUuSlMgZmlsZSBkZXNjcmlwdG9yIHRvIHdyaXRlIHRvIGluc3RlYWQgb2YgYnVmZmVyaW5nIChvcHRpb25hbClcbiAgICAgICAgICAvLyBZb3UgbXVzdCBzdXBwbHkgb25lIG9mOlxuICAgICAgICAgIGZyYW1lRHVyYXRpb246IG51bGwsXG4gICAgICAgICAgLy8gRHVyYXRpb24gb2YgZnJhbWVzIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgIGZyYW1lUmF0ZTogbnVsbCAvLyBOdW1iZXIgb2YgZnJhbWVzIHBlciBzZWNvbmRcblxuICAgICAgICB9LFxuICAgICAgICAgICAgc2Vla1BvaW50cyA9IHtcbiAgICAgICAgICBDdWVzOiB7XG4gICAgICAgICAgICBpZDogbmV3IFVpbnQ4QXJyYXkoWzB4MWMsIDB4NTMsIDB4YmIsIDB4NmJdKSxcbiAgICAgICAgICAgIHBvc2l0aW9uRUJNTDogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgU2VnbWVudEluZm86IHtcbiAgICAgICAgICAgIGlkOiBuZXcgVWludDhBcnJheShbMHgxNSwgMHg0OSwgMHhhOSwgMHg2Nl0pLFxuICAgICAgICAgICAgcG9zaXRpb25FQk1MOiBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBUcmFja3M6IHtcbiAgICAgICAgICAgIGlkOiBuZXcgVWludDhBcnJheShbMHgxNiwgMHg1NCwgMHhhZSwgMHg2Yl0pLFxuICAgICAgICAgICAgcG9zaXRpb25FQk1MOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAgICAgZWJtbFNlZ21lbnQsXG4gICAgICAgICAgICBzZWdtZW50RHVyYXRpb24gPSB7XG4gICAgICAgICAgaWQ6IDB4NDQ4OSxcbiAgICAgICAgICAvLyBEdXJhdGlvblxuICAgICAgICAgIGRhdGE6IG5ldyBFQk1MRmxvYXQ2NCgwKVxuICAgICAgICB9LFxuICAgICAgICAgICAgc2Vla0hlYWQsXG4gICAgICAgICAgICBjdWVzID0gW10sXG4gICAgICAgICAgICBibG9iQnVmZmVyID0gbmV3IEJsb2JCdWZmZXIob3B0aW9ucy5maWxlV3JpdGVyIHx8IG9wdGlvbnMuZmQpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpbGVPZmZzZXRUb1NlZ21lbnRSZWxhdGl2ZShmaWxlT2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZpbGVPZmZzZXQgLSBlYm1sU2VnbWVudC5kYXRhT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBTZWVrSGVhZCBlbGVtZW50IHdpdGggZGVzY3JpcHRvcnMgZm9yIHRoZSBwb2ludHMgaW4gdGhlIGdsb2JhbCBzZWVrUG9pbnRzIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA1IGJ5dGVzIG9mIHBvc2l0aW9uIHZhbHVlcyBhcmUgcmVzZXJ2ZWQgZm9yIGVhY2ggbm9kZSwgd2hpY2ggbGllIGF0IHRoZSBvZmZzZXQgcG9pbnQucG9zaXRpb25FQk1MLmRhdGFPZmZzZXQsXG4gICAgICAgICAqIHRvIGJlIG92ZXJ3cml0dGVuIGxhdGVyLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlZWtIZWFkKCkge1xuICAgICAgICAgIHZhciBzZWVrUG9zaXRpb25FQk1MVGVtcGxhdGUgPSB7XG4gICAgICAgICAgICBpZDogMHg1M2FjLFxuICAgICAgICAgICAgLy8gU2Vla1Bvc2l0aW9uXG4gICAgICAgICAgICBzaXplOiA1LFxuICAgICAgICAgICAgLy8gQWxsb3dzIGZvciAzMkdCIHZpZGVvIGZpbGVzXG4gICAgICAgICAgICBkYXRhOiAwIC8vIFdlJ2xsIG92ZXJ3cml0ZSB0aGlzIHdoZW4gdGhlIGZpbGUgaXMgY29tcGxldGVcblxuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGlkOiAweDExNGQ5Yjc0LFxuICAgICAgICAgICAgLy8gU2Vla0hlYWRcbiAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc2Vla1BvaW50cykge1xuICAgICAgICAgICAgdmFyIHNlZWtQb2ludCA9IHNlZWtQb2ludHNbbmFtZV07XG4gICAgICAgICAgICBzZWVrUG9pbnQucG9zaXRpb25FQk1MID0gT2JqZWN0LmNyZWF0ZShzZWVrUG9zaXRpb25FQk1MVGVtcGxhdGUpO1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiAweDRkYmIsXG4gICAgICAgICAgICAgIC8vIFNlZWtcbiAgICAgICAgICAgICAgZGF0YTogW3tcbiAgICAgICAgICAgICAgICBpZDogMHg1M2FiLFxuICAgICAgICAgICAgICAgIC8vIFNlZWtJRFxuICAgICAgICAgICAgICAgIGRhdGE6IHNlZWtQb2ludC5pZFxuICAgICAgICAgICAgICB9LCBzZWVrUG9pbnQucG9zaXRpb25FQk1MXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGUgdGhlIFdlYk0gZmlsZSBoZWFkZXIgdG8gdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiB3cml0ZUhlYWRlcigpIHtcbiAgICAgICAgICBzZWVrSGVhZCA9IGNyZWF0ZVNlZWtIZWFkKCk7XG4gICAgICAgICAgdmFyIGVibWxIZWFkZXIgPSB7XG4gICAgICAgICAgICBpZDogMHgxYTQ1ZGZhMyxcbiAgICAgICAgICAgIC8vIEVCTUxcbiAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgIGlkOiAweDQyODYsXG4gICAgICAgICAgICAgIC8vIEVCTUxWZXJzaW9uXG4gICAgICAgICAgICAgIGRhdGE6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgaWQ6IDB4NDJmNyxcbiAgICAgICAgICAgICAgLy8gRUJNTFJlYWRWZXJzaW9uXG4gICAgICAgICAgICAgIGRhdGE6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgaWQ6IDB4NDJmMixcbiAgICAgICAgICAgICAgLy8gRUJNTE1heElETGVuZ3RoXG4gICAgICAgICAgICAgIGRhdGE6IDRcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgaWQ6IDB4NDJmMyxcbiAgICAgICAgICAgICAgLy8gRUJNTE1heFNpemVMZW5ndGhcbiAgICAgICAgICAgICAgZGF0YTogOFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBpZDogMHg0MjgyLFxuICAgICAgICAgICAgICAvLyBEb2NUeXBlXG4gICAgICAgICAgICAgIGRhdGE6ICd3ZWJtJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBpZDogMHg0Mjg3LFxuICAgICAgICAgICAgICAvLyBEb2NUeXBlVmVyc2lvblxuICAgICAgICAgICAgICBkYXRhOiAyXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGlkOiAweDQyODUsXG4gICAgICAgICAgICAgIC8vIERvY1R5cGVSZWFkVmVyc2lvblxuICAgICAgICAgICAgICBkYXRhOiAyXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNlZ21lbnRJbmZvID0ge1xuICAgICAgICAgICAgaWQ6IDB4MTU0OWE5NjYsXG4gICAgICAgICAgICAvLyBJbmZvXG4gICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICBpZDogMHgyYWQ3YjEsXG4gICAgICAgICAgICAgIC8vIFRpbWVjb2RlU2NhbGVcbiAgICAgICAgICAgICAgZGF0YTogMWU2IC8vIFRpbWVzIHdpbGwgYmUgaW4gbWlsaXNlY29uZHMgKDFlNiBuYW5vc2Vjb25kcyBwZXIgc3RlcCA9IDFtcylcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBpZDogMHg0ZDgwLFxuICAgICAgICAgICAgICAvLyBNdXhpbmdBcHBcbiAgICAgICAgICAgICAgZGF0YTogJ3dlYm0td3JpdGVyLWpzJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBpZDogMHg1NzQxLFxuICAgICAgICAgICAgICAvLyBXcml0aW5nQXBwXG4gICAgICAgICAgICAgIGRhdGE6ICd3ZWJtLXdyaXRlci1qcydcbiAgICAgICAgICAgIH0sIHNlZ21lbnREdXJhdGlvbiAvLyBUbyBiZSBmaWxsZWQgaW4gbGF0ZXJcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0cmFja3MgPSB7XG4gICAgICAgICAgICBpZDogMHgxNjU0YWU2YixcbiAgICAgICAgICAgIC8vIFRyYWNrc1xuICAgICAgICAgICAgZGF0YTogW3tcbiAgICAgICAgICAgICAgaWQ6IDB4YWUsXG4gICAgICAgICAgICAgIC8vIFRyYWNrRW50cnlcbiAgICAgICAgICAgICAgZGF0YTogW3tcbiAgICAgICAgICAgICAgICBpZDogMHhkNyxcbiAgICAgICAgICAgICAgICAvLyBUcmFja051bWJlclxuICAgICAgICAgICAgICAgIGRhdGE6IERFRkFVTFRfVFJBQ0tfTlVNQkVSXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBpZDogMHg3M2M1LFxuICAgICAgICAgICAgICAgIC8vIFRyYWNrVUlEXG4gICAgICAgICAgICAgICAgZGF0YTogREVGQVVMVF9UUkFDS19OVU1CRVJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGlkOiAweDljLFxuICAgICAgICAgICAgICAgIC8vIEZsYWdMYWNpbmdcbiAgICAgICAgICAgICAgICBkYXRhOiAwXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBpZDogMHgyMmI1OWMsXG4gICAgICAgICAgICAgICAgLy8gTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICBkYXRhOiAndW5kJ1xuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaWQ6IDB4ODYsXG4gICAgICAgICAgICAgICAgLy8gQ29kZWNJRFxuICAgICAgICAgICAgICAgIGRhdGE6ICdWX1ZQOCdcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGlkOiAweDI1ODY4OCxcbiAgICAgICAgICAgICAgICAvLyBDb2RlY05hbWVcbiAgICAgICAgICAgICAgICBkYXRhOiAnVlA4J1xuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaWQ6IDB4ODMsXG4gICAgICAgICAgICAgICAgLy8gVHJhY2tUeXBlXG4gICAgICAgICAgICAgICAgZGF0YTogMVxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaWQ6IDB4ZTAsXG4gICAgICAgICAgICAgICAgLy8gVmlkZW9cbiAgICAgICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICAgICAgaWQ6IDB4YjAsXG4gICAgICAgICAgICAgICAgICAvLyBQaXhlbFdpZHRoXG4gICAgICAgICAgICAgICAgICBkYXRhOiB2aWRlb1dpZHRoXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgaWQ6IDB4YmEsXG4gICAgICAgICAgICAgICAgICAvLyBQaXhlbEhlaWdodFxuICAgICAgICAgICAgICAgICAgZGF0YTogdmlkZW9IZWlnaHRcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGVibWxTZWdtZW50ID0ge1xuICAgICAgICAgICAgaWQ6IDB4MTg1MzgwNjcsXG4gICAgICAgICAgICAvLyBTZWdtZW50XG4gICAgICAgICAgICBzaXplOiAtMSxcbiAgICAgICAgICAgIC8vIFVuYm91bmRlZCBzaXplXG4gICAgICAgICAgICBkYXRhOiBbc2Vla0hlYWQsIHNlZ21lbnRJbmZvLCB0cmFja3NdXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgYnVmZmVyU3RyZWFtID0gbmV3IEFycmF5QnVmZmVyRGF0YVN0cmVhbSgyNTYpO1xuICAgICAgICAgIHdyaXRlRUJNTChidWZmZXJTdHJlYW0sIGJsb2JCdWZmZXIucG9zLCBbZWJtbEhlYWRlciwgZWJtbFNlZ21lbnRdKTtcbiAgICAgICAgICBibG9iQnVmZmVyLndyaXRlKGJ1ZmZlclN0cmVhbS5nZXRBc0RhdGFBcnJheSgpKTsgLy8gTm93IHdlIGtub3cgd2hlcmUgdGhlc2UgdG9wLWxldmVsIGVsZW1lbnRzIGxpZSBpbiB0aGUgZmlsZTpcblxuICAgICAgICAgIHNlZWtQb2ludHMuU2VnbWVudEluZm8ucG9zaXRpb25FQk1MLmRhdGEgPSBmaWxlT2Zmc2V0VG9TZWdtZW50UmVsYXRpdmUoc2VnbWVudEluZm8ub2Zmc2V0KTtcbiAgICAgICAgICBzZWVrUG9pbnRzLlRyYWNrcy5wb3NpdGlvbkVCTUwuZGF0YSA9IGZpbGVPZmZzZXRUb1NlZ21lbnRSZWxhdGl2ZSh0cmFja3Mub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgU2ltcGxlQmxvY2sga2V5ZnJhbWUgaGVhZGVyIHVzaW5nIHRoZXNlIGZpZWxkczpcbiAgICAgICAgICogICAgIHRpbWVjb2RlICAgIC0gVGltZSBvZiB0aGlzIGtleWZyYW1lXG4gICAgICAgICAqICAgICB0cmFja051bWJlciAtIFRyYWNrIG51bWJlciBmcm9tIDEgdG8gMTI2IChpbmNsdXNpdmUpXG4gICAgICAgICAqICAgICBmcmFtZSAgICAgICAtIFJhdyBmcmFtZSBkYXRhIHBheWxvYWQgc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgYW4gRUJNTCBlbGVtZW50LlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUtleWZyYW1lQmxvY2soa2V5ZnJhbWUpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyU3RyZWFtID0gbmV3IEFycmF5QnVmZmVyRGF0YVN0cmVhbSgxICsgMiArIDEpO1xuXG4gICAgICAgICAgaWYgKCEoa2V5ZnJhbWUudHJhY2tOdW1iZXIgPiAwICYmIGtleWZyYW1lLnRyYWNrTnVtYmVyIDwgMTI3KSkge1xuICAgICAgICAgICAgdGhyb3cgJ1RyYWNrTnVtYmVyIG11c3QgYmUgPiAwIGFuZCA8IDEyNyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnVmZmVyU3RyZWFtLndyaXRlRUJNTFZhckludChrZXlmcmFtZS50cmFja051bWJlcik7IC8vIEFsd2F5cyAxIGJ5dGUgc2luY2Ugd2UgbGltaXQgdGhlIHJhbmdlIG9mIHRyYWNrTnVtYmVyXG5cbiAgICAgICAgICBidWZmZXJTdHJlYW0ud3JpdGVVMTZCRShrZXlmcmFtZS50aW1lY29kZSk7IC8vIEZsYWdzIGJ5dGVcblxuICAgICAgICAgIGJ1ZmZlclN0cmVhbS53cml0ZUJ5dGUoMSA8PCA3IC8vIEtleWZyYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IDB4YTMsXG4gICAgICAgICAgICAvLyBTaW1wbGVCbG9ja1xuICAgICAgICAgICAgZGF0YTogW2J1ZmZlclN0cmVhbS5nZXRBc0RhdGFBcnJheSgpLCBrZXlmcmFtZS5mcmFtZV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBDbHVzdGVyIG5vZGUgdXNpbmcgdGhlc2UgZmllbGRzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICB0aW1lY29kZSAgICAtIFN0YXJ0IHRpbWUgZm9yIHRoZSBjbHVzdGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgYW4gRUJNTCBlbGVtZW50LlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNsdXN0ZXIoY2x1c3Rlcikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogMHgxZjQzYjY3NSxcbiAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgIGlkOiAweGU3LFxuICAgICAgICAgICAgICAvLyBUaW1lY29kZVxuICAgICAgICAgICAgICBkYXRhOiBNYXRoLnJvdW5kKGNsdXN0ZXIudGltZWNvZGUpXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDdWVQb2ludCh0cmFja0luZGV4LCBjbHVzdGVyVGltZSwgY2x1c3RlckZpbGVPZmZzZXQpIHtcbiAgICAgICAgICBjdWVzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IDB4YmIsXG4gICAgICAgICAgICAvLyBDdWVcbiAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgIGlkOiAweGIzLFxuICAgICAgICAgICAgICAvLyBDdWVUaW1lXG4gICAgICAgICAgICAgIGRhdGE6IGNsdXN0ZXJUaW1lXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGlkOiAweGI3LFxuICAgICAgICAgICAgICAvLyBDdWVUcmFja1Bvc2l0aW9uc1xuICAgICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICAgIGlkOiAweGY3LFxuICAgICAgICAgICAgICAgIC8vIEN1ZVRyYWNrXG4gICAgICAgICAgICAgICAgZGF0YTogdHJhY2tJbmRleFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaWQ6IDB4ZjEsXG4gICAgICAgICAgICAgICAgLy8gQ3VlQ2x1c3RlclBvc2l0aW9uXG4gICAgICAgICAgICAgICAgZGF0YTogZmlsZU9mZnNldFRvU2VnbWVudFJlbGF0aXZlKGNsdXN0ZXJGaWxlT2Zmc2V0KVxuICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGUgYSBDdWVzIGVsZW1lbnQgdG8gdGhlIGJsb2JTdHJlYW0gdXNpbmcgdGhlIGdsb2JhbCBgY3Vlc2AgYXJyYXkgb2YgQ3VlUG9pbnRzICh1c2UgYWRkQ3VlUG9pbnQoKSkuXG4gICAgICAgICAqIFRoZSBzZWVrIGVudHJ5IGZvciB0aGUgQ3VlcyBpbiB0aGUgU2Vla0hlYWQgaXMgdXBkYXRlZC5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiB3cml0ZUN1ZXMoKSB7XG4gICAgICAgICAgdmFyIGVibWwgPSB7XG4gICAgICAgICAgICBpZDogMHgxYzUzYmI2YixcbiAgICAgICAgICAgIGRhdGE6IGN1ZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjdWVzQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyRGF0YVN0cmVhbSgxNiArIGN1ZXMubGVuZ3RoICogMzIpOyAvLyBQcmV0dHkgY3J1ZGUgZXN0aW1hdGUgb2YgdGhlIGJ1ZmZlciBzaXplIHdlJ2xsIG5lZWRcblxuICAgICAgICAgIHdyaXRlRUJNTChjdWVzQnVmZmVyLCBibG9iQnVmZmVyLnBvcywgZWJtbCk7XG4gICAgICAgICAgYmxvYkJ1ZmZlci53cml0ZShjdWVzQnVmZmVyLmdldEFzRGF0YUFycmF5KCkpOyAvLyBOb3cgd2Uga25vdyB3aGVyZSB0aGUgQ3VlcyBlbGVtZW50IGhhcyBlbmRlZCB1cCwgd2UgY2FuIHVwZGF0ZSB0aGUgU2Vla0hlYWRcblxuICAgICAgICAgIHNlZWtQb2ludHMuQ3Vlcy5wb3NpdGlvbkVCTUwuZGF0YSA9IGZpbGVPZmZzZXRUb1NlZ21lbnRSZWxhdGl2ZShlYm1sLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsdXNoIHRoZSBmcmFtZXMgaW4gdGhlIGN1cnJlbnQgY2x1c3RlckZyYW1lQnVmZmVyIG91dCB0byB0aGUgc3RyZWFtIGFzIGEgQ2x1c3Rlci5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiBmbHVzaENsdXN0ZXJGcmFtZUJ1ZmZlcigpIHtcbiAgICAgICAgICBpZiAoY2x1c3RlckZyYW1lQnVmZmVyLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBGaXJzdCB3b3JrIG91dCBob3cgbGFyZ2Ugb2YgYSBidWZmZXIgd2UgbmVlZCB0byBob2xkIHRoZSBjbHVzdGVyIGRhdGFcblxuXG4gICAgICAgICAgdmFyIHJhd0ltYWdlU2l6ZSA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJGcmFtZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmF3SW1hZ2VTaXplICs9IGNsdXN0ZXJGcmFtZUJ1ZmZlcltpXS5mcmFtZS5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ocmF3SW1hZ2VTaXplICsgY2x1c3RlckZyYW1lQnVmZmVyLmxlbmd0aCAqIDMyKSxcbiAgICAgICAgICAgICAgLy8gRXN0aW1hdGUgMzIgYnl0ZXMgcGVyIFNpbXBsZUJsb2NrIGhlYWRlclxuICAgICAgICAgIGNsdXN0ZXIgPSBjcmVhdGVDbHVzdGVyKHtcbiAgICAgICAgICAgIHRpbWVjb2RlOiBNYXRoLnJvdW5kKGNsdXN0ZXJTdGFydFRpbWUpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJGcmFtZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2x1c3Rlci5kYXRhLnB1c2goY3JlYXRlS2V5ZnJhbWVCbG9jayhjbHVzdGVyRnJhbWVCdWZmZXJbaV0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3cml0ZUVCTUwoYnVmZmVyLCBibG9iQnVmZmVyLnBvcywgY2x1c3Rlcik7XG4gICAgICAgICAgYmxvYkJ1ZmZlci53cml0ZShidWZmZXIuZ2V0QXNEYXRhQXJyYXkoKSk7XG4gICAgICAgICAgYWRkQ3VlUG9pbnQoREVGQVVMVF9UUkFDS19OVU1CRVIsIE1hdGgucm91bmQoY2x1c3RlclN0YXJ0VGltZSksIGNsdXN0ZXIub2Zmc2V0KTtcbiAgICAgICAgICBjbHVzdGVyRnJhbWVCdWZmZXIgPSBbXTtcbiAgICAgICAgICBjbHVzdGVyU3RhcnRUaW1lICs9IGNsdXN0ZXJEdXJhdGlvbjtcbiAgICAgICAgICBjbHVzdGVyRHVyYXRpb24gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKCkge1xuICAgICAgICAgIC8vIERlcml2ZSBmcmFtZUR1cmF0aW9uIHNldHRpbmcgaWYgbm90IGFscmVhZHkgc3VwcGxpZWRcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuZnJhbWVEdXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZnJhbWVSYXRlKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyBvcHRpb25zLmZyYW1lUmF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93ICdNaXNzaW5nIHJlcXVpcmVkIGZyYW1lRHVyYXRpb24gb3IgZnJhbWVSYXRlIHNldHRpbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEZyYW1lVG9DbHVzdGVyKGZyYW1lKSB7XG4gICAgICAgICAgZnJhbWUudHJhY2tOdW1iZXIgPSBERUZBVUxUX1RSQUNLX05VTUJFUjsgLy8gRnJhbWUgdGltZWNvZGVzIGFyZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlaXIgY2x1c3RlcjpcblxuICAgICAgICAgIGZyYW1lLnRpbWVjb2RlID0gTWF0aC5yb3VuZChjbHVzdGVyRHVyYXRpb24pO1xuICAgICAgICAgIGNsdXN0ZXJGcmFtZUJ1ZmZlci5wdXNoKGZyYW1lKTtcbiAgICAgICAgICBjbHVzdGVyRHVyYXRpb24gKz0gZnJhbWUuZHVyYXRpb247XG5cbiAgICAgICAgICBpZiAoY2x1c3RlckR1cmF0aW9uID49IE1BWF9DTFVTVEVSX0RVUkFUSU9OX01TRUMpIHtcbiAgICAgICAgICAgIGZsdXNoQ2x1c3RlckZyYW1lQnVmZmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXdyaXRlcyB0aGUgU2Vla0hlYWQgZWxlbWVudCB0aGF0IHdhcyBpbml0aWFsbHkgd3JpdHRlbiB0byB0aGUgc3RyZWFtIHdpdGggdGhlIG9mZnNldHMgb2YgdG9wIGxldmVsIGVsZW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWxsIG9uY2Ugd3JpdGluZyBpcyBjb21wbGV0ZSAoc28gdGhlIG9mZnNldCBvZiBhbGwgdG9wIGxldmVsIGVsZW1lbnRzIGlzIGtub3duKS5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiByZXdyaXRlU2Vla0hlYWQoKSB7XG4gICAgICAgICAgdmFyIHNlZWtIZWFkQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyRGF0YVN0cmVhbShzZWVrSGVhZC5zaXplKSxcbiAgICAgICAgICAgICAgb2xkUG9zID0gYmxvYkJ1ZmZlci5wb3M7IC8vIFdyaXRlIHRoZSByZXdyaXR0ZW4gU2Vla0hlYWQgZWxlbWVudCdzIGRhdGEgcGF5bG9hZCB0byB0aGUgc3RyZWFtIChkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgaWQgb3Igc2l6ZSlcblxuICAgICAgICAgIHdyaXRlRUJNTChzZWVrSGVhZEJ1ZmZlciwgc2Vla0hlYWQuZGF0YU9mZnNldCwgc2Vla0hlYWQuZGF0YSk7IC8vIEFuZCB3cml0ZSB0aGF0IHRocm91Z2ggdG8gdGhlIGZpbGVcblxuICAgICAgICAgIGJsb2JCdWZmZXIuc2VlayhzZWVrSGVhZC5kYXRhT2Zmc2V0KTtcbiAgICAgICAgICBibG9iQnVmZmVyLndyaXRlKHNlZWtIZWFkQnVmZmVyLmdldEFzRGF0YUFycmF5KCkpO1xuICAgICAgICAgIGJsb2JCdWZmZXIuc2VlayhvbGRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXdyaXRlIHRoZSBEdXJhdGlvbiBmaWVsZCBvZiB0aGUgU2VnbWVudCB3aXRoIHRoZSBuZXdseS1kaXNjb3ZlcmVkIHZpZGVvIGR1cmF0aW9uLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGZ1bmN0aW9uIHJld3JpdGVEdXJhdGlvbigpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyRGF0YVN0cmVhbSg4KSxcbiAgICAgICAgICAgICAgb2xkUG9zID0gYmxvYkJ1ZmZlci5wb3M7IC8vIFJld3JpdGUgdGhlIGRhdGEgcGF5bG9hZCAoZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIGlkIG9yIHNpemUpXG5cbiAgICAgICAgICBidWZmZXIud3JpdGVEb3VibGVCRShjbHVzdGVyU3RhcnRUaW1lKTsgLy8gQW5kIHdyaXRlIHRoYXQgdGhyb3VnaCB0byB0aGUgZmlsZVxuXG4gICAgICAgICAgYmxvYkJ1ZmZlci5zZWVrKHNlZ21lbnREdXJhdGlvbi5kYXRhT2Zmc2V0KTtcbiAgICAgICAgICBibG9iQnVmZmVyLndyaXRlKGJ1ZmZlci5nZXRBc0RhdGFBcnJheSgpKTtcbiAgICAgICAgICBibG9iQnVmZmVyLnNlZWsob2xkUG9zKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgZnJhbWUgdG8gdGhlIHZpZGVvLiBDdXJyZW50bHkgdGhlIGZyYW1lIG11c3QgYmUgYSBDYW52YXMgZWxlbWVudC5cbiAgICAgICAgICovXG5cblxuICAgICAgICB0aGlzLmFkZEZyYW1lID0gZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgICAgIGlmICh3cml0dGVuSGVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9IHZpZGVvV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPSB2aWRlb0hlaWdodCkge1xuICAgICAgICAgICAgICB0aHJvdyAnRnJhbWUgc2l6ZSBkaWZmZXJzIGZyb20gcHJldmlvdXMgZnJhbWVzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlkZW9XaWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIHZpZGVvSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIHdyaXRlSGVhZGVyKCk7XG4gICAgICAgICAgICB3cml0dGVuSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgd2ViUCA9IHJlbmRlckFzV2ViUChjYW52YXMsIHtcbiAgICAgICAgICAgIHF1YWxpdHk6IG9wdGlvbnMucXVhbGl0eVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCF3ZWJQKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNvdWxkbid0IGRlY29kZSBXZWJQIGZyYW1lLCBkb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgV2ViUD9cIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRGcmFtZVRvQ2x1c3Rlcih7XG4gICAgICAgICAgICBmcmFtZTogZXh0cmFjdEtleWZyYW1lRnJvbVdlYlAod2ViUCksXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5mcmFtZUR1cmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5pc2ggd3JpdGluZyB0aGUgdmlkZW8gYW5kIHJldHVybiBhIFByb21pc2UgdG8gc2lnbmFsIGNvbXBsZXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBkZXN0aW5hdGlvbiBkZXZpY2Ugd2FzIG1lbW9yeSAoaS5lLiBvcHRpb25zLmZpbGVXcml0ZXIgd2FzIG5vdCBzdXBwbGllZCksIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkIHdpdGhcbiAgICAgICAgICogYSBCbG9iIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBlbnRpcmUgdmlkZW8uXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmbHVzaENsdXN0ZXJGcmFtZUJ1ZmZlcigpO1xuICAgICAgICAgIHdyaXRlQ3VlcygpO1xuICAgICAgICAgIHJld3JpdGVTZWVrSGVhZCgpO1xuICAgICAgICAgIHJld3JpdGVEdXJhdGlvbigpO1xuICAgICAgICAgIHJldHVybiBibG9iQnVmZmVyLmNvbXBsZXRlKCd2aWRlby93ZWJtJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRXcml0dGVuU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gYmxvYkJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZChvcHRpb25EZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIHZhbGlkYXRlT3B0aW9ucygpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgaWYgKGlzTm9kZUVudmlyb21lbnQpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gV2ViTVdyaXRlcihBcnJheUJ1ZmZlckRhdGFTdHJlYW0sIEJsb2JCdWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuV2ViTVdyaXRlciA9IFdlYk1Xcml0ZXIoQXJyYXlCdWZmZXJEYXRhU3RyZWFtLCBCbG9iQnVmZmVyKTtcbiAgICB9XG4gIH0pKCk7XG59KSh3ZWJtV3JpdGVyMF8yXzApO1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFRhciA9IHdpbmRvdy5UYXI7XG4gICAgdmFyIGRvd25sb2FkID0gd2luZG93LmRvd25sb2FkO1xuICAgIHZhciBHSUYgPSB3aW5kb3cuR0lGO1xuICAgIHZhciBXZWJNV3JpdGVyID0gd2luZG93LldlYk1Xcml0ZXI7XG4gICAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICAgZnVuY3Rpb246IHRydWUsXG4gICAgICBvYmplY3Q6IHRydWVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hlY2tHbG9iYWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5PYmplY3QgPT09IE9iamVjdCA/IHZhbHVlIDogbnVsbDtcbiAgICB9XG4gICAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cblxuICAgIHZhciBmcmVlRXhwb3J0cyA9IGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgPyBleHBvcnRzIDogdW5kZWZpbmVkO1xuICAgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cblxuICAgIHZhciBmcmVlTW9kdWxlID0gbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgPyBtb2R1bGUgOiB1bmRlZmluZWQ7XG4gICAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cblxuICAgIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzID8gZnJlZUV4cG9ydHMgOiB1bmRlZmluZWQ7XG4gICAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cblxuICAgIHZhciBmcmVlR2xvYmFsID0gY2hlY2tHbG9iYWwoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpO1xuICAgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG5cbiAgICB2YXIgZnJlZVNlbGYgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZik7XG4gICAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGB3aW5kb3dgLiAqL1xuXG4gICAgdmFyIGZyZWVXaW5kb3cgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpO1xuICAgIC8qKiBEZXRlY3QgYHRoaXNgIGFzIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuXG4gICAgdmFyIHRoaXNHbG9iYWwgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2YgdGhpc10gJiYgdGhpcyk7XG4gICAgLyoqXG4gICAgICogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFRoZSBgdGhpc2AgdmFsdWUgaXMgdXNlZCBpZiBpdCdzIHRoZSBnbG9iYWwgb2JqZWN0IHRvIGF2b2lkIEdyZWFzZW1vbmtleSdzXG4gICAgICogcmVzdHJpY3RlZCBgd2luZG93YCBvYmplY3QsIG90aGVyd2lzZSB0aGUgYHdpbmRvd2Agb2JqZWN0IGlzIHVzZWQuXG4gICAgICovXG5cbiAgICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVdpbmRvdyAhPT0gKHRoaXNHbG9iYWwgJiYgdGhpc0dsb2JhbC53aW5kb3cpICYmIGZyZWVXaW5kb3cgfHwgZnJlZVNlbGYgfHwgdGhpc0dsb2JhbCB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gICAgaWYgKCEoJ2djJyBpbiB3aW5kb3cpKSB7XG4gICAgICB3aW5kb3cuZ2MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIUhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS50b0Jsb2IpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUsICd0b0Jsb2InLCB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHR5cGUsIHF1YWxpdHkpIHtcbiAgICAgICAgICB2YXIgYmluU3RyID0gYXRvYih0aGlzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KS5zcGxpdCgnLCcpWzFdKSxcbiAgICAgICAgICAgICAgbGVuID0gYmluU3RyLmxlbmd0aCxcbiAgICAgICAgICAgICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGFycltpXSA9IGJpblN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhbGxiYWNrKG5ldyBCbG9iKFthcnJdLCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlIHx8ICdpbWFnZS9wbmcnXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIEBsaWNlbnNlIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcblxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoJ3BlcmZvcm1hbmNlJyBpbiB3aW5kb3cgPT0gZmFsc2UpIHtcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlID0ge307XG4gICAgICB9XG5cbiAgICAgIERhdGUubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0aGFua3MgSUU4XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICgnbm93JyBpbiB3aW5kb3cucGVyZm9ybWFuY2UgPT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KSB7XG4gICAgICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBub3dPZmZzZXQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIGZ1bmN0aW9uIHBhZChuKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKCcwMDAwMDAwJyArIG4pLnNsaWNlKC03KTtcbiAgICB9IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL0FkZC1vbnMvQ29kZV9zbmlwcGV0cy9UaW1lcnNcblxuXG4gICAgdmFyIGdfc3RhcnRUaW1lID0gd2luZG93LkRhdGUubm93KCk7XG5cbiAgICBmdW5jdGlvbiBndWlkKCkge1xuICAgICAgZnVuY3Rpb24gczQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ0NGcmFtZUVuY29kZXIoc2V0dGluZ3MpIHtcbiAgICAgIHZhciBfaGFuZGxlcnMgPSB7fTtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcblxuICAgICAgdGhpcy5vbiA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICBfaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcjtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IF9oYW5kbGVyc1tldmVudF07XG5cbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmZpbGVuYW1lID0gc2V0dGluZ3MubmFtZSB8fCBndWlkKCk7XG4gICAgICB0aGlzLmV4dGVuc2lvbiA9ICcnO1xuICAgICAgdGhpcy5taW1lVHlwZSA9ICcnO1xuICAgIH1cblxuICAgIENDRnJhbWVFbmNvZGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgQ0NGcmFtZUVuY29kZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIENDRnJhbWVFbmNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIENDRnJhbWVFbmNvZGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBDQ0ZyYW1lRW5jb2Rlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgQ0NGcmFtZUVuY29kZXIucHJvdG90eXBlLnNhZmVUb1Byb2NlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQ0NGcmFtZUVuY29kZXIucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RlcCBub3Qgc2V0IScpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDQ1RhckVuY29kZXIoc2V0dGluZ3MpIHtcbiAgICAgIENDRnJhbWVFbmNvZGVyLmNhbGwodGhpcywgc2V0dGluZ3MpO1xuICAgICAgdGhpcy5leHRlbnNpb24gPSAnLnRhcic7XG4gICAgICB0aGlzLm1pbWVUeXBlID0gJ2FwcGxpY2F0aW9uL3gtdGFyJztcbiAgICAgIHRoaXMuZmlsZUV4dGVuc2lvbiA9ICcnO1xuICAgICAgdGhpcy5iYXNlRmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgdGhpcy50YXBlID0gbnVsbDtcbiAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgdGhpcy5wYXJ0ID0gMTtcbiAgICAgIHRoaXMuZnJhbWVzID0gMDtcbiAgICB9XG5cbiAgICBDQ1RhckVuY29kZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDQ0ZyYW1lRW5jb2Rlci5wcm90b3R5cGUpO1xuXG4gICAgQ0NUYXJFbmNvZGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICBDQ1RhckVuY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRhcGUuYXBwZW5kKHBhZCh0aGlzLmNvdW50KSArIHRoaXMuZmlsZUV4dGVuc2lvbiwgbmV3IFVpbnQ4QXJyYXkoZmlsZVJlYWRlci5yZXN1bHQpKTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvU2F2ZVRpbWUgPiAwICYmIHRoaXMuZnJhbWVzIC8gdGhpcy5zZXR0aW5ncy5mcmFtZXJhdGUgPj0gdGhpcy5zZXR0aW5ncy5hdXRvU2F2ZVRpbWUpIHtcbiAgICAgICAgICB0aGlzLnNhdmUoZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZW5hbWUgPSB0aGlzLmJhc2VGaWxlbmFtZSArICctcGFydC0nICsgcGFkKHRoaXMucGFydCk7XG4gICAgICAgICAgICBkb3dubG9hZChibG9iLCB0aGlzLmZpbGVuYW1lICsgdGhpcy5leHRlbnNpb24sIHRoaXMubWltZVR5cGUpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50ICsgMTtcbiAgICAgICAgICAgIHRoaXMucGFydCsrO1xuICAgICAgICAgICAgdGhpcy5maWxlbmFtZSA9IHRoaXMuYmFzZUZpbGVuYW1lICsgJy1wYXJ0LScgKyBwYWQodGhpcy5wYXJ0KTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3RlcCgpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICAgIHRoaXMuZnJhbWVzKys7XG4gICAgICAgICAgdGhpcy5zdGVwKCk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICB9O1xuXG4gICAgQ0NUYXJFbmNvZGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayh0aGlzLnRhcGUuc2F2ZSgpKTtcbiAgICB9O1xuXG4gICAgQ0NUYXJFbmNvZGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50YXBlID0gbmV3IFRhcigpO1xuICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIENDUE5HRW5jb2RlcihzZXR0aW5ncykge1xuICAgICAgQ0NUYXJFbmNvZGVyLmNhbGwodGhpcywgc2V0dGluZ3MpO1xuICAgICAgdGhpcy50eXBlID0gJ2ltYWdlL3BuZyc7XG4gICAgICB0aGlzLmZpbGVFeHRlbnNpb24gPSAnLnBuZyc7XG4gICAgfVxuXG4gICAgQ0NQTkdFbmNvZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ0NUYXJFbmNvZGVyLnByb3RvdHlwZSk7XG5cbiAgICBDQ1BOR0VuY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgIGNhbnZhcy50b0Jsb2IoZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgQ0NUYXJFbmNvZGVyLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBibG9iKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy50eXBlKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQ0NKUEVHRW5jb2RlcihzZXR0aW5ncykge1xuICAgICAgQ0NUYXJFbmNvZGVyLmNhbGwodGhpcywgc2V0dGluZ3MpO1xuICAgICAgdGhpcy50eXBlID0gJ2ltYWdlL2pwZWcnO1xuICAgICAgdGhpcy5maWxlRXh0ZW5zaW9uID0gJy5qcGcnO1xuICAgICAgdGhpcy5xdWFsaXR5ID0gc2V0dGluZ3MucXVhbGl0eSAvIDEwMCB8fCAwLjg7XG4gICAgfVxuXG4gICAgQ0NKUEVHRW5jb2Rlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENDVGFyRW5jb2Rlci5wcm90b3R5cGUpO1xuXG4gICAgQ0NKUEVHRW5jb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgY2FudmFzLnRvQmxvYihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICBDQ1RhckVuY29kZXIucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIGJsb2IpO1xuICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLnR5cGUsIHRoaXMucXVhbGl0eSk7XG4gICAgfTtcbiAgICAvKlxuICAgIFdlYk0gRW5jb2RlclxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIENDV2ViTUVuY29kZXIoc2V0dGluZ3MpIHtcbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgICAgaWYgKGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3dlYnAnKS5zdWJzdHIoNSwgMTApICE9PSAnaW1hZ2Uvd2VicCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dlYlAgbm90IHN1cHBvcnRlZCAtIHRyeSBhbm90aGVyIGV4cG9ydCBmb3JtYXQnKTtcbiAgICAgIH1cblxuICAgICAgQ0NGcmFtZUVuY29kZXIuY2FsbCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgICB0aGlzLnF1YWxpdHkgPSBzZXR0aW5ncy5xdWFsaXR5IC8gMTAwIHx8IDAuODtcbiAgICAgIHRoaXMuZXh0ZW5zaW9uID0gJy53ZWJtJztcbiAgICAgIHRoaXMubWltZVR5cGUgPSAndmlkZW8vd2VibSc7XG4gICAgICB0aGlzLmJhc2VGaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICB0aGlzLmZyYW1lcmF0ZSA9IHNldHRpbmdzLmZyYW1lcmF0ZTtcbiAgICAgIHRoaXMuZnJhbWVzID0gMDtcbiAgICAgIHRoaXMucGFydCA9IDE7XG4gICAgICB0aGlzLnZpZGVvV3JpdGVyID0gbmV3IFdlYk1Xcml0ZXIoe1xuICAgICAgICBxdWFsaXR5OiB0aGlzLnF1YWxpdHksXG4gICAgICAgIGZpbGVXcml0ZXI6IG51bGwsXG4gICAgICAgIGZkOiBudWxsLFxuICAgICAgICBmcmFtZVJhdGU6IHRoaXMuZnJhbWVyYXRlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBDQ1dlYk1FbmNvZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ0NGcmFtZUVuY29kZXIucHJvdG90eXBlKTtcblxuICAgIENDV2ViTUVuY29kZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIENDV2ViTUVuY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgIHRoaXMudmlkZW9Xcml0ZXIuYWRkRnJhbWUoY2FudmFzKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b1NhdmVUaW1lID4gMCAmJiB0aGlzLmZyYW1lcyAvIHRoaXMuc2V0dGluZ3MuZnJhbWVyYXRlID49IHRoaXMuc2V0dGluZ3MuYXV0b1NhdmVUaW1lKSB7XG4gICAgICAgIHRoaXMuc2F2ZShmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICAgIHRoaXMuZmlsZW5hbWUgPSB0aGlzLmJhc2VGaWxlbmFtZSArICctcGFydC0nICsgcGFkKHRoaXMucGFydCk7XG4gICAgICAgICAgZG93bmxvYWQoYmxvYiwgdGhpcy5maWxlbmFtZSArIHRoaXMuZXh0ZW5zaW9uLCB0aGlzLm1pbWVUeXBlKTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLnBhcnQrKztcbiAgICAgICAgICB0aGlzLmZpbGVuYW1lID0gdGhpcy5iYXNlRmlsZW5hbWUgKyAnLXBhcnQtJyArIHBhZCh0aGlzLnBhcnQpO1xuICAgICAgICAgIHRoaXMuc3RlcCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcmFtZXMrKztcbiAgICAgICAgdGhpcy5zdGVwKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENDV2ViTUVuY29kZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudmlkZW9Xcml0ZXIuY29tcGxldGUoKS50aGVuKGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgQ0NXZWJNRW5jb2Rlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgIHRoaXMuZnJhbWVzID0gMDtcbiAgICAgIHRoaXMudmlkZW9Xcml0ZXIgPSBuZXcgV2ViTVdyaXRlcih7XG4gICAgICAgIHF1YWxpdHk6IHRoaXMucXVhbGl0eSxcbiAgICAgICAgZmlsZVdyaXRlcjogbnVsbCxcbiAgICAgICAgZmQ6IG51bGwsXG4gICAgICAgIGZyYW1lUmF0ZTogdGhpcy5mcmFtZXJhdGVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDQ0ZGTXBlZ1NlcnZlckVuY29kZXIoc2V0dGluZ3MpIHtcbiAgICAgIENDRnJhbWVFbmNvZGVyLmNhbGwodGhpcywgc2V0dGluZ3MpO1xuICAgICAgc2V0dGluZ3MucXVhbGl0eSA9IHNldHRpbmdzLnF1YWxpdHkgLyAxMDAgfHwgMC44O1xuICAgICAgdGhpcy5lbmNvZGVyID0gbmV3IEZGTXBlZ1NlcnZlci5WaWRlbyhzZXR0aW5ncyk7XG4gICAgICB0aGlzLmVuY29kZXIub24oJ3Byb2Nlc3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncHJvY2VzcycpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZW5jb2Rlci5vbignZmluaXNoZWQnLCBmdW5jdGlvbiAodXJsLCBzaXplKSB7XG4gICAgICAgIHZhciBjYiA9IHRoaXMuY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjYih1cmwsIHNpemUpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5lbmNvZGVyLm9uKCdwcm9ncmVzcycsIGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5vblByb2dyZXNzKSB7XG4gICAgICAgICAgdGhpcy5zZXR0aW5ncy5vblByb2dyZXNzKHByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZW5jb2Rlci5vbignZXJyb3InLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBhbGVydChKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIENDRkZNcGVnU2VydmVyRW5jb2Rlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENDRnJhbWVFbmNvZGVyLnByb3RvdHlwZSk7XG5cbiAgICBDQ0ZGTXBlZ1NlcnZlckVuY29kZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5lbmNvZGVyLnN0YXJ0KHRoaXMuc2V0dGluZ3MpO1xuICAgIH07XG5cbiAgICBDQ0ZGTXBlZ1NlcnZlckVuY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgIHRoaXMuZW5jb2Rlci5hZGQoY2FudmFzKTtcbiAgICB9O1xuXG4gICAgQ0NGRk1wZWdTZXJ2ZXJFbmNvZGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLmVuY29kZXIuZW5kKCk7XG4gICAgfTtcblxuICAgIENDRkZNcGVnU2VydmVyRW5jb2Rlci5wcm90b3R5cGUuc2FmZVRvUHJvY2VlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZXIuc2FmZVRvUHJvY2VlZCgpO1xuICAgIH07XG4gICAgLypcbiAgICBIVE1MQ2FudmFzRWxlbWVudC5jYXB0dXJlU3RyZWFtKClcbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBDQ1N0cmVhbUVuY29kZXIoc2V0dGluZ3MpIHtcbiAgICAgIENDRnJhbWVFbmNvZGVyLmNhbGwodGhpcywgc2V0dGluZ3MpO1xuICAgICAgdGhpcy5mcmFtZXJhdGUgPSB0aGlzLnNldHRpbmdzLmZyYW1lcmF0ZTtcbiAgICAgIHRoaXMudHlwZSA9ICd2aWRlby93ZWJtJztcbiAgICAgIHRoaXMuZXh0ZW5zaW9uID0gJy53ZWJtJztcbiAgICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcbiAgICAgIHRoaXMubWVkaWFSZWNvcmRlciA9IG51bGw7XG4gICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIH1cblxuICAgIENDU3RyZWFtRW5jb2Rlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENDRnJhbWVFbmNvZGVyLnByb3RvdHlwZSk7XG5cbiAgICBDQ1N0cmVhbUVuY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgIGlmICghdGhpcy5zdHJlYW0pIHtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSh0aGlzLmZyYW1lcmF0ZSk7XG4gICAgICAgIHRoaXMubWVkaWFSZWNvcmRlciA9IG5ldyBNZWRpYVJlY29yZGVyKHRoaXMuc3RyZWFtKTtcbiAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyLnN0YXJ0KCk7XG5cbiAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyLm9uZGF0YWF2YWlsYWJsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdGhpcy5jaHVua3MucHVzaChlLmRhdGEpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RlcCgpO1xuICAgIH07XG5cbiAgICBDQ1N0cmVhbUVuY29kZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMubWVkaWFSZWNvcmRlci5vbnN0b3AgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKHRoaXMuY2h1bmtzLCB7XG4gICAgICAgICAgdHlwZTogJ3ZpZGVvL3dlYm0nXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICBjYWxsYmFjayhibG9iKTtcbiAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgdGhpcy5tZWRpYVJlY29yZGVyLnN0b3AoKTtcbiAgICB9O1xuICAgIC8qZnVuY3Rpb24gQ0NHSUZFbmNvZGVyKCBzZXR0aW5ncyApIHtcbiAgICBDQ0ZyYW1lRW5jb2Rlci5jYWxsKCB0aGlzICk7XG4gICAgc2V0dGluZ3MucXVhbGl0eSA9IHNldHRpbmdzLnF1YWxpdHkgfHwgNjtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IEdJRkVuY29kZXIoKTtcbiAgICB0aGlzLmVuY29kZXIuc2V0UmVwZWF0KCAxICk7XG4gICAgXHR0aGlzLmVuY29kZXIuc2V0RGVsYXkoIHNldHRpbmdzLnN0ZXAgKTtcbiAgICBcdHRoaXMuZW5jb2Rlci5zZXRRdWFsaXR5KCA2ICk7XG4gICAgXHR0aGlzLmVuY29kZXIuc2V0VHJhbnNwYXJlbnQoIG51bGwgKTtcbiAgICBcdHRoaXMuZW5jb2Rlci5zZXRTaXplKCAxNTAsIDE1MCApO1xuICAgICBcdHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICBcdHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgIH1cbiAgICBDQ0dJRkVuY29kZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ0NGcmFtZUVuY29kZXIgKTtcbiAgICBDQ0dJRkVuY29kZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbmNvZGVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIENDR0lGRW5jb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oIGNhbnZhcyApIHtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgIHRoaXMuY3R4LmRyYXdJbWFnZSggY2FudmFzLCAwLCAwICk7XG4gICAgdGhpcy5lbmNvZGVyLmFkZEZyYW1lKCB0aGlzLmN0eCApO1xuICAgIHRoaXMuZW5jb2Rlci5zZXRTaXplKCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcbiAgICB2YXIgcmVhZEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQgKiA0KTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnICk7XG4gICAgY29udGV4dC5yZWFkUGl4ZWxzKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgY29udGV4dC5SR0JBLCBjb250ZXh0LlVOU0lHTkVEX0JZVEUsIHJlYWRCdWZmZXIpO1xuICAgIHRoaXMuZW5jb2Rlci5hZGRGcmFtZSggcmVhZEJ1ZmZlciwgdHJ1ZSApO1xuICAgIH1cbiAgICBDQ0dJRkVuY29kZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVuY29kZXIuZmluaXNoKCk7XG4gICAgfVxuICAgIENDR0lGRW5jb2Rlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcbiAgICB2YXIgYmluYXJ5X2dpZiA9IHRoaXMuZW5jb2Rlci5zdHJlYW0oKS5nZXREYXRhKCk7XG4gICAgdmFyIGRhdGFfdXJsID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCwnK2VuY29kZTY0KGJpbmFyeV9naWYpO1xuICAgIHdpbmRvdy5sb2NhdGlvbiA9IGRhdGFfdXJsO1xuICAgIHJldHVybjtcbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKCBbIGJpbmFyeV9naWYgXSwgeyB0eXBlOiBcIm9jdGV0L3N0cmVhbVwiIH0gKTtcbiAgICB2YXIgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoIGJsb2IgKTtcbiAgICBjYWxsYmFjayggdXJsICk7XG4gICAgfSovXG5cblxuICAgIGZ1bmN0aW9uIENDR0lGRW5jb2RlcihzZXR0aW5ncykge1xuICAgICAgQ0NGcmFtZUVuY29kZXIuY2FsbCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gMzEgLSAoc2V0dGluZ3MucXVhbGl0eSAqIDMwIC8gMTAwIHx8IDEwKTtcbiAgICAgIHNldHRpbmdzLndvcmtlcnMgPSBzZXR0aW5ncy53b3JrZXJzIHx8IDQ7XG4gICAgICB0aGlzLmV4dGVuc2lvbiA9ICcuZ2lmJztcbiAgICAgIHRoaXMubWltZVR5cGUgPSAnaW1hZ2UvZ2lmJztcbiAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB0aGlzLnNpemVTZXQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW5jb2RlciA9IG5ldyBHSUYoe1xuICAgICAgICB3b3JrZXJzOiBzZXR0aW5ncy53b3JrZXJzLFxuICAgICAgICBxdWFsaXR5OiBzZXR0aW5ncy5xdWFsaXR5LFxuICAgICAgICB3b3JrZXJTY3JpcHQ6IHNldHRpbmdzLndvcmtlcnNQYXRoICsgJ2dpZi53b3JrZXIuanMnXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW5jb2Rlci5vbigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mub25Qcm9ncmVzcykge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3Mub25Qcm9ncmVzcyhwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVuY29kZXIub24oJ2ZpbmlzaGVkJywgZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgdmFyIGNiID0gdGhpcy5jYWxsYmFjaztcblxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNiKGJsb2IpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIENDR0lGRW5jb2Rlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENDRnJhbWVFbmNvZGVyLnByb3RvdHlwZSk7XG5cbiAgICBDQ0dJRkVuY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgIGlmICghdGhpcy5zaXplU2V0KSB7XG4gICAgICAgIHRoaXMuZW5jb2Rlci5zZXRPcHRpb24oJ3dpZHRoJywgY2FudmFzLndpZHRoKTtcbiAgICAgICAgdGhpcy5lbmNvZGVyLnNldE9wdGlvbignaGVpZ2h0JywgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuc2l6ZVNldCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuICAgICAgdGhpcy5lbmNvZGVyLmFkZEZyYW1lKHRoaXMuY3R4LCB7XG4gICAgICAgIGNvcHk6IHRydWUsXG4gICAgICAgIGRlbGF5OiB0aGlzLnNldHRpbmdzLnN0ZXBcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdGVwKCk7XG4gICAgICAvKnRoaXMuZW5jb2Rlci5zZXRTaXplKCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcbiAgICAgIHZhciByZWFkQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2FudmFzLndpZHRoICogY2FudmFzLmhlaWdodCAqIDQpO1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApO1xuICAgICAgY29udGV4dC5yZWFkUGl4ZWxzKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgY29udGV4dC5SR0JBLCBjb250ZXh0LlVOU0lHTkVEX0JZVEUsIHJlYWRCdWZmZXIpO1xuICAgICAgdGhpcy5lbmNvZGVyLmFkZEZyYW1lKCByZWFkQnVmZmVyLCB0cnVlICk7Ki9cbiAgICB9O1xuXG4gICAgQ0NHSUZFbmNvZGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLmVuY29kZXIucmVuZGVyKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIENDYXB0dXJlKHNldHRpbmdzKSB7XG4gICAgICB2YXIgX3NldHRpbmdzID0gc2V0dGluZ3MgfHwge30sXG4gICAgICAgICAgX3ZlcmJvc2UsXG4gICAgICAgICAgX3RpbWUsXG4gICAgICAgICAgX3N0YXJ0VGltZSxcbiAgICAgICAgICBfcGVyZm9ybWFuY2VUaW1lLFxuICAgICAgICAgIF9wZXJmb3JtYW5jZVN0YXJ0VGltZSxcbiAgICAgICAgICBfc3RlcCxcbiAgICAgICAgICBfZW5jb2RlcixcbiAgICAgICAgICBfdGltZW91dHMgPSBbXSxcbiAgICAgICAgICBfaW50ZXJ2YWxzID0gW10sXG4gICAgICAgICAgX2ZyYW1lQ291bnQgPSAwLFxuICAgICAgICAgIF9pbnRlcm1lZGlhdGVGcmFtZUNvdW50ID0gMCxcbiAgICAgICAgICBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lQ2FsbGJhY2tzID0gW10sXG4gICAgICAgICAgX2NhcHR1cmluZyA9IGZhbHNlLFxuICAgICAgICAgIF9oYW5kbGVycyA9IHt9O1xuXG4gICAgICBfc2V0dGluZ3MuZnJhbWVyYXRlID0gX3NldHRpbmdzLmZyYW1lcmF0ZSB8fCA2MDtcbiAgICAgIF9zZXR0aW5ncy5tb3Rpb25CbHVyRnJhbWVzID0gMiAqIChfc2V0dGluZ3MubW90aW9uQmx1ckZyYW1lcyB8fCAxKTtcbiAgICAgIF92ZXJib3NlID0gX3NldHRpbmdzLnZlcmJvc2UgfHwgZmFsc2U7XG4gICAgICBfc2V0dGluZ3MuZGlzcGxheSB8fCBmYWxzZTtcbiAgICAgIF9zZXR0aW5ncy5zdGVwID0gMTAwMC4wIC8gX3NldHRpbmdzLmZyYW1lcmF0ZTtcbiAgICAgIF9zZXR0aW5ncy50aW1lTGltaXQgPSBfc2V0dGluZ3MudGltZUxpbWl0IHx8IDA7XG4gICAgICBfc2V0dGluZ3MuZnJhbWVMaW1pdCA9IF9zZXR0aW5ncy5mcmFtZUxpbWl0IHx8IDA7XG4gICAgICBfc2V0dGluZ3Muc3RhcnRUaW1lID0gX3NldHRpbmdzLnN0YXJ0VGltZSB8fCAwO1xuXG4gICAgICB2YXIgX3RpbWVEaXNwbGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIF90aW1lRGlzcGxheS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBfdGltZURpc3BsYXkuc3R5bGUubGVmdCA9IF90aW1lRGlzcGxheS5zdHlsZS50b3AgPSAwO1xuICAgICAgX3RpbWVEaXNwbGF5LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdibGFjayc7XG4gICAgICBfdGltZURpc3BsYXkuc3R5bGUuZm9udEZhbWlseSA9ICdtb25vc3BhY2UnO1xuICAgICAgX3RpbWVEaXNwbGF5LnN0eWxlLmZvbnRTaXplID0gJzExcHgnO1xuICAgICAgX3RpbWVEaXNwbGF5LnN0eWxlLnBhZGRpbmcgPSAnNXB4JztcbiAgICAgIF90aW1lRGlzcGxheS5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgX3RpbWVEaXNwbGF5LnN0eWxlLnpJbmRleCA9IDEwMDAwMDtcbiAgICAgIGlmIChfc2V0dGluZ3MuZGlzcGxheSkgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfdGltZURpc3BsYXkpO1xuICAgICAgdmFyIGNhbnZhc01vdGlvbkJsdXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHZhciBjdHhNb3Rpb25CbHVyID0gY2FudmFzTW90aW9uQmx1ci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdmFyIGJ1ZmZlck1vdGlvbkJsdXI7XG4gICAgICB2YXIgaW1hZ2VEYXRhO1xuXG4gICAgICBfbG9nKCdTdGVwIGlzIHNldCB0byAnICsgX3NldHRpbmdzLnN0ZXAgKyAnbXMnKTtcblxuICAgICAgdmFyIF9lbmNvZGVycyA9IHtcbiAgICAgICAgZ2lmOiBDQ0dJRkVuY29kZXIsXG4gICAgICAgIHdlYm06IENDV2ViTUVuY29kZXIsXG4gICAgICAgIGZmbXBlZ3NlcnZlcjogQ0NGRk1wZWdTZXJ2ZXJFbmNvZGVyLFxuICAgICAgICBwbmc6IENDUE5HRW5jb2RlcixcbiAgICAgICAganBnOiBDQ0pQRUdFbmNvZGVyLFxuICAgICAgICAnd2VibS1tZWRpYXJlY29yZGVyJzogQ0NTdHJlYW1FbmNvZGVyXG4gICAgICB9O1xuICAgICAgdmFyIGN0b3IgPSBfZW5jb2RlcnNbX3NldHRpbmdzLmZvcm1hdF07XG5cbiAgICAgIGlmICghY3Rvcikge1xuICAgICAgICB0aHJvdyAnRXJyb3I6IEluY29ycmVjdCBvciBtaXNzaW5nIGZvcm1hdDogVmFsaWQgZm9ybWF0cyBhcmUgJyArIE9iamVjdC5rZXlzKF9lbmNvZGVycykuam9pbignLCAnKTtcbiAgICAgIH1cblxuICAgICAgX2VuY29kZXIgPSBuZXcgY3Rvcihfc2V0dGluZ3MpO1xuICAgICAgX2VuY29kZXIuc3RlcCA9IF9zdGVwO1xuXG4gICAgICBfZW5jb2Rlci5vbigncHJvY2VzcycsIF9wcm9jZXNzKTtcblxuICAgICAgX2VuY29kZXIub24oJ3Byb2dyZXNzJywgX3Byb2dyZXNzKTtcblxuICAgICAgaWYgKCdwZXJmb3JtYW5jZScgaW4gd2luZG93ID09IGZhbHNlKSB7XG4gICAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBEYXRlLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhhbmtzIElFOFxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoJ25vdycgaW4gd2luZG93LnBlcmZvcm1hbmNlID09IGZhbHNlKSB7XG4gICAgICAgIHZhciBub3dPZmZzZXQgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCkge1xuICAgICAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCkge1xuICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgX29sZFNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCxcbiAgICAgICAgICBfb2xkU2V0SW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwsXG4gICAgICAgICAgX29sZENsZWFySW50ZXJ2YWwgPSB3aW5kb3cuY2xlYXJJbnRlcnZhbCxcbiAgICAgICAgICBfb2xkQ2xlYXJUaW1lb3V0ID0gd2luZG93LmNsZWFyVGltZW91dCxcbiAgICAgICAgICBfb2xkUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICAgICAgICBfb2xkTm93ID0gd2luZG93LkRhdGUubm93LFxuICAgICAgICAgIF9vbGRQZXJmb3JtYW5jZU5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3csXG4gICAgICAgICAgX29sZEdldFRpbWUgPSB3aW5kb3cuRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTsgLy8gRGF0ZS5wcm90b3R5cGUuX29sZEdldFRpbWUgPSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lO1xuXG4gICAgICB2YXIgbWVkaWEgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgIF9sb2coJ0NhcHR1cmVyIHN0YXJ0Jyk7XG5cbiAgICAgICAgX3N0YXJ0VGltZSA9IHdpbmRvdy5EYXRlLm5vdygpO1xuICAgICAgICBfdGltZSA9IF9zdGFydFRpbWUgKyBfc2V0dGluZ3Muc3RhcnRUaW1lO1xuICAgICAgICBfcGVyZm9ybWFuY2VTdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIF9wZXJmb3JtYW5jZVRpbWUgPSBfcGVyZm9ybWFuY2VTdGFydFRpbWUgKyBfc2V0dGluZ3Muc3RhcnRUaW1lO1xuXG4gICAgICAgIHdpbmRvdy5EYXRlLnByb3RvdHlwZS5nZXRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGltZTtcbiAgICAgICAgfTtcblxuICAgICAgICB3aW5kb3cuRGF0ZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aW1lO1xuICAgICAgICB9O1xuXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aW1lKSB7XG4gICAgICAgICAgdGltZSA9IDUwMDA7XG4gICAgICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgdHJpZ2dlclRpbWU6IF90aW1lICsgdGltZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGltZW91dHMucHVzaCh0KTtcblxuICAgICAgICAgIF9sb2coJ1RpbWVvdXQgc2V0IHRvICcgKyB0LnRpbWUpO1xuXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX3RpbWVvdXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoX3RpbWVvdXRzW2pdID09IGlkKSB7XG4gICAgICAgICAgICAgIF90aW1lb3V0cy5zcGxpY2UoaiwgMSk7XG5cbiAgICAgICAgICAgICAgX2xvZygnVGltZW91dCBjbGVhcmVkJyk7XG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHdpbmRvdy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGltZSkge1xuICAgICAgICAgIHZhciB0ID0ge1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgICAgIHRyaWdnZXJUaW1lOiBfdGltZSArIHRpbWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX2ludGVydmFscy5wdXNoKHQpO1xuXG4gICAgICAgICAgX2xvZygnSW50ZXJ2YWwgc2V0IHRvICcgKyB0LnRpbWUpO1xuXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICBfbG9nKCdjbGVhciBJbnRlcnZhbCcpO1xuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3BlcmZvcm1hbmNlVGltZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBob29rQ3VycmVudFRpbWUoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9ob29rZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvb2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9ob29rZWRUaW1lID0gdGhpcy5jdXJyZW50VGltZSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgbWVkaWEucHVzaCh0aGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5faG9va2VkVGltZSArIF9zZXR0aW5ncy5zdGFydFRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MVmlkZW9FbGVtZW50LnByb3RvdHlwZSwgJ2N1cnJlbnRUaW1lJywge1xuICAgICAgICAgICAgZ2V0OiBob29rQ3VycmVudFRpbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEF1ZGlvRWxlbWVudC5wcm90b3R5cGUsICdjdXJyZW50VGltZScsIHtcbiAgICAgICAgICAgIGdldDogaG9va0N1cnJlbnRUaW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9sb2coZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfc3RhcnQoKSB7XG4gICAgICAgIF9pbml0KCk7XG5cbiAgICAgICAgX2VuY29kZXIuc3RhcnQoKTtcblxuICAgICAgICBfY2FwdHVyaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3N0b3AoKSB7XG4gICAgICAgIF9jYXB0dXJpbmcgPSBmYWxzZTtcblxuICAgICAgICBfZW5jb2Rlci5zdG9wKCk7XG5cbiAgICAgICAgX2Rlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX2NhbGwoZm4sIHApIHtcbiAgICAgICAgX29sZFNldFRpbWVvdXQoZm4sIDAsIHApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfc3RlcCgpIHtcbiAgICAgICAgLy9fb2xkUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBfcHJvY2VzcyApO1xuICAgICAgICBfY2FsbChfcHJvY2Vzcyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgICBfbG9nKCdDYXB0dXJlciBzdG9wJyk7XG5cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQgPSBfb2xkU2V0VGltZW91dDtcbiAgICAgICAgd2luZG93LnNldEludGVydmFsID0gX29sZFNldEludGVydmFsO1xuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCA9IF9vbGRDbGVhckludGVydmFsO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0ID0gX29sZENsZWFyVGltZW91dDtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IF9vbGRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgICAgIHdpbmRvdy5EYXRlLnByb3RvdHlwZS5nZXRUaW1lID0gX29sZEdldFRpbWU7XG4gICAgICAgIHdpbmRvdy5EYXRlLm5vdyA9IF9vbGROb3c7XG4gICAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPSBfb2xkUGVyZm9ybWFuY2VOb3c7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF91cGRhdGVUaW1lKCkge1xuICAgICAgICB2YXIgc2Vjb25kcyA9IF9mcmFtZUNvdW50IC8gX3NldHRpbmdzLmZyYW1lcmF0ZTtcblxuICAgICAgICBpZiAoX3NldHRpbmdzLmZyYW1lTGltaXQgJiYgX2ZyYW1lQ291bnQgPj0gX3NldHRpbmdzLmZyYW1lTGltaXQgfHwgX3NldHRpbmdzLnRpbWVMaW1pdCAmJiBzZWNvbmRzID49IF9zZXR0aW5ncy50aW1lTGltaXQpIHtcbiAgICAgICAgICBfc3RvcCgpO1xuXG4gICAgICAgICAgX3NhdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkID0gbmV3IERhdGUobnVsbCk7XG4gICAgICAgIGQuc2V0U2Vjb25kcyhzZWNvbmRzKTtcblxuICAgICAgICBpZiAoX3NldHRpbmdzLm1vdGlvbkJsdXJGcmFtZXMgPiAyKSB7XG4gICAgICAgICAgX3RpbWVEaXNwbGF5LnRleHRDb250ZW50ID0gJ0NDYXB0dXJlICcgKyBfc2V0dGluZ3MuZm9ybWF0ICsgJyB8ICcgKyBfZnJhbWVDb3VudCArICcgZnJhbWVzICgnICsgX2ludGVybWVkaWF0ZUZyYW1lQ291bnQgKyAnIGludGVyKSB8ICcgKyBkLnRvSVNPU3RyaW5nKCkuc3Vic3RyKDExLCA4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGltZURpc3BsYXkudGV4dENvbnRlbnQgPSAnQ0NhcHR1cmUgJyArIF9zZXR0aW5ncy5mb3JtYXQgKyAnIHwgJyArIF9mcmFtZUNvdW50ICsgJyBmcmFtZXMgfCAnICsgZC50b0lTT1N0cmluZygpLnN1YnN0cigxMSwgOCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX2NoZWNrRnJhbWUoY2FudmFzKSB7XG4gICAgICAgIGlmIChjYW52YXNNb3Rpb25CbHVyLndpZHRoICE9PSBjYW52YXMud2lkdGggfHwgY2FudmFzTW90aW9uQmx1ci5oZWlnaHQgIT09IGNhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgICBjYW52YXNNb3Rpb25CbHVyLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICAgIGNhbnZhc01vdGlvbkJsdXIuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICBidWZmZXJNb3Rpb25CbHVyID0gbmV3IFVpbnQxNkFycmF5KGNhbnZhc01vdGlvbkJsdXIuaGVpZ2h0ICogY2FudmFzTW90aW9uQmx1ci53aWR0aCAqIDQpO1xuICAgICAgICAgIGN0eE1vdGlvbkJsdXIuZmlsbFN0eWxlID0gJyMwJztcbiAgICAgICAgICBjdHhNb3Rpb25CbHVyLmZpbGxSZWN0KDAsIDAsIGNhbnZhc01vdGlvbkJsdXIud2lkdGgsIGNhbnZhc01vdGlvbkJsdXIuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfYmxlbmRGcmFtZShjYW52YXMpIHtcbiAgICAgICAgLy9fbG9nKCAnSW50ZXJtZWRpYXRlIEZyYW1lOiAnICsgX2ludGVybWVkaWF0ZUZyYW1lQ291bnQgKTtcbiAgICAgICAgY3R4TW90aW9uQmx1ci5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcbiAgICAgICAgaW1hZ2VEYXRhID0gY3R4TW90aW9uQmx1ci5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzTW90aW9uQmx1ci53aWR0aCwgY2FudmFzTW90aW9uQmx1ci5oZWlnaHQpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYnVmZmVyTW90aW9uQmx1ci5sZW5ndGg7IGogKz0gNCkge1xuICAgICAgICAgIGJ1ZmZlck1vdGlvbkJsdXJbal0gKz0gaW1hZ2VEYXRhLmRhdGFbal07XG4gICAgICAgICAgYnVmZmVyTW90aW9uQmx1cltqICsgMV0gKz0gaW1hZ2VEYXRhLmRhdGFbaiArIDFdO1xuICAgICAgICAgIGJ1ZmZlck1vdGlvbkJsdXJbaiArIDJdICs9IGltYWdlRGF0YS5kYXRhW2ogKyAyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9pbnRlcm1lZGlhdGVGcmFtZUNvdW50Kys7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF9zYXZlRnJhbWUoKSB7XG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBidWZmZXJNb3Rpb25CbHVyLmxlbmd0aDsgaiArPSA0KSB7XG4gICAgICAgICAgZGF0YVtqXSA9IGJ1ZmZlck1vdGlvbkJsdXJbal0gKiAyIC8gX3NldHRpbmdzLm1vdGlvbkJsdXJGcmFtZXM7XG4gICAgICAgICAgZGF0YVtqICsgMV0gPSBidWZmZXJNb3Rpb25CbHVyW2ogKyAxXSAqIDIgLyBfc2V0dGluZ3MubW90aW9uQmx1ckZyYW1lcztcbiAgICAgICAgICBkYXRhW2ogKyAyXSA9IGJ1ZmZlck1vdGlvbkJsdXJbaiArIDJdICogMiAvIF9zZXR0aW5ncy5tb3Rpb25CbHVyRnJhbWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4TW90aW9uQmx1ci5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgICAgICBfZW5jb2Rlci5hZGQoY2FudmFzTW90aW9uQmx1cik7XG5cbiAgICAgICAgX2ZyYW1lQ291bnQrKztcbiAgICAgICAgX2ludGVybWVkaWF0ZUZyYW1lQ291bnQgPSAwO1xuXG4gICAgICAgIF9sb2coJ0Z1bGwgTUIgRnJhbWUhICcgKyBfZnJhbWVDb3VudCArICcgJyArIF90aW1lKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJ1ZmZlck1vdGlvbkJsdXIubGVuZ3RoOyBqICs9IDQpIHtcbiAgICAgICAgICBidWZmZXJNb3Rpb25CbHVyW2pdID0gMDtcbiAgICAgICAgICBidWZmZXJNb3Rpb25CbHVyW2ogKyAxXSA9IDA7XG4gICAgICAgICAgYnVmZmVyTW90aW9uQmx1cltqICsgMl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2MoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX2NhcHR1cmUoY2FudmFzKSB7XG4gICAgICAgIGlmIChfY2FwdHVyaW5nKSB7XG4gICAgICAgICAgaWYgKF9zZXR0aW5ncy5tb3Rpb25CbHVyRnJhbWVzID4gMikge1xuICAgICAgICAgICAgX2NoZWNrRnJhbWUoY2FudmFzKTtcblxuICAgICAgICAgICAgX2JsZW5kRnJhbWUoY2FudmFzKTtcblxuICAgICAgICAgICAgaWYgKF9pbnRlcm1lZGlhdGVGcmFtZUNvdW50ID49IDAuNSAqIF9zZXR0aW5ncy5tb3Rpb25CbHVyRnJhbWVzKSB7XG4gICAgICAgICAgICAgIF9zYXZlRnJhbWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9zdGVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9lbmNvZGVyLmFkZChjYW52YXMpO1xuXG4gICAgICAgICAgICBfZnJhbWVDb3VudCsrO1xuXG4gICAgICAgICAgICBfbG9nKCdGdWxsIEZyYW1lISAnICsgX2ZyYW1lQ291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfcHJvY2VzcygpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSAxMDAwIC8gX3NldHRpbmdzLmZyYW1lcmF0ZTtcbiAgICAgICAgdmFyIGR0ID0gKF9mcmFtZUNvdW50ICsgX2ludGVybWVkaWF0ZUZyYW1lQ291bnQgLyBfc2V0dGluZ3MubW90aW9uQmx1ckZyYW1lcykgKiBzdGVwO1xuICAgICAgICBfdGltZSA9IF9zdGFydFRpbWUgKyBkdDtcbiAgICAgICAgX3BlcmZvcm1hbmNlVGltZSA9IF9wZXJmb3JtYW5jZVN0YXJ0VGltZSArIGR0O1xuICAgICAgICBtZWRpYS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgdi5faG9va2VkVGltZSA9IGR0IC8gMTAwMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3VwZGF0ZVRpbWUoKTtcblxuICAgICAgICBfbG9nKCdGcmFtZTogJyArIF9mcmFtZUNvdW50ICsgJyAnICsgX2ludGVybWVkaWF0ZUZyYW1lQ291bnQpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX3RpbWVvdXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKF90aW1lID49IF90aW1lb3V0c1tqXS50cmlnZ2VyVGltZSkge1xuICAgICAgICAgICAgX2NhbGwoX3RpbWVvdXRzW2pdLmNhbGxiYWNrKTsgLy9jb25zb2xlLmxvZyggJ3RpbWVvdXQhJyApO1xuXG5cbiAgICAgICAgICAgIF90aW1lb3V0cy5zcGxpY2UoaiwgMSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2ludGVydmFscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChfdGltZSA+PSBfaW50ZXJ2YWxzW2pdLnRyaWdnZXJUaW1lKSB7XG4gICAgICAgICAgICBfY2FsbChfaW50ZXJ2YWxzW2pdLmNhbGxiYWNrKTtcblxuICAgICAgICAgICAgX2ludGVydmFsc1tqXS50cmlnZ2VyVGltZSArPSBfaW50ZXJ2YWxzW2pdLnRpbWU7IC8vY29uc29sZS5sb2coICdpbnRlcnZhbCEnICk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICBfY2FsbChjYiwgX3RpbWUgLSBnX3N0YXJ0VGltZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVDYWxsYmFja3MgPSBbXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3NhdmUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgICAgIGRvd25sb2FkKGJsb2IsIF9lbmNvZGVyLmZpbGVuYW1lICsgX2VuY29kZXIuZXh0ZW5zaW9uLCBfZW5jb2Rlci5taW1lVHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9lbmNvZGVyLnNhdmUoY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfbG9nKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKF92ZXJib3NlKSBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX29uKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIF9oYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfZW1pdChldmVudCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IF9oYW5kbGVyc1tldmVudF07XG5cbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF9wcm9ncmVzcyhwcm9ncmVzcykge1xuICAgICAgICBfZW1pdCgncHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBfc3RhcnQsXG4gICAgICAgIGNhcHR1cmU6IF9jYXB0dXJlLFxuICAgICAgICBzdG9wOiBfc3RvcCxcbiAgICAgICAgc2F2ZTogX3NhdmUsXG4gICAgICAgIG9uOiBfb25cbiAgICAgIH07XG4gICAgfVxuICAgIChmcmVlV2luZG93IHx8IGZyZWVTZWxmIHx8IHt9KS5DQ2FwdHVyZSA9IENDYXB0dXJlOyAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcblxuICAgIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcy5cbiAgICAgICAgaWYgKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gQ0NhcHR1cmUpLkNDYXB0dXJlID0gQ0NhcHR1cmU7XG4gICAgICAgIH0gLy8gRXhwb3J0IGZvciBDb21tb25KUyBzdXBwb3J0LlxuXG5cbiAgICAgICAgZnJlZUV4cG9ydHMuQ0NhcHR1cmUgPSBDQ2FwdHVyZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICAgICAgcm9vdC5DQ2FwdHVyZSA9IENDYXB0dXJlO1xuICAgICAgfVxuICB9KSgpO1xufSkoQ0NhcHR1cmUkMiwgQ0NhcHR1cmUkMi5leHBvcnRzKTtcblxudmFyIENDYXB0dXJlID0gQ0NhcHR1cmUkMi5leHBvcnRzO1xuXG52YXIgQ0NhcHR1cmUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKC8qI19fUFVSRV9fKi9PYmplY3QuYXNzaWduKC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpLCBDQ2FwdHVyZSQyLmV4cG9ydHMsIHtcbiAgJ2RlZmF1bHQnOiBDQ2FwdHVyZVxufSkpO1xuXG5leHBvcnQgeyBDQ2FwdHVyZSQxIGFzIEMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNDYXB0dXJlLWQ1YjIzYmEwLmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../react-swift/dist/CCapture-d5b23ba0.js\n");

/***/ }),

/***/ "../../react-swift/dist/_commonjsHelpers-1c8beb5f.js":
/*!***********************************************************!*\
  !*** ../../react-swift/dist/_commonjsHelpers-1c8beb5f.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"c\": function() { return /* binding */ commonjsGlobal; }\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\n//# sourceMappingURL=_commonjsHelpers-1c8beb5f.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3JlYWN0LXN3aWZ0L2Rpc3QvX2NvbW1vbmpzSGVscGVycy0xYzhiZWI1Zi5qcz8yZDYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFK0I7QUFDL0IiLCJmaWxlIjoiLi4vLi4vcmVhY3Qtc3dpZnQvZGlzdC9fY29tbW9uanNIZWxwZXJzLTFjOGJlYjVmLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmV4cG9ydCB7IGNvbW1vbmpzR2xvYmFsIGFzIGMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9jb21tb25qc0hlbHBlcnMtMWM4YmViNWYuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../react-swift/dist/_commonjsHelpers-1c8beb5f.js\n");

/***/ })

}]);